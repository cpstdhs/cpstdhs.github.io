
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>3. 데이터 모델 &#8212; Python 3.9.14 문서</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.9.14 문서에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="4. 실행 모델" href="executionmodel.html" />
    <link rel="prev" title="2. 어휘 분석" href="lexical_analysis.html" />
    <link rel="canonical" href="https://docs.python.org/3/reference/datamodel.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="빠른 검색"/>
            <input type="submit" value="이동"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. 데이터 모델</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. 객체, 값, 형</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. 표준형 계층</a></li>
<li><a class="reference internal" href="#special-method-names">3.3. 특수 메서드 이름들</a><ul>
<li><a class="reference internal" href="#basic-customization">3.3.1. 기본적인 커스터마이제이션</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.3.2. 어트리뷰트 액세스 커스터마이제이션</a><ul>
<li><a class="reference internal" href="#customizing-module-attribute-access">3.3.2.1. 모듈 어트리뷰트 액세스 커스터마이제이션</a></li>
<li><a class="reference internal" href="#implementing-descriptors">3.3.2.2. 디스크립터 구현하기</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.3.2.3. 디스크립터 호출하기</a></li>
<li><a class="reference internal" href="#slots">3.3.2.4. __slots__</a><ul>
<li><a class="reference internal" href="#notes-on-using-slots">3.3.2.4.1. <em>__slots__</em> 사용에 관한 노트</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.3.3. 클래스 생성 커스터마이제이션</a><ul>
<li><a class="reference internal" href="#metaclasses">3.3.3.1. 메타 클래스</a></li>
<li><a class="reference internal" href="#resolving-mro-entries">3.3.3.2. MRO 항목 결정하기</a></li>
<li><a class="reference internal" href="#determining-the-appropriate-metaclass">3.3.3.3. 적절한 메타 클래스 선택하기</a></li>
<li><a class="reference internal" href="#preparing-the-class-namespace">3.3.3.4. 클래스 이름 공간 준비하기</a></li>
<li><a class="reference internal" href="#executing-the-class-body">3.3.3.5. 클래스 바디 실행하기</a></li>
<li><a class="reference internal" href="#creating-the-class-object">3.3.3.6. 클래스 객체 만들기</a></li>
<li><a class="reference internal" href="#uses-for-metaclasses">3.3.3.7. 메타 클래스의 용도</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.3.4. 인스턴스 및 서브 클래스 검사 커스터마이제이션</a></li>
<li><a class="reference internal" href="#emulating-generic-types">3.3.5. 제네릭 형 흉내 내기</a><ul>
<li><a class="reference internal" href="#the-purpose-of-class-getitem">3.3.5.1. The purpose of <em>__class_getitem__</em></a></li>
<li><a class="reference internal" href="#class-getitem-versus-getitem">3.3.5.2. <em>__class_getitem__</em> versus <em>__getitem__</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#emulating-callable-objects">3.3.6. 콜러블 객체 흉내 내기</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.3.7. 컨테이너형 흉내 내기</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.3.8. 숫자 형 흉내 내기</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.3.9. with 문 컨텍스트 관리자</a></li>
<li><a class="reference internal" href="#special-method-lookup">3.3.10. 특수 메서드 조회</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coroutines">3.4. 코루틴(Coroutines)</a><ul>
<li><a class="reference internal" href="#awaitable-objects">3.4.1. 어웨이터블 객체(Awaitable Objects)</a></li>
<li><a class="reference internal" href="#coroutine-objects">3.4.2. 코루틴 객체(Coroutine Objects)</a></li>
<li><a class="reference internal" href="#asynchronous-iterators">3.4.3. 비동기 이터레이터(Asynchronous Iterators)</a></li>
<li><a class="reference internal" href="#asynchronous-context-managers">3.4.4. 비동기 컨텍스트 관리자</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="lexical_analysis.html"
                        title="이전 장"><span class="section-number">2. </span>어휘 분석</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="executionmodel.html"
                        title="다음 장"><span class="section-number">4. </span>실행 모델</a></p>
  <div role="note" aria-label="source link">
    <h3>현재 문서</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.9/Doc/reference/datamodel.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 실행 모델"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. 어휘 분석"
             accesskey="P">이전</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.9.14 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">파이썬 언어 레퍼런스</a> &#187;</li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="data-model">
<span id="datamodel"></span><h1><span class="section-number">3. </span>데이터 모델<a class="headerlink" href="#data-model" title="제목 주소">¶</a></h1>
<section id="objects-values-and-types">
<span id="objects"></span><h2><span class="section-number">3.1. </span>객체, 값, 형<a class="headerlink" href="#objects-values-and-types" title="제목 주소">¶</a></h2>
<p id="index-0"><em class="dfn">객체 (Objects)</em>는 파이썬이 데이터(data)를 추상화한 것(abstraction)입니다. 파이썬 프로그램의 모든 데이터는 객체나 객체 간의 관계로 표현됩니다. (폰 노이만(Von Neumann)의 “프로그램 내장식 컴퓨터(stored program computer)” 모델을 따르고, 또 그 관점에서 코드 역시 객체로 표현됩니다.)</p>
<span class="target" id="index-1"></span><p>모든 객체는 아이덴티티(identity), 형(type), 값(value)을 갖습니다. 객체의 <em>아이덴티티</em> 는 한 번 만들어진 후에는 변경되지 않습니다. 메모리상에서의 객체의 주소로 생각해도 좋습니다. ‘<a class="reference internal" href="expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>’ 연산자는 두 객체의 아이덴티티를 비교합니다; <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> 함수는 아이덴티티를 정수로 표현한 값을 돌려줍니다.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> CPython 의 경우, <code class="docutils literal notranslate"><span class="pre">id(x)</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span></code> 가 저장된 메모리의 주소입니다.</p>
</div>
<p>객체의 형은 객체가 지원하는 연산들을 정의하고 (예를 들어, “길이를 갖고 있나?”) 그 형의 객체들이 가질 수 있는 가능한 값들을 정의합니다. <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 함수는 객체의 형(이것 역시 객체다)을 돌려줍니다. 아이덴티티와 마찬가지로, 객체의 <em class="dfn">형 (type)</em> 역시 변경되지 않습니다. <a class="footnote-reference brackets" href="#id8" id="id1">1</a></p>
<p>어떤 객체들의 <em>값</em> 은 변경할 수 있습니다. 값을 변경할 수 있는 객체들을 <em>가변(mutable)</em> 이라고 합니다. 일단 만들어진 후에 값을 변경할 수 없는 객체들을 <em>불변(immutable)</em> 이라고 합니다. (가변 객체에 대한 참조를 저장하고 있는 불변 컨테이너의 값은 가변 객체의 값이 변할 때 변경된다고 볼 수도 있습니다; 하지만 저장하고 있는 객체들의 집합이 바뀔 수 없으므로 컨테이너는 여전히 불변이라고 여겨집니다. 따라서 불변성은 엄밀하게는 변경 불가능한 값을 갖는 것과는 다릅니다. 좀 더 미묘합니다.) 객체의 가변성(mutability)은 그것의 형에 의해 결정됩니다; 예를 들어 숫자, 문자열, 튜플(tuple)은 불변이지만, 딕셔너리(dictionary) 와 리스트(list)는 가변입니다.</p>
<p id="index-2">객체는 결코 명시적으로 파괴되지 않습니다; 더 참조되지 않을 때(unreachable) 가비지 수거(garbage collect)됩니다. 구현이 가비지 수거를 지연시키거나 아예 생략하는 것이 허락됩니다 — 아직 참조되는 객체들을 수거하지 않는 이상 가비지 수거가 어떤 식으로 구현되는지는 구현의 품질 문제입니다.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> CPython 은 현재 참조 횟수 계산(reference-counting) 방식을 사용하는데, (선택 사항으로) 순환적으로 연결된 가비지의 지연된 감지가 추가됩니다. 이 방법으로 대부분 객체를 참조가 제거되자마자 수거할 수 있습니다. 하지만 순환 참조가 있는 가비지들을 수거한다는 보장은 없습니다. 순환적 가비지 수거의 제어에 관한 정보는 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 모듈 문서를 참조하면 됩니다. 다른 구현들은 다른 식으로 동작하고, CPython 도 변경될 수 있습니다. 참조가 제거될 때 즉각적으로 파이널리제이션(finalization)되는 것에 의존하지 말아야 합니다 (그래서 항상 파일을 명시적으로 닫아주어야 합니다).</p>
</div>
<p>구현이 제공하는 추적이나 디버깅 장치의 사용은 그렇지 않으면 수거될 수 있는 객체들을 살아있도록 만들 수 있음에 주의해야 합니다. 또한 ‘<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>…<a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a>’ 문으로 예외를 잡는 것도 객체를 살아있게 만들 수 있습니다.</p>
<p>어떤 객체들은 열린 파일이나 창 같은 “외부(external)” 자원들에 대한 참조를 포함합니다. 이 자원들은 객체가 가비지 수거될 때 반납된다고 이해되지만, 가비지 수거는 보장되는 것이 아니므로, 그런 객체들은 외부자원을 반납하는 명시적인 방법 또한 제공합니다. 보통 <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> 메서드다. 프로그램을 작성할 때는 그러한 객체들을 항상 명시적으로 닫아야(close) 합니다. ‘<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>…<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a>’ 문과 ‘<a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>’ 문은 이렇게 하는 편리한 방법을 제공합니다.</p>
<p id="index-3">어떤 객체들은 다른 객체에 대한 참조를 포함하고 있습니다. 이런 것들을 <em>컨테이너(container)</em> 라고 부릅니다. 튜플, 리스트, 딕셔너리등이 컨테이너의 예입니다. 이 참조들은 컨테이너의 값의 일부입니다. 대부분은, 우리가 컨테이너의 값을 논할 때는, 들어있는 객체들의 아이덴티티 보다는 값을 따집니다. 하지만, 컨테이너의 가변성에 대해 논할 때는 직접 가진 객체들의 아이덴티티만을 따집니다. 그래서, (튜플 같은) 불변 컨테이너가 가변 객체로의 참조를 하고 있다면, 그 가변 객체가 변경되면 컨테이너의 값도 변경됩니다.</p>
<p>형은 거의 모든 측면에서 객체가 동작하는 방법에 영향을 줍니다. 객체의 아이덴티디가 갖는 중요성조차도 어떤 면에서는 영향을 받습니다: 불변형의 경우, 새 값을 만드는 연산은 실제로는 이미 존재하는 객체 중에서 같은 형과 값을 갖는 것을 돌려줄 수 있습니다. 반면에 가변 객체에서는 이런 것이 허용되지 않습니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">1</span></code> 후에, <code class="docutils literal notranslate"><span class="pre">a</span></code> 와 <code class="docutils literal notranslate"><span class="pre">b</span></code> 는 값 1을 갖는 같은 객체일 수도 있고, 아닐 수도 있습니다. 하지만 <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">[];</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> 후에, <code class="docutils literal notranslate"><span class="pre">c</span></code> 와 <code class="docutils literal notranslate"><span class="pre">d</span></code> 는 두 개의 서로 다르고, 독립적이고, 새로 만들어진 빈 리스트임이 보장됩니다. (<code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> 는 객은 객체를 <code class="docutils literal notranslate"><span class="pre">c</span></code> 와 <code class="docutils literal notranslate"><span class="pre">d</span></code> 에 대입합니다.)</p>
</section>
<section id="the-standard-type-hierarchy">
<span id="types"></span><h2><span class="section-number">3.2. </span>표준형 계층<a class="headerlink" href="#the-standard-type-hierarchy" title="제목 주소">¶</a></h2>
<p id="index-4">아래에 파이썬에 내장된 형들의 목록이 있습니다. (구현에 따라 C 나 자바나 다른 언어로 작성된) 확장 모듈들은 추가의 형을 정의할 수 있습니다. 파이썬의 미래 버전 역시 형 계층에 형을 더할 수 있는데 (예를 들어, 유리수, 효율적으로 저장된 정수 배열 등등), 표준 라이브러리를 통해 추가될 가능성이 더 크기는 합니다.</p>
<p id="index-5">아래에 나오는 몇몇 형에 대한 설명은 ‘특수 어트리뷰트(special attribute)’ 를 나열하는 문단을 포함합니다. 이것들은 구현에 접근할 방법을 제공하는데, 일반적인 사용을 위한 것이 아닙니다. 정의는 앞으로 변경될 수 있습니다.</p>
<dl>
<dt>None</dt><dd><p id="index-6">이 형은 하나의 값만을 갖습니다. 이 값을 갖는 하나의 객체가 존재합니다. 이 객체에는 내장된 이름 <code class="docutils literal notranslate"><span class="pre">None</span></code> 을 통해 접근합니다. 여러 가지 상황에서 값의 부재를 알리는 데 사용됩니다. 예를 들어, 명시적으로 뭔가를 돌려주지 않는 함수의 반환 값입니다. 논리값은 거짓입니다.</p>
</dd>
<dt>NotImplemented</dt><dd><p id="index-7">이 형은 하나의 값만을 갖습니다. 이 값을 갖는 하나의 객체가 존재합니다. 이 객체에는 내장된 이름 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 을 통해 접근합니다. 숫자 메서드(numeric method)와 비교(rich comparison) 메서드는 제공된 피연산자에 대해 연산이 구현되지 않으면 이 값을 돌려줘야 합니다. (그러면 인터프리터는 연산자에 따라 뒤집힌 연산이나, 어떤 다른 대안을 시도합니다.) 불리언 문맥에서 평가되지 않아야 합니다.</p>
<p>더 자세한 내용은 <a class="reference internal" href="../library/numbers.html#implementing-the-arithmetic-operations"><span class="std std-ref">산술 연산 구현</span></a> 을 참고하십시오.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span>불리언 문맥에서 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>를 평가하는 것은 폐지되었습니다. 현재는 참으로 평가되지만, <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>를 방출합니다. 향후 버전의 파이썬에서는 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킬 것입니다.</p>
</div>
</dd>
<dt>Ellipsis</dt><dd><p id="index-8">이 형은 하나의 값만을 갖습니다. 이 값을 갖는 하나의 객체가 존재합니다. 이 객체에는 리터럴 <code class="docutils literal notranslate"><span class="pre">...</span></code> 이나 내장된 이름 <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> 을 통해 접근합니다. 논리값은 참입니다.</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Number" title="numbers.Number"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a></dt><dd><p id="index-9">이것들은 숫자 리터럴에 의해 만들어지고, 산술 연산과 내장 산술 함수들이 결과로 돌려줍니다. 숫자 객체는 불변입니다; 한 번 값이 만들어지면 절대 변하지 않습니다. 파이썬의 숫자는 당연히 수학적인 숫자들과 밀접하게 관련되어 있습니다, 하지만 컴퓨터의 숫자 표현상의 제약을 받고 있습니다.</p>
<p>The string representations of the numeric classes, computed by
<a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> and <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>, have the following
properties:</p>
<ul class="simple">
<li><p>클래스 생성자에 전달될 때 원래 숫자 값을 가진 객체를 생성하는 유효한 숫자 리터럴 입니다.</p></li>
<li><p>가능하면, 표현은 10진법입니다.</p></li>
<li><p>소수점 앞의 단일 0을 제외하고, 선행 0은 표시되지 않습니다.</p></li>
<li><p>소수점 뒤의 단일 0을 제외하고, 후행 0은 표시되지 않습니다.</p></li>
<li><p>부호는 숫자가 음수일 때만 표시됩니다.</p></li>
</ul>
<p>파이썬은 정수, 실수, 복소수를 구분합니다:</p>
<dl>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a></dt><dd><p id="index-10">이것들은 수학적인 정수 집합(양과 음)에 속하는 요소들을 나타냅니다.</p>
<p>두 가지 종류의 정수가 있습니다:</p>
<dl>
<dt>정수 (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>)</dt><dd><p>이것은 (가상) 메모리가 허락하는 한, 제약 없는 범위의 숫자를 표현합니다. 시프트(shift)와 마스크(mask) 연산이 목적일 때는 이진 표현이 가정되고, 음수는 일종의 2의 보수(2’s complement)로 표현되는데, 부호 비트가 왼쪽으로 무한히 확장된 것과 같은 효과를 줍니다.</p>
</dd>
<dt>불린 (<a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>)</dt><dd><p id="index-11">이것은 논리값 거짓과 참을 나타냅니다. <code class="docutils literal notranslate"><span class="pre">False</span></code> 와 <code class="docutils literal notranslate"><span class="pre">True</span></code> 두 객체만 불린 형 객체입니다. 불린 형은 int 형의 자식형(subtype)이고, 대부분 상황에서 각기 0과1처럼 동작합니다. 예외는 문자열로 변환되는 경우인데, 각기 문자열 <code class="docutils literal notranslate"><span class="pre">&quot;False&quot;</span></code> 와 <code class="docutils literal notranslate"><span class="pre">&quot;True&quot;</span></code> 가 반환됩니다.</p>
</dd>
</dl>
<p id="index-12">정수 표현 규칙은 음수가 포함된 시프트와 마스크 연산에 가장 의미 있는 해석을 제공하기 위한 것입니다.</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code></a> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>)</dt><dd><p id="index-13">이것들은 기계 수준의 배정도(double precision) 부동 소수점 수를 나타냅니다. 허락되는 값의 범위와 오버플로의 처리에 관해서는 하부 기계의 설계(와 C 나 자바 구현)에 따르는 수밖에 없습니다. 파이썬은 단정도(single precision) 부동 소수점 수를 지원하지 않습니다; 이것들을 사용하는 이유가 되는 프로세서와 메모리의 절감은 파이썬에서 객체를 사용하는데 들어가는 비용과 상쇄되어 미미해집니다. 그 때문에 두 가지 종류의 부동 소수점 수로 언어를 복잡하게 만들만한 가치가 없습니다.</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Complex" title="numbers.Complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code></a> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>)</dt><dd><p id="index-14">이것들은 기계 수준 배정도 부동 소수점 수의 쌍으로 복소수를 나타냅니다. 부동 소수점 수와 한계와 문제점을 공유합니다. 복소수 <code class="docutils literal notranslate"><span class="pre">z</span></code> 의 실수부와 허수부는, 읽기 전용 어트리뷰트 <code class="docutils literal notranslate"><span class="pre">z.real</span></code> 와 <code class="docutils literal notranslate"><span class="pre">z.imag</span></code> 로 꺼낼 수 있습니다.</p>
</dd>
</dl>
</dd>
<dt>시퀀스들</dt><dd><p id="index-15">음이 아닌 정수로 인덱싱(indexing)될 수 있는 유한한 길이의 순서 있는 집합을 나타냅니다. 내장함수 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 은 시퀀스가 가진 항목들의 개수를 돌려줍니다. 시퀀스의 길이가 <em>n</em> 일 때, 인덱스(index) 집합은 숫자 0, 1, …, <em>n</em>-1을 포함합니다. 시퀀스 <em>a</em> 의 항목 <em>i</em> 는 <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> 로 선택됩니다.</p>
<p id="index-16">시퀀스는 슬라이싱도 지원합니다: <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> 는 <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>k</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em> 를 만족하는 모든 항목 <em>k</em> 를 선택합니다. 표현식에서 사용될 때, 슬라이스는 같은 형의 시퀀스입니다. 인덱스 집합은 0에서 시작되도록 다시 번호 매겨집니다.</p>
<p>어떤 시퀀스는 세 번째 “스텝(step)” 매개변수를 사용하는 “확장 슬라이싱(extended slicing)”도 지원합니다: <code class="docutils literal notranslate"><span class="pre">a[i:j:k]</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code>, <em>n</em> <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> <code class="docutils literal notranslate"><span class="pre">0</span></code>, <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>x</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em> 를 만족하는 모든 항목 <em>x</em> 를 선택합니다.</p>
<p>시퀀스는 불변성에 따라 구분됩니다</p>
<dl>
<dt>불변 시퀀스</dt><dd><p id="index-17">불변 시퀀스 형의 객체는 일단 만들어진 후에는 변경될 수 없습니다. (만약 다른 객체로의 참조를 포함하면, 그 객체는 가변일 수 있고, 변경될 수 있습니다; 하지만, 불변 객체로부터 참조되는 객체의 집합 자체는 변경될 수 없습니다.)</p>
<p>다음과 같은 형들은 불변 시퀀스입니다:</p>
<dl id="index-18">
<dt>문자열(Strings)</dt><dd><p id="index-19">문자열은 유니코드 코드 포인트(Unicode code point)들을 표현하는 값들의 시퀀스입니다. <code class="docutils literal notranslate"><span class="pre">U+0000</span> <span class="pre">-</span> <span class="pre">U+10FFFF</span></code> 범위의 모든 코드 포인트들은 문자열로 표현될 수 있습니다. 파이썬에는 <code class="xref c c-type docutils literal notranslate"><span class="pre">char</span></code> 형이 없습니다. 대신에 문자열에 있는 각 코드 포인트는 길이 <code class="docutils literal notranslate"><span class="pre">1</span></code> 인 문자열 객체로 표현됩니다. 내장 함수 <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a> 는 코드 포인트를 문자열 형식에서 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code> 범위의 정수로 변환합니다; <a class="reference internal" href="../library/functions.html#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a> 은 범위 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code> 의 정수를 해당하는 길이 <code class="docutils literal notranslate"><span class="pre">1</span></code> 의 문자열 객체로 변환합니다. <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> 는 주어진 텍스트 인코딩을 사용해서 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 을 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 로 변환하고, <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> 는 그 반대 작업을 수행합니다.</p>
</dd>
<dt>튜플(Tuples)</dt><dd><p id="index-20">튜플의 항목은 임의의 파이썬 객체입니다. 두 개 이상의 항목으로 구성되는 튜플은 콤마로 분리된 표현식의 목록으로 만들 수 있습니다. 하나의 항목으로 구성된 튜플(싱글턴,singleton)은 표현식에 콤마를 붙여서 만들 수 있습니다(괄호로 표현식을 묶을 수 있으므로, 표현식 만으로는 튜플을 만들지 않습니다). 빈 튜플은 한 쌍의 빈 괄호로 만들 수 있습니다.</p>
</dd>
<dt>바이트열(Bytes)</dt><dd><p id="index-21">바이트열(bytes) 객체는 불변 배열입니다. 항목은 8-비트 바이트인데, 0 &lt;= x &lt; 256 범위의 정수로 표현됩니다. 바이트 객체를 만들 때는 바이트열 리터럴(<code class="docutils literal notranslate"><span class="pre">b'abc'</span></code> 와 같은) 과 내장 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes()</span></code></a> 생성자(constructor)를 사용할 수 있습니다. 또한, 바이트열 객체는 <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> 메서드를 통해 문자열로 디코딩될 수 있습니다.</p>
</dd>
</dl>
</dd>
<dt>가변 시퀀스</dt><dd><p id="index-22">가변 시퀀스는 만들어진 후에 변경될 수 있습니다. 서브스크립션(subscription)과 슬라이싱은 대입문과 <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> (삭제) 문의 대상으로 사용될 수 있습니다.</p>
<p>현재 두 개의 내장 가변 시퀀스형이 있습니다:</p>
<dl>
<dt>리스트(Lists)</dt><dd><p id="index-23">리스트의 항목은 임의의 파이썬 객체입니다. 리스트는 콤마로 분리된 표현식을 대괄호 안에 넣어서 만들 수 있습니다. (길이 0이나 1의 리스트를 만드는데 별도의 규칙이 필요 없습니다.)</p>
</dd>
<dt>바이트 배열(Byte Arrays)</dt><dd><p id="index-24">바이트 배열(bytearray) 객체는 가변 배열입니다. 내장 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a> 생성자로 만들어집니다. 가변이라는 것(그래서 해싱 불가능하다는 것)을 제외하고, 바이트 배열은 불변 바이트열( <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>) 객체와 같은 인터페이스와 기능을 제공합니다.</p>
</dd>
</dl>
<p id="index-25">확장 모듈 <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> 는 추가의 가변 시퀀스 형을 제공하는데, <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 모듈 역시 마찬가지입니다.</p>
</dd>
</dl>
</dd>
<dt>집합 형들(Set types)</dt><dd><p id="index-26">이것들은 중복 없는 불변 객체들의 순서 없고 유한한 집합을 나타냅니다. 인덱싱할 수 없습니다. 하지만 이터레이트할 수 있고, 내장 함수 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 은 집합 안에 있는 항목들의 개수를 돌려줍니다. 집합의 일반적인 용도는 빠른 멤버십 검사(fast membership testing), 시퀀스에서 중복된 항목 제거, 교집합(intersection), 합집합(union), 차집합(difference), 대칭차집합(symmetric difference)과 같은 집합 연산을 계산하는 것입니다.</p>
<p>집합의 원소들에는 딕셔너리 키와 같은 불변성 규칙이 적용됩니다. 숫자 형의 경우는 숫자 비교에 관한 일반 원칙이 적용된다는 점에 주의해야 합니다: 만약 두 숫자가 같다고 비교되면(예를 들어, <code class="docutils literal notranslate"><span class="pre">1</span></code> 과 <code class="docutils literal notranslate"><span class="pre">1.0</span></code>), 그중 하나만 집합에 들어갈 수 있습니다.</p>
<p>현재 두 개의 내장 집합 형이 있습니다:</p>
<dl>
<dt>집합(Sets)</dt><dd><p id="index-27">이것들은 가변 집합을 나타냅니다. 내장 <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal notranslate"><span class="pre">set()</span></code></a> 생성자로 만들 수 있고, <code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code> 같은 메서드들을 사용해서 나중에 수정할 수 있습니다.</p>
</dd>
<dt>불변 집합(Frozen sets)</dt><dd><p id="index-28">이것들은 불변 집합을 나타냅니다. 내장 <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-func docutils literal notranslate"><span class="pre">frozenset()</span></code></a> 생성자로 만들 수 있습니다. 불변 집합(frozenset)은 불변이고 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a> 하므로, 다른 집합의 원소나, 딕셔너리의 키로 사용될 수 있습니다.</p>
</dd>
</dl>
</dd>
<dt>매핑(Mappings)</dt><dd><p id="index-29">이것들은 임의의 인덱스 집합으로 인덱싱되는 객체들의 유한한 집합을 나타냅니다. 인덱스 표기법(subscript notation) <code class="docutils literal notranslate"><span class="pre">a[k]</span></code> 는 매핑 <code class="docutils literal notranslate"><span class="pre">a</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">k</span></code> 로 인덱스 되는 항목을 선택합니다; 이것은 표현식에 사용될 수도 있고, 대입이나 <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> 문장의 대상이 될 수도 있습니다. 내장 함수 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 은 매핑에 포함된 항목들의 개수를 돌려줍니다.</p>
<p>현재 한 개의 내장 매핑 형이 있습니다:</p>
<dl>
<dt>딕셔너리(Dictionaries)</dt><dd><p id="index-30">이것들은 거의 임의의 인덱스 집합으로 인덱싱되는 객체들의 유한한 집합을 나타냅니다. 키로 사용할 수 없는 것들은 리스트, 딕셔너리나 그 외의 가변형 중에서 아이덴티티가 아니라 값으로 비교되는 것들뿐입니다. 딕셔너리의 효율적인 구현이, 키의 해시값이 도중에 변경되지 않고 계속 같은 값으로 유지되도록 요구하고 있기 때문입니다. 키로 사용되는 숫자 형의 경우는 숫자 비교에 관한 일반 원칙이 적용됩니다: 만약 두 숫자가 같다고 비교되면(예를 들어, <code class="docutils literal notranslate"><span class="pre">1</span></code> 과 <code class="docutils literal notranslate"><span class="pre">1.0</span></code>), 둘 다 같은 딕셔너리 항목을 인덱싱하는데 사용될 수 있습니다.</p>
<p>딕셔너리는 삽입 순서를 유지합니다, 키가 딕셔너리에 순차적으로 추가된 순서와 같은 순서로 생성됨을 뜻합니다. 기존 키를 교체해도 순서는 변경되지 않지만, 키를 제거했다가 다시 삽입하면 이전 위치를 유지하는 대신 끝에 추가됩니다.</p>
<p>딕셔너리는 가변입니다; <code class="docutils literal notranslate"><span class="pre">{...}</span></code> 표기법으로 만들 수 있습니다 (<a class="reference internal" href="expressions.html#dict"><span class="std std-ref">딕셔너리 디스플레이</span></a> 섹션을 참고하십시오).</p>
<p id="index-31">확장 모듈 <a class="reference internal" href="../library/dbm.html#module-dbm.ndbm" title="dbm.ndbm: The standard &quot;database&quot; interface, based on ndbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.ndbm</span></code></a> 과 <a class="reference internal" href="../library/dbm.html#module-dbm.gnu" title="dbm.gnu: GNU's reinterpretation of dbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.gnu</span></code></a> 는 추가의 매핑 형을 제공하는데, <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 모듈 역시 마찬가지입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>딕셔너리는 3.6 이전의 파이썬 버전에서 삽입 순서를 유지하지 않았습니다. CPython 3.6에서, 삽입 순서가 유지되었지만, 그 시점에는 언어 보증이 아니라 구현 세부 사항으로 간주하였습니다.</p>
</div>
</dd>
</dl>
</dd>
<dt>콜러블(Callable types)</dt><dd><p id="index-32">이것들은 함수 호출 연산(<a class="reference internal" href="expressions.html#calls"><span class="std std-ref">호출</span></a> 섹션 참고)이 적용될 수 있는 형들입니다:</p>
<dl>
<dt>사용자 정의 함수</dt><dd><p id="index-33">사용자 정의 함수 객체는 함수 정의를 통해 만들어집니다 (<a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">함수 정의</span></a> 섹션 참고). 함수의 형식 매개변수(formal parameter) 목록과 같은 개수의 항목을 포함하는 인자(argument) 목록으로 호출되어야 합니다.</p>
<p>특수 어트리뷰트들(Special attributes):</p>
<table class="docutils align-default" id="index-34">
<colgroup>
<col style="width: 37%" />
<col style="width: 46%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>어트리뷰트</p></th>
<th class="head"><p>의미</p></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></p></td>
<td><p>함수를 설명하는 문자열 또는 없는 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code>; 서브 클래스로 상속되지 않습니다.</p></td>
<td><p>쓰기 가능</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></p></td>
<td><p>함수의 이름.</p></td>
<td><p>쓰기 가능</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../library/stdtypes.html#definition.__qualname__" title="definition.__qualname__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__qualname__</span></code></a></p></td>
<td><p>함수의 <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">정규화된 이름</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.3에 추가.</span></p>
</div>
</td>
<td><p>쓰기 가능</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code></p></td>
<td><p>함수가 정의된 모듈의 이름 또는 (없는 경우) <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
<td><p>쓰기 가능</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__defaults__</span></code></p></td>
<td><p>인자의 기본값 또는 (없는 경우) <cite>None</cite> 으로 만들어진 튜플.</p></td>
<td><p>쓰기 가능</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__code__</span></code></p></td>
<td><p>컴파일된 함수의 바디(body) 를 나타내는 코드 객체</p></td>
<td><p>쓰기 가능</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__globals__</span></code></p></td>
<td><p>함수의 전역 변수들을 가진 딕셔너리에 대한 참조 — 함수가 정의된 모듈의 전역 이름 공간(namespace)</p></td>
<td><p>읽기 전용</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a></p></td>
<td><p>임의의 함수 어트리뷰트를 지원하는 이름 공간.</p></td>
<td><p>쓰기 가능</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__closure__</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">None</span></code> 또는 함수의 자유 변수(free variable)들에 대한 연결을 가진 셀(cell)들의 튜플. <code class="docutils literal notranslate"><span class="pre">cell_contents</span></code> 어트리뷰트에 대한 정보는 아래를 보십시오.</p></td>
<td><p>읽기 전용</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></p></td>
<td><p>매개변수의 어노테이션을 가진 dict. dict의 키는 매개변수의 이름인데, 반환 값 어노테이션이 있다면 <code class="docutils literal notranslate"><span class="pre">'return'</span></code> 을 키로 사용합니다.</p></td>
<td><p>쓰기 가능</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__kwdefaults__</span></code></p></td>
<td><p>키워드 형태로만 전달 가능한 매개변수들의 기본값을 가진 dict.</p></td>
<td><p>쓰기 가능</p></td>
</tr>
</tbody>
</table>
<p>“쓰기 가능” 하다고 표시된 대부분의 어트리뷰트들은 값이 대입될 때 형을 검사합니다.</p>
<p>함수 객체는 임의의 어트리뷰트를 읽고 쓸 수 있도록 지원하는데, 예를 들어 함수에 메타데이터(metadata)를 붙이는데 사용될 수 있습니다. 어트리뷰트를 읽거나 쓸 때는 일반적인 점 표현법(dot-notation)이 사용됩니다. <em>현재 구현은 오직 사용자 정의 함수만 함수 어트리뷰트를 지원함에 주의해야 합니다. 내장 함수의 함수 어트리뷰트는 미래에 지원될 수 있습니다.</em></p>
<p>셀 객체는 <code class="docutils literal notranslate"><span class="pre">cell_contents</span></code> 어트리뷰트를 가지고 있습니다. 셀의 값을 읽을 뿐만 아니라 값을 설정하는 데도 사용할 수 있습니다.</p>
<p>함수 정의에 관한 추가적인 정보를 코드 객체로부터 얻을 수 있습니다. 아래에 나오는 내부 형의 기술을 참고하십시오. <a class="reference internal" href="../library/types.html#types.CellType" title="types.CellType"><code class="xref py py-data docutils literal notranslate"><span class="pre">셀</span></code></a> 형은 <a class="reference internal" href="../library/types.html#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">types</span></code></a> 모듈에서 액세스할 수 있습니다.</p>
</dd>
<dt>인스턴스 메서드(Instance methods)</dt><dd><p id="index-35">인스턴스 메서드는 클래스, 클래스 인스턴스와 모든 콜러블 객체 (보통 사용자 정의 함수)을 결합합니다.</p>
<p id="index-36">특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 는 클래스 인스턴스 객체, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> 는 함수 객체; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 은 메서드의 설명 (<code class="docutils literal notranslate"><span class="pre">__func__.__doc__</span></code> 과 같습니다); <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 은 메서드의 이름 (<code class="docutils literal notranslate"><span class="pre">__func__.__name__</span></code> 과 같습니다); <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> 은 메서드가 정의된 모듈의 이름이거나 없는 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>메서드는 기반 함수의 모든 함수 어트리뷰트들을 읽을 수 있도록 지원합니다(하지만 쓰기는 지원하지 않습니다).</p>
<p>어트리뷰트가 사용자 정의 함수 객체이거나 클래스 메서드 객체면, 사용자 정의 메서드 객체는 클래스의 어트리뷰트를 읽을 때 만들어질 수 있습니다 (아마도 그 클래스의 인스턴스를 통해서).</p>
<p>인스턴스 메서드 객체가 클래스 인스턴스를 통해 클래스의 사용자 정의 함수 객체를 읽음으로써 만들어질 때, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 어트리뷰트는 인스턴스이고, 메서드 객체는 결합(bound)하였다고 말합니다. 새 메서드의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> 어트리뷰트는 원래의 함수 객체입니다.</p>
<p>인스턴스 메서드 객체가 클래스나 인스턴스로부터 클래스 메서드 객체를 읽음으로써 만들어질 때, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 어트리뷰트는 클래스 자신이고, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> 어트리뷰트는 클래스 메서드가 기반을 두는 함수 객체입니다.</p>
<p>인스턴스 메서드 객체가 호출될 때, 기반을 두는 함수 (<code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code>) 가 호출되는데, 인자 목록의 앞에 클래스 인스턴스 (<code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code>) 가 삽입됩니다. 예를 들어, <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 가 함수 <code class="xref py py-meth docutils literal notranslate"><span class="pre">f()</span></code> 의 정의를 포함하는 클래스이고, <code class="docutils literal notranslate"><span class="pre">x</span></code> 가 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 의 인스턴스일 때, <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> 를 호출하는 것은 <code class="docutils literal notranslate"><span class="pre">C.f(x,</span> <span class="pre">1)</span></code> 을 호출하는 것과 같습니다.</p>
<p>인스턴스 메서드 객체가 클래스 메서드 객체로부터 올 때, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 에 저장된 “클래스 인스턴스” 는 실제로는 클래스 자신입니다. 그래서 <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> 이나 <code class="docutils literal notranslate"><span class="pre">C.f(1)</span></code> 을 호출하는 것은 <code class="docutils literal notranslate"><span class="pre">f(C,1)</span></code> 를 호출하는 것과 같습니다 (<code class="docutils literal notranslate"><span class="pre">f</span></code> 는 기반 함수입니다).</p>
<p>함수 객체에서 인스턴스 객체로의 변환은 인스턴스로부터 어트리뷰트를 읽을 때마다 일어남에 주의해야 합니다. 어떤 경우에, 어트리뷰트를 지역 변수에 대입하고, 그 지역 변수를 호출하는 것이 효과적인 최적화가 됩니다. 또한, 이 변환이 사용자 정의 함수에 대해서만 발생함에 주의해야 합니다; 다른 콜러블 객체 (그리고 콜러블이 아닌 모든 객체)는 변환 없이 읽힙니다. 클래스 인스턴스의 어트리뷰트인 사용자 정의 함수는 결합한 메서드로 변환되지 않는다는 것도 중요합니다; 이 변환은 함수가 클래스 어트리뷰트일 때만 일어납니다.</p>
</dd>
<dt>제너레이터 함수(Generator functions)</dt><dd><p id="index-37"><a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 문(<a class="reference internal" href="simple_stmts.html#yield"><span class="std std-ref">yield 문</span></a> 절 참조)을 사용하는 함수나 메서드를 <em class="dfn">제너레이터 함수 (generator function)</em> 라고 부릅니다. 이런 함수를 호출하면 항상 이터레이터(iterator) 객체를 돌려주는데, 함수의 바디(body)를 실행하는 데 사용됩니다: 이터레이터의 <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterator.__next__()</span></code></a> 메서드를 호출하면 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 문이 값을 제공할 때까지 함수가 실행됩니다. 함수가 <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 문을 실행하거나 끝에 도달하면 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 예외를 일으키고, 이터레이터는 반환하는 값들의 끝에 도달하게 됩니다.</p>
</dd>
<dt>코루틴 함수(Coroutine functions)</dt><dd><p id="index-38"><a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 를 사용해서 정의되는 함수나 메서드를 <em class="dfn">코루틴 함수 (coroutine function)</em> 라고 부릅니다. 이런 함수를 호출하면 <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">코루틴</span></a> 객체를 돌려줍니다. <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식을 비롯해, <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 와 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 문을 사용할 수 있습니다. <a class="reference internal" href="#coroutine-objects"><span class="std std-ref">코루틴 객체(Coroutine Objects)</span></a> 섹션을 참조하십시오.</p>
</dd>
<dt>비동기 제너레이터 함수(Asynchronous generator functions)</dt><dd><p id="index-39"><a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> 를 사용해서 정의되는 함수가 <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 문을 사용하면 <em class="dfn">비동기 제너레이터 함수 (asynchronous generator function)</em> 라고 부릅니다. 이런 함수를 호출하면 항상 비동기 이터레이터(asynchronous iterator) 객체를 돌려주는데, 함수의 바디(body)를 실행하기 위해 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 문에서 사용됩니다.</p>
<p>Calling the asynchronous iterator’s
<a class="reference internal" href="#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aiterator.__anext__</span></code></a> method
will return an <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> which when awaited
will execute until it provides a value using the <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>
expression.  When the function executes an empty <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>
statement or falls off the end, a <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> exception
is raised and the asynchronous iterator will have reached the end of
the set of values to be yielded.</p>
</dd>
<dt>내장 함수(Built-in functions)</dt><dd><p id="index-40">내장 함수 객체는 C 함수를 둘러싸고 있습니다(wrapper). 내장 함수의 예로는 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 과 <a class="reference internal" href="../library/math.html#math.sin" title="math.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.sin()</span></code></a> (<a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 는 표준 내장 모듈입니다) 가 있습니다. 인자의 개수와 형은 C 함수에 의해 결정됩니다. 특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 은 함수의 설명 문자열 또는 없는 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다; <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 은 함수의 이름입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 는 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정됩니다 (하지만 다음 항목을 보십시오); <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> 은 함수가 정의된 모듈의 이름이거나 없는 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다.</p>
</dd>
<dt>내장 메서드(Built-in methods)</dt><dd><p id="index-41">이것은 사실 내장 함수의 다른 모습입니다. 이번에는 묵시적인 추가의 인자로 C 함수에 전달되는 객체를 갖고 있습니다. 내장 메서드의 예로는 <code class="docutils literal notranslate"><span class="pre">alist.append()</span></code> 가 있는데, <em>alist</em> 는 리스트 객체입니다. 이 경우에, 특수 읽기 전용 어트리뷰트 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 는 <em>alist</em> 로 표현된 객체로 설정됩니다.</p>
</dd>
<dt>클래스(Classes)</dt><dd><p>Classes are callable.  These objects normally act as factories for new
instances of themselves, but variations are possible for class types that
override <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a>.  The arguments of the call are passed to
<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> and, in the typical case, to <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> to
initialize the new instance.</p>
</dd>
<dt>클래스 인스턴스(Class Instances)</dt><dd><p>Instances of arbitrary classes can be made callable by defining a
<a class="reference internal" href="#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> method in their class.</p>
</dd>
</dl>
</dd>
<dt>모듈(Modules)</dt><dd><p id="index-42">모듈은 파이썬 코드의 기본적인 조직화 단위이고, <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 문이나, <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> 과 내장 <a class="reference internal" href="../library/functions.html#__import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 함수를 호출해서 구동할 수 있는 <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">임포트 시스템</span></a> 에 의해 만들어집니다. 모듈 객체는 딕셔너리 객체로 구현되는 이름 공간을 갖습니다(이 딕셔너리 객체는 모듈에서 정의되는 함수들의 <code class="docutils literal notranslate"><span class="pre">__globals__</span></code> 어트리뷰트로 참조됩니다). 어트리뷰트 참조는 이 딕셔너리에 대한 조회로 변환됩니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">m.x</span></code> 는 <code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span></code> 와 같습니다. 모듈 객체는 모듈을 초기화하는데 사용된 코드 객체를 갖고 있지 않습니다 (일단 초기화가 끝나면 필요 없으므로).</p>
<p>어트리뷰트 대입은 모듈의 이름 공간 딕셔너리를 갱신합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">m.x</span> <span class="pre">=</span> <span class="pre">1</span></code> 은 <code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span> <span class="pre">=</span> <span class="pre">1</span></code> 과 같습니다.</p>
<p id="index-43">미리 정의된 (쓰기 가능한) 어트리뷰트들: <a class="reference internal" href="import.html#__name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 은 모듈의 이름입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 은 모듈의 설명 문자열 또는 없는 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다; (없을 수도 있는) <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 는 모듈의 바디를 실행하면서 수집된 <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">변수 어노테이션</span></a> 들을 담은 딕셔너리입니다; <a class="reference internal" href="import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> 은 모듈이 로드된 파일의 경로명입니다. 인터프리터에 정적으로 연결된 C 모듈과 같은 어떤 종류의 모듈들에서는 <a class="reference internal" href="import.html#__file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> 어트리뷰트가 제공되지 않습니다; 공유 라이브러리(shared library)로부터 동적으로 로딩되는 확장 모듈의 경우 공유 라이브러리의 경로명이 제공됩니다.</p>
<p id="index-44">특수 읽기 전용 어트리뷰트들: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 는 딕셔너리로 표현되는 모듈의 이름 공간입니다.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> CPython 이 모듈 딕셔너리를 비우는 방법 때문에, 딕셔너리에 대한 참조가 남아있더라도, 모듈이 스코프를 벗어나면 모듈 딕셔너리는 비워집니다. 이것을 피하려면, 딕셔너리를 복사하거나 딕셔너리를 직접 이용하는 동안은 모듈을 잡아두어야 합니다.</p>
</div>
</dd>
<dt>사용자 정의 클래스(Custom classes)</dt><dd><p>사용자 정의 클래스 형들은 보통 클래스 정의 때문에 만들어집니다 (<a class="reference internal" href="compound_stmts.html#class"><span class="std std-ref">클래스 정의</span></a> 섹션 참조). 클래스는 딕셔너리로 구현된 이름 공간을 갖습니다. 클래스 어트리뷰트 참조는 이 딕셔너리에 대한 조회로 변환됩니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">C.x</span></code> 는 <code class="docutils literal notranslate"><span class="pre">C.__dict__[&quot;x&quot;]</span></code> 로 변환됩니다 (하지만 어트리뷰트에 접근하는 다른 방법들을 허락하는 여러 가지 훅(hook)이 있습니다.). 거기에서 어트리뷰트 이름이 발견되지 않으면, 어트리뷰트 검색은 부모 클래스들에서 계속됩니다. 이 부모 클래스 검색은 C3 메서드 결정 순서(method resolution order)를 사용하는데, 다중 상속이 같은 부모 클래스로 모이는 ‘다이아몬드(diamond)’ 계승 구조가 존재해도 올바르게 동작합니다. 파이썬이 사용하는 C3 MRO에 관한 좀 더 자세한 내용은 2.3 배포에 첨부된 문서 <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a> 에서 찾아볼 수 있습니다.</p>
<p id="index-45">클래스 어트리뷰트 참조가 (클래스 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 라고 하자) 클래스 메서드 객체로 귀결될 때는, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> 어트리뷰트가 <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> 인 인스턴스 메서드 객체로 변환됩니다. 스태틱 메서드로 귀결될 때는, 스태틱 메서드 객체가 감싸고 있는 객체로 변환됩니다. 클래스로부터 얻은 어트리뷰트가 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 에 저장된 값과 달라지도록 만드는 다른 방법이 <a class="reference internal" href="#descriptors"><span class="std std-ref">디스크립터 구현하기</span></a> 섹션에 나옵니다.</p>
<p id="index-46">클래스 어트리뷰트 대입은 클래스의 딕셔너리를 갱신할 뿐, 어떤 경우도 부모 클래스의 딕셔너리를 건드리지는 않습니다.</p>
<p id="index-47">클래스 객체는 클래스 인스턴스를 돌려주도록(아래를 보십시오) 호출될 수 있습니다(위를 보십시오).</p>
<p id="index-48">특수 어트리뷰트들:<a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 은 클래스의 이름입니다. <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> 은 클래스가 정의된 모듈의 이름입니다. <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 는 클래스의 이름 공간을 저장하는 딕셔너리입니다; <a class="reference internal" href="../library/stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a> 는 부모 클래스들을 저장하는 튜플입니다; 부모 클래스 목록에 나타나는 순서를 유지합니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> 은 클래스의 설명 문자열 이거나 정의되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다; (없을 수 있는) <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> 는 클래스의 바디를 실행하면서 수집된 <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">변수 어노테이션</span></a> 들을 담은 딕셔너리입니다.</p>
</dd>
<dt>클래스 인스턴스(Class instances)</dt><dd><p id="index-49">A class instance is created by calling a class object (see above).  A class
instance has a namespace implemented as a dictionary which is the first place
in which attribute references are searched.  When an attribute is not found
there, and the instance’s class has an attribute by that name, the search
continues with the class attributes.  If a class attribute is found that is a
user-defined function object, it is transformed into an instance method
object whose <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> attribute is the instance.  Static method and
class method objects are also transformed; see above under “Classes”.  See
section <a class="reference internal" href="#descriptors"><span class="std std-ref">디스크립터 구현하기</span></a> for another way in which attributes of a class
retrieved via its instances may differ from the objects actually stored in
the class’s <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>.  If no class attribute is found, and the
object’s class has a <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> method, that is called to satisfy
the lookup.</p>
<p id="index-50">Attribute assignments and deletions update the instance’s dictionary, never a
class’s dictionary.  If the class has a <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> or
<a class="reference internal" href="#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code></a> method, this is called instead of updating the instance
dictionary directly.</p>
<p id="index-51">어떤 특별한 이름들의 메서드들을 가지면, 클래스 인스턴스는 숫자, 시퀀스, 매핑인 척할 수 있습니다. <a class="reference internal" href="#specialnames"><span class="std std-ref">특수 메서드 이름들</span></a> 섹션을 보십시오.</p>
<p id="index-52">특수 어트리뷰트들: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 는 어트리뷰트 딕셔너리입니다; <a class="reference internal" href="../library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> 는 인스턴스의 클래스입니다.</p>
</dd>
<dt>I/O 객체 (파일 객체라고도 알려져 있습니다)</dt><dd><p id="index-53"><a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">파일 객체</span></a> 는 열린 파일을 나타냅니다. 파일 객체를 만드는 여러 가지 단축법이 있습니다: <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 내장 함수, <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.popen()</span></code></a>, <a class="reference internal" href="../library/os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fdopen()</span></code></a> 과 소켓 객체의 <a class="reference internal" href="../library/socket.html#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a> 메서드 (그리고, 아마도 확장 모듈들이 제공하는 다른 함수들이나 메서드들).</p>
<p><code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> 는 인터프리터의 표준 입력, 출력, 에러 스트림으로 초기화된 파일 객체들입니다; 모두 텍스트 모드로 열려서 <a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a> 추상 클래스에 의해 정의된 인터페이스를 따릅니다.</p>
</dd>
<dt>내부 형(Internal types)</dt><dd><p id="index-54">인터프리터가 내부적으로 사용하는 몇몇 형들은 사용자에게 노출됩니다. 인터프리터의 미래 버전에서 이들의 정의는 변경될 수 있지만, 완전함을 위해 여기서 언급합니다.</p>
<dl id="index-55">
<dt>코드 객체(Code objects)</dt><dd><p>코드 객체는 <em>바이트로 컴파일된(byte-compiled)</em> 실행 가능한 파이썬 코드를 나타내는데, 그냥 <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">바이트 코드</span></a> 라고도 부릅니다. 코드 객체와 함수 객체 간에는 차이가 있습니다; 함수 객체는 함수의 전역 공간(globals) (함수가 정의된 모듈)을 명시적으로 참조하고 있지만, 코드 객체는 어떤 문맥(context)도 갖고 있지 않습니다; 또한 기본 인자값들이 함수 객체에 저장되어 있지만 코드 객체에는 들어있지 않습니다 (실행 시간에 계산되는 값들을 나타내기 때문입니다). 함수 객체와는 달리, 코드 객체는 불변이고 가변 객체들에 대한 어떤 참조도 (직접 혹은 간접적으로도) 갖고 있지 않습니다.</p>
<p id="index-56">특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_name</span></code> 은 함수의 이름입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_argcount</span></code> 는 위치 인자들 (위치 전용 인자와 기본값이 있는 인자들도 포함됩니다)의 총 개수입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_posonlyargcount</span></code> 는 위치 전용 인자들 (기본값이 있는 인자들도 포함됩니다)의 개수입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_kwonlyargcount</span></code> 는 키워드 전용 인자들 (기본값이 있는 인자들도 포함됩니다)의 개수입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_nlocals</span></code> 는 함수가 사용하는 지역 변수들 (인자들을 포함합니다)의 개수입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_varnames</span></code> 는 지역 변수들의 이름을 담고 있는 튜플입니다(인자들의 이름이 먼저 나옵니다); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_cellvars</span></code> 는 중첩된 함수들이 참조하는 지역 변수들의 이름을 담고 있는 튜플입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_freevars</span></code> 는 자유 변수(free variables)들의 이름을 담고 있는 튜플입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_code</span></code> 는 바이트 코드 명령 시퀀스를 나타내는 문자열입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code> 는 바이트 코드가 사용하는 리터럴을 포함하는 튜플입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_names</span></code> 는 바이트 코드가 사용하는 이름들을 담고 있는 튜플입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_filename</span></code> 은 컴파일된 코드를 제공한 파일의 이름입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_firstlineno</span></code> 는 함수의 첫 번째 줄 번호입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_lnotab</span></code> 은 바이트 코드에서의 위치를 줄 번호로 매핑하는 법을 문자열로 인코딩한 값입니다 (자세한 내용은 인터프리터의 소스 코드를 참고하십시오); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_stacksize</span></code> 는 필요한 스택의 크기입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> 는 인터프리터의 여러 플래그(flag)들을 정수로 인코딩한 값입니다.</p>
<p id="index-57">다음과 같은 값들이 <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> 를 위해 정의되어 있습니다: 함수가 가변 개수의 위치 인자를 받아들이기 위해 사용되는 <code class="docutils literal notranslate"><span class="pre">*arguments</span></code> 문법을 사용하면 비트 <code class="docutils literal notranslate"><span class="pre">0x04</span></code> 가 1이 됩니다; 임의의 키워드 인자를 받아들이기 위해 사용하는 <code class="docutils literal notranslate"><span class="pre">**keywords</span></code> 문법을 사용하면 비트 <code class="docutils literal notranslate"><span class="pre">0x08</span></code> 이 1이 됩니다; 비트 <code class="docutils literal notranslate"><span class="pre">0x20</span></code> 은 함수가 제너레이터일 때 설정됩니다.</p>
<p>퓨처 기능 선언 (<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>) 또한 코드 객체가 특정 기능이 활성화된 상태에서 컴파일되었는지를 나타내기 위해 <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> 의 비트들을 사용합니다: 함수가 퓨처 division이 활성화된 상태에서 컴파일되었으면 비트 <code class="docutils literal notranslate"><span class="pre">0x2000</span></code> 이 설정됩니다; 비트 <code class="docutils literal notranslate"><span class="pre">0x10</span></code> 과 <code class="docutils literal notranslate"><span class="pre">0x1000</span></code> 는 예전 버전의 파이썬에서 사용되었습니다.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> 의 다른 비트들은 내부 사용을 위해 예약되어 있습니다.</p>
<p id="index-58">만약 코드 객체가 함수를 나타낸다면, <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code> 의 첫 번째 항목은 설명 문자열이거나 정의되지 않으면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다.</p>
</dd>
</dl>
<dl id="frame-objects">
<dt>프레임 객체(Frame objects)</dt><dd><p id="index-59">프레임 객체는 실행 프레임(execution frame)을 나타냅니다. 트레이스백 객체에 등장할 수 있고 (아래를 보십시오), 등록된 추적 함수로도 전달됩니다.</p>
<p id="index-60">특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_back</span></code> 은 이전 스택 프레임 (호출자 방향으로)을 가리키거나, 이게 스택의 바닥이라면 <code class="docutils literal notranslate"><span class="pre">None</span></code>; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_code</span></code> 는 이 프레임에서 실행되는 코드 객체; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_locals</span></code> 는 지역 변수를 조회하는데 사용되는 딕셔너리; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_globals</span></code> 는 전역 변수에 사용됩니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_builtins</span></code> 는 내장된(intrinsic) 이름들에 사용됩니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lasti</span></code> 는 정확한 바이트 코드 명령(instruction)을 제공합니다 (코드 객체의 바이트 코드 문자열에 대한 인덱스입니다).</p>
<p>Accessing <code class="docutils literal notranslate"><span class="pre">f_code</span></code> raises an <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">auditing event</span></a>
<code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> with arguments <code class="docutils literal notranslate"><span class="pre">obj</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;f_code&quot;</span></code>.</p>
<p id="index-61">특수 쓰기 가능 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace</span></code> 는, <code class="docutils literal notranslate"><span class="pre">None</span></code> 이 아니면, 코드 실행 중의 여러 이벤트로 인해 호출되는 함수입니다 (디버거에서 사용됩니다). 보통 이벤트는 각 새 소스 줄에서 발생합니다 - <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_lines</span></code>를 <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>로 설정하면 이것을 비활성화할 수 있습니다.</p>
<p>구현은 <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_opcodes</span></code>를 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>로 설정하는 것으로 요청되는 옵코드(opcode) 당 이벤트를 허용할 수 있습니다. 추적 함수에 의해 발생 된 예외가 추적되는 함수로 빠져나오면 정의되지 않은 인터프리터 동작을 유발할 수 있음에 주의해야 합니다.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lineno</span></code> 는 프레임의 현재 줄 번호입니다 — 트레이스 함수(f_trace)에서 이 값을 쓰면 해당 줄로 점프합니다 (오직 가장 바닥 프레임에서만 가능합니다). 디버거는 f_lineno 를 쓰기 위한 점프 명령을 구현할 수 있습니다 (소위 Set Next Statement).</p>
<p>프레임 객체는 한가지 메서드를 지원합니다:</p>
<dl class="method">
<dt id="frame.clear">
<code class="sig-prename descclassname">frame.</code><code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frame.clear" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 프레임이 잡은 지역 변수들에 대한 모든 참조를 제거합니다. 또한, 만약 프레임이 제너레이터에 속하면, 제너레이터가 종료됩니다(finalize). 이것은 프레임 객체가 관련된 참조 순환을 깨는 데 도움을 줍니다 (예를 들어, 예외를 잡아서 트레이스백을 추후 사용을 위해 저장할 때).</p>
<p>만약 프레임이 현재 실행 중이면 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 예외가 발생합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

</dd>
</dl>
<dl id="traceback-objects">
<dt>트레이스백 객체(Traceback objects)</dt><dd><p id="index-62">트레이스백 객체는 예외의 스택 트레이스를 나타냅니다. 트레이스백 객체는 예외가 발생할 때 만들어지고, <a class="reference internal" href="../library/types.html#types.TracebackType" title="types.TracebackType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.TracebackType</span></code></a> 를 호출해서 명시적으로 만들 수도 있습니다.</p>
<p>묵시적으로 만들어진 트레이스백의 경우, 예외 처리기를 찾아서 실행 스택을 되감을 때, 각각 되감기 단계마다 현재 트레이스백의 앞에 트레이스백 객체를 삽입합니다. 예외 처리기에 들어가면, 스택 트레이스를 프로그램이 사용할 수 있습니다. (<a class="reference internal" href="compound_stmts.html#try"><span class="std std-ref">try 문</span></a> 섹션 참조.) <code class="docutils literal notranslate"><span class="pre">sys.exc_info()</span></code> 가 돌려주는 튜플의 세 번째 항목이나 잡힌 예외의 <code class="docutils literal notranslate"><span class="pre">__traceback__</span></code> 어트리뷰트로 액세스할 수 있습니다.</p>
<p>프로그램이 적절한 처리기를 제공하지 않는 경우, 스택 트레이스는 표준 에러 스트림으로 (보기 좋게 포맷되어) 출력됩니다; 만약 인터프리터가 대화형이면, <code class="docutils literal notranslate"><span class="pre">sys.last_traceback</span></code> 으로 사용자에게 제공합니다.</p>
<p>명시적으로 생성된 트레이스백의 경우, <code class="docutils literal notranslate"><span class="pre">tb_next</span></code> 어트리뷰트를 어떻게 연결하여 전체 스택 트레이스를 형성해야 하는지를 결정하는 것은 트레이스백을 만드는 주체에게 달려 있습니다.</p>
<p id="index-63">특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_frame</span></code> 은 현 단계에서의 실행 프레임입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_lineno</span></code> 는 예외가 발생한 줄의 번호를 줍니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_lasti</span></code> 정확한 바이트 코드 명령을 가리킵니다. 만약 예외가 except 절이나 finally 절이 없는 <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 문에서 발생하면, 줄 번호와 트레이스백의 마지막 명령(last instruction)은 프레임 객체의 줄 번호와 다를 수 있습니다.</p>
<p>Accessing <code class="docutils literal notranslate"><span class="pre">tb_frame</span></code> raises an <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">auditing event</span></a>
<code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> with arguments <code class="docutils literal notranslate"><span class="pre">obj</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;tb_frame&quot;</span></code>.</p>
<p id="index-64">특수 쓰기 가능 어트리뷰트: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_next</span></code> 는 스택 트레이스의 다음 단계 (예외가 발생한 프레임 방향으로)이거나 다음 단계가 없으면 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>트레이스백 객체는 이제 파이썬 코드에서 명시적으로 인스턴스를 만들 수 있으며 기존 인스턴스의 <code class="docutils literal notranslate"><span class="pre">tb_next</span></code> 어트리뷰트를 변경할 수 있습니다.</p>
</div>
</dd>
<dt>슬라이스 객체(Slice objects)</dt><dd><p id="index-65">Slice objects are used to represent slices for
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>
methods.  They are also created by the built-in <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a> function.</p>
<p id="index-66">특수 읽기 전용 어트리뷰트들: <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code> 는 하한(lower bound) 입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> 은 상한(upper bound) 입니다; <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> 은 스텝 값입니다; 각 값은 생략될 경우 <code class="docutils literal notranslate"><span class="pre">None</span></code> 입니다. 이 어트리뷰트들은 임의의 형이 될 수 있습니다.</p>
<p>슬라이스 객체는 하나의 메서드를 지원합니다.</p>
<dl class="method">
<dt id="slice.indices">
<code class="sig-prename descclassname">slice.</code><code class="sig-name descname">indices</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">length</em><span class="sig-paren">)</span><a class="headerlink" href="#slice.indices" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 하나의 정수 인자 <em>length</em> 를 받아서 슬라이스 객체가 길이 <em>length</em> 인 시퀀스에 적용되었을 때 그 슬라이스에 대한 정보를 계산합니다. 세 개의 정수로 구성된 튜플을 돌려줍니다: 이것들은 각각 <em>start</em> 와 <em>stop</em> 인덱스와, <em>step</em> 또는 슬라이스의 스트라이드(stride) 길이입니다. 생략되었거나 범위를 벗어난 인덱스들은 일반적인 슬라이스와 같은 방법으로 다뤄집니다.</p>
</dd></dl>

</dd>
<dt>스태틱 메서드 객체(Static method objects)</dt><dd><p>스태틱 메서드 객체는 위에서 설명한 함수 객체를 메서드 객체로 변환하는 과정을 방지하는 방법을 제공합니다. 스태틱 메서드 객체는 다른 임의의 객체, 보통 사용자 정의 메서드를 둘러쌉니다. 스태틱 메서드가 클래스나 클래스 인스턴스로부터 읽힐 때 객체가 실제로 돌려주는 것은 둘러싸여 있던 객체인데, 다른 어떤 변환도 적용되지 않은 상태입니다. 둘러싸는 객체는 그렇더라도, 스태틱 메서드 객체 자체는 콜러블이 아닙니다. 스태틱 메서드 객체는 내장 <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> 생성자로 만듭니다.</p>
</dd>
<dt>클래스 메서드 객체(Class method objects)</dt><dd><p>스태틱 메서드 객체처럼, 클래스 메서드 객체 역시 다른 객체를 둘러싸는데, 클래스와 클래스 인스턴스로부터 그 객체를 꺼내는 방식에 변화를 줍니다. 그런 조회에서 클래스 메서드 객체가 동작하는 방식에 대해서는 위 “사용자 정의 메서드(User-defined methods)” 에서 설명했습니다. 클래스 메서드 객체는 내장 <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> 생성자로 만듭니다.</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="special-method-names">
<span id="specialnames"></span><h2><span class="section-number">3.3. </span>특수 메서드 이름들<a class="headerlink" href="#special-method-names" title="제목 주소">¶</a></h2>
<p id="index-67">A class can implement certain operations that are invoked by special syntax
(such as arithmetic operations or subscripting and slicing) by defining methods
with special names. This is Python’s approach to <em class="dfn">operator overloading</em>,
allowing classes to define their own behavior with respect to language
operators.  For instance, if a class defines a method named
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>,
and <code class="docutils literal notranslate"><span class="pre">x</span></code> is an instance of this class, then <code class="docutils literal notranslate"><span class="pre">x[i]</span></code> is roughly equivalent
to <code class="docutils literal notranslate"><span class="pre">type(x).__getitem__(x,</span> <span class="pre">i)</span></code>.  Except where mentioned, attempts to execute an
operation raise an exception when no appropriate method is defined (typically
<a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> or <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>).</p>
<p>Setting a special method to <code class="docutils literal notranslate"><span class="pre">None</span></code> indicates that the corresponding
operation is not available.  For example, if a class sets
<a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the class is not iterable, so calling
<a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> on its instances will raise a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> (without
falling back to <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>). <a class="footnote-reference brackets" href="#id9" id="id2">2</a></p>
<p>내장형을 흉내 내는 클래스를 구현할 때, 모방은 모형화하는 객체에 말이 되는 수준까지만 구현하는 것이 중요합니다. 예를 들어, 어떤 시퀀스는 개별 항목들을 꺼내는 것만으로도 잘 동작할 수 있습니다. 하지만 슬라이스를 꺼내는 것은 말이 안 될 수 있습니다. (이런 한가지 예는 W3C의 Document Object Model의 <code class="xref py py-class docutils literal notranslate"><span class="pre">NodeList</span></code> 인터페이스입니다.)</p>
<section id="basic-customization">
<span id="customization"></span><h3><span class="section-number">3.3.1. </span>기본적인 커스터마이제이션<a class="headerlink" href="#basic-customization" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="object.__new__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__new__</code><span class="sig-paren">(</span><em class="sig-param">cls</em><span class="optional">[</span>, <em class="sig-param">...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__new__" title="정의 주소">¶</a></dt>
<dd><p id="index-68">클래스 <em>cls</em> 의 새 인스턴스를 만들기 위해 호출됩니다. <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 는 스태틱 메서드입니다 (그렇게 선언하지 않아도 되는 특별한 경우입니다)인데, 첫 번째 인자로 만들려고 하는 인스턴스의 클래스가 전달됩니다. 나머지 인자들은 객체 생성자 표현(클래스 호출)에 전달된 것들입니다. <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 의 반환 값은 새 객체 인스턴스이어야 합니다 (보통 <em>cls</em> 의 인스턴스).</p>
<p>일반적인 구현은 <code class="docutils literal notranslate"><span class="pre">super().__new__(cls[,</span> <span class="pre">...])</span></code> 에 적절한 인자들을 전달하는 방법으로 슈퍼 클래스의 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 를 호출해서 새 인스턴스를 만든 후에, 돌려주기 전에 필요한 수정을 가합니다.</p>
<p>If <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> is invoked during object construction and it returns an
instance of <em>cls</em>, then the new instance’s <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> method
will be invoked like <code class="docutils literal notranslate"><span class="pre">__init__(self[,</span> <span class="pre">...])</span></code>, where <em>self</em> is the new instance
and the remaining arguments are the same as were passed to the object constructor.</p>
<p>만약 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 가 <em>cls</em> 의 인스턴스를 돌려주지 않으면, 새 인스턴스의 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 는 호출되지 않습니다.</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 는 주로 불변형(int, str, tuple과 같은)의 서브 클래스가 인스턴스 생성을 커스터마이즈할 수 있도록 하는 데 사용됩니다. 또한, 사용자 정의 메타 클래스에서 클래스 생성을 커스터마이즈하기 위해 자주 사용됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__init__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="optional">[</span>, <em class="sig-param">...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__init__" title="정의 주소">¶</a></dt>
<dd><p id="index-69">(<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 에 의해) 인스턴스가 만들어진 후에, 하지만 호출자에게 돌려주기 전에 호출됩니다. 인자들은 클래스 생성자 표현으로 전달된 것들입니다. 만약 베이스 클래스가 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드를 갖고 있다면, 서브 클래스의 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 메서드는, 있다면, 인스턴스에서 베이스 클래스가 차지하는 부분이 올바르게 초기화됨을 확실히 하기 위해 명시적으로 호출해주어야 합니다; 예를 들어: <code class="docutils literal notranslate"><span class="pre">super().__init__([args...])</span></code>.</p>
<p>객체를 만드는데 <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 와 <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 가 협력하고 있으므로 (<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 는 만들고, <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 는 그것을 커스터마이즈합니다), <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이외의 값을 돌려주면 실행시간에 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__del__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__del__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__del__" title="정의 주소">¶</a></dt>
<dd><p id="index-70">인스턴스가 파괴되기 직전에 호출됩니다. 파이널라이저 또는 (부적절하게) 파괴자라고 불립니다. 만약 베이스 클래스가 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드를 갖고 있다면, 자식 클래스의 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드는, 정의되어 있다면, 인스턴스에서 베이스 클래스가 차지하는 부분을 적절하게 삭제하기 위해, 명시적으로 베이스 클래스의 메서드를 호출해야 합니다.</p>
<p>(권장하지는 않지만!) <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드는 인스턴스에 대한 새로운 참조를 만듦으로써 인스턴스의 파괴를 지연시킬 수 있습니다. 이것을 객체 <em>부활</em> 이라고 부릅니다. 부활한 객체가 파괴될 때 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 이 두 번째로 호출될지는 구현에 따라 다릅니다; 현재 <a class="reference internal" href="../glossary.html#term-cpython"><span class="xref std std-term">CPython</span></a> 구현은 오직 한 번만 호출합니다.</p>
<p>인터프리터가 종료할 때 아직 남아있는 객체들에 대해서는 <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드의 호출이 보장되지 않습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> 는 직접 <code class="docutils literal notranslate"><span class="pre">x.__del__()</span></code> 를 호출하지 않습니다 — 앞에 있는 것은 <code class="docutils literal notranslate"><span class="pre">x</span></code> 의 참조 횟수(reference count)를 하나 감소시키고, 뒤에 있는 것은 <code class="docutils literal notranslate"><span class="pre">x</span></code> 의 참조 횟수가 0 이 될 때 호출됩니다.</p>
</div>
<div class="impl-detail compound">
<p class="compound-first"><strong>CPython implementation detail:</strong> It is possible for a reference cycle to prevent the reference count
of an object from going to zero.  In this case, the cycle will be
later detected and deleted by the <a class="reference internal" href="../glossary.html#term-garbage-collection"><span class="xref std std-term">cyclic garbage collector</span></a>.  A common cause of reference cycles is when
an exception has been caught in a local variable.  The frame’s
locals then reference the exception, which references its own
traceback, which references the locals of all frames caught in the
traceback.</p>
<div class="compound-last admonition seealso">
<p class="admonition-title">더 보기</p>
<p><a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 모듈에 대한 문서.</p>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">경고</p>
<p><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 이 호출되는 불안정한 상황 때문에, 이것이 실행 중에 발생시키는 예외는 무시되고, 대신에 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> 로 경고가 출력됩니다. 특히:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 은 (임의의 스레드에서) 임의의 코드가 실행되는 동안 호출될 수 있습니다. <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 이 록을 얻어야 하거나 다른 블로킹 자원을 호출하면, <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 을 실행하기 위해 중단된 코드가 자원을 이미 차지했을 수 있으므로 교착 상태에 빠질 수 있습니다.</p></li>
<li><p><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 은 인터프리터를 종료할 때 실행될 수 있습니다. 결과적으로, 액세스해야 하는 전역 변수(다른 모듈 포함)가 이미 삭제되었거나 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정되었을 수 있습니다. 파이썬은 이름이 하나의 밑줄로 시작하는 전역 객체가 다른 전역 객체들보다 먼저 삭제됨을 보장합니다; 이것은, 만약 그 전역 객체들에 대한 다른 참조가 존재하지 않는다면, <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 메서드가 호출되는 시점에, 임포트된 모듈들이 남아있도록 확실히 하는 데 도움이 될 수 있습니다.</p></li>
</ul>
</div>
<span class="target" id="index-71"></span></dd></dl>

<dl class="method">
<dt id="object.__repr__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__repr__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 내장 함수에 의해 호출되어 객체의 “형식적인(official)” 문자열 표현을 계산합니다. 만약 가능하다면, 이것은 같은 (적절한 환경이 주어질 때) 값을 갖는 객체를 새로 만들 수 있는 올바른 파이썬 표현식처럼 보여야 합니다. 가능하지 않다면, <code class="docutils literal notranslate"><span class="pre">&lt;...쓸모있는</span> <span class="pre">설명...&gt;</span></code> 형태의 문자열을 돌려줘야 합니다. 반환 값은 반드시 문자열이어야 합니다. 만약 클래스가 <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> 없이 <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 만 정의한다면, <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> 은 그 클래스 인스턴스의 “비형식적인(informal)” 문자열 표현이 요구될 때 사용될 수 있습니다.</p>
<p>이것은 디버깅에 사용되기 때문에, 표현이 풍부한 정보를 담고 모호하지 않게 하는 것이 중요합니다.</p>
<span class="target" id="index-72"></span></dd></dl>

<dl class="method">
<dt id="object.__str__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__str__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__str__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str(object)</span></code></a> 와 내장 함수 <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a>, <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 에 의해 호출되어 객체의 “비형식적인(informal)” 또는 보기 좋게 인쇄 가능한 문자열 표현을 계산합니다. 반환 값은 반드시 <a class="reference internal" href="../library/stdtypes.html#textseq"><span class="std std-ref">문자열</span></a> 객체여야 합니다.</p>
<p>이 메서드는 <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> 이 올바른 파이썬 표현식을 돌려줄 것이라고 기대되지 않는다는 점에서 <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a> 과 다릅니다: 더 편리하고 간결한 표현이 사용될 수 있습니다.</p>
<p>내장형 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 에 정의된 기본 구현은 <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a> 을 호출합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__bytes__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__bytes__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bytes__" title="정의 주소">¶</a></dt>
<dd><p id="index-73"><a class="reference internal" href="../library/functions.html#func-bytes"><span class="std std-ref">bytes</span></a> 에 의해 호출되어 객체의 바이트열 표현을 계산합니다. 반환 값은 반드시 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 객체여야 합니다.</p>
<span class="target" id="index-74"></span></dd></dl>

<dl class="method">
<dt id="object.__format__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__format__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">format_spec</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__format__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 내장 함수, 확대하면, <a class="reference internal" href="lexical_analysis.html#f-strings"><span class="std std-ref">포맷 문자열 리터럴(formatted string literals)</span></a> 의 계산과 <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 메서드에 의해 호출되어, 객체의 “포맷된” 문자열 표현을 만들어냅니다. <em>format_spec</em> 인자는 요구되는 포맷 옵션들을 포함하는 문자열입니다. <em>format_spec</em> 인자의 해석은 <a class="reference internal" href="#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a> 을 구현하는 형에 달려있으나, 대부분 클래스는 포매팅을 내향형들의 하나로 위임하거나, 비슷한 포맷 옵션 문법을 사용합니다.</p>
<p>표준 포매팅 문법에 대해서는 <a class="reference internal" href="../library/string.html#formatspec"><span class="std std-ref">포맷 명세 미니 언어</span></a> 를 참고하면 됩니다.</p>
<p>반환 값은 반드시 문자열이어야 합니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.4에서 변경: </span><code class="docutils literal notranslate"><span class="pre">object</span></code> 의 __format__ 메서드 자신은, 빈 문자열이 아닌 인자가 전달되면 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 발생시킵니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>이제 <code class="docutils literal notranslate"><span class="pre">object.__format__(x,</span> <span class="pre">'')</span></code> 는 <code class="docutils literal notranslate"><span class="pre">format(str(x),</span> <span class="pre">'')</span></code> 가 아니라 <code class="docutils literal notranslate"><span class="pre">str(x)</span></code> 와 동등합니다.</p>
</div>
</dd></dl>

<span class="target" id="richcmpfuncs"></span><dl class="method">
<dt id="object.__lt__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__lt__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lt__" title="정의 주소">¶</a></dt>
<dt id="object.__le__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__le__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__le__" title="정의 주소">¶</a></dt>
<dt id="object.__eq__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__eq__" title="정의 주소">¶</a></dt>
<dt id="object.__ne__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ne__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ne__" title="정의 주소">¶</a></dt>
<dt id="object.__gt__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__gt__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__gt__" title="정의 주소">¶</a></dt>
<dt id="object.__ge__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ge__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ge__" title="정의 주소">¶</a></dt>
<dd><p id="index-75">이것들은 소위 “풍부한 비교(rich comparison)” 메서드입니다. 연산자 기호와 메서드 이름 간의 관계는 다음과 같습니다: <code class="docutils literal notranslate"><span class="pre">x&lt;y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__lt__(y)</span></code> 를 호출합니다, <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__le__(y)</span></code> 를 호출합니다, <code class="docutils literal notranslate"><span class="pre">x==y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__eq__(y)</span></code> 를 호출합니다, <code class="docutils literal notranslate"><span class="pre">x!=y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__ne__(y)</span></code> 를 호출합니다, <code class="docutils literal notranslate"><span class="pre">x&gt;y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__gt__(y)</span></code> 를 호출합니다, <code class="docutils literal notranslate"><span class="pre">x&gt;=y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x.__ge__(y)</span></code> 를 호출합니다.</p>
<p>풍부한 비교 메서드는 주어진 한 쌍의 인자에게 해당 연산을 구현하지 않는 경우 단일자(singleton) <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 를 돌려줄 수 있습니다. 관례상, 성공적인 비교면 <code class="docutils literal notranslate"><span class="pre">False</span></code> 나 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 돌려줍니다. 하지만, 이 메서드는 어떤 형의 값이건 돌려줄 수 있습니다, 그래서 비교 연산자가 논리 문맥(Boolean context) (예를 들어 <code class="docutils literal notranslate"><span class="pre">if</span></code> 문의 조건)에서 사용되면, 파이썬은 결과의 참 거짓을 파악하기 위해 값에 대해 <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> 을 호출합니다.</p>
<p>기본적으로, <code class="docutils literal notranslate"><span class="pre">object</span></code>는 <code class="docutils literal notranslate"><span class="pre">is</span></code>를 사용해서 거짓으로 비교될 때 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>를 반환하는 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a>를 구현합니다: <code class="docutils literal notranslate"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span> <span class="pre">else</span> <span class="pre">NotImplemented</span></code>. <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a>의 경우는, 기본적으로 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a>에 위임하고 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 가 아니라면 그 결과를 뒤집습니다. 비교 연산자나 기본 구현 간의 다른 암시적인 관계는 없습니다; 예를 들어, <code class="docutils literal notranslate"><span class="pre">(x&lt;y</span> <span class="pre">or</span> <span class="pre">x==y)</span></code> 가 참이라고 해서 <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code> 가 참일 필요는 없습니다. 하나의 기본 연산으로부터 대소관계 연산을 자동으로 만들어내려면, <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.total_ordering()</span></code></a>을 보십시오.</p>
<p>사용자 정의 비교 연산자를 지원하고 딕셔너리 키로 사용될 수 있는 <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">해시 가능</span></a> 객체를 만드는 것에 관한 몇 가지 중요한 내용이 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 에 관한 문단에 나옵니다.</p>
<p>이 메서드들에 대한 (왼편의 인자는 연산을 지원하지 않지만, 오른편 인자가 지원할 때 사용되는) 뒤집힌 버전은 따로 없습니다; 대신에 <a class="reference internal" href="#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> 와 <a class="reference internal" href="#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> 는 서로의 뒤집힌 연산입니다; <a class="reference internal" href="#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a> 와 <a class="reference internal" href="#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> 는 서로의 뒤집힌 연산입니다; <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 와 <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> 는 서로의 뒤집힌 연산입니다; 만약 피연산자가 서로 다른 형이고, 오른편 피연산자의 형이 왼편 피연산자의 형의 직간접적인 서브 클래스면, 오른편 피연산자의 뒤집힌 버전이 우선순위가 높습니다; 그렇지 않으면 왼편 피연산자의 메서드가 우선순위가 높습니다. 가상 서브 클래싱(virtual subclassing)은 고려되지 않습니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__hash__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__hash__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__hash__" title="정의 주소">¶</a></dt>
<dd><p id="index-76">Called by built-in function <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> and for operations on members of
hashed collections including <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, and
<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.  The <code class="docutils literal notranslate"><span class="pre">__hash__()</span></code> method should return an integer. The only required
property is that objects which compare equal have the same hash value; it is
advised to mix together the hash values of the components of the object that
also play a part in comparison of objects by packing them into a tuple and
hashing the tuple. Example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nick</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> 는 객체가 정의한 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드가 돌려주는 값을 <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> 의 크기로 자릅니다(truncate). 이것은 보통 64-bit 빌드에서는 8바이트고, 32-bit 빌드에서는 4바이트입니다. 만약 객체의 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 가 서로 다른 비트 크기를 갖는 빌드들 사이에서 함께 사용되어야 한다면, 모든 지원할 빌드들에서의 폭을 검사해야 합니다. 이렇게 하는 쉬운 방법은 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-c</span> <span class="pre">&quot;import</span> <span class="pre">sys;</span> <span class="pre">print(sys.hash_info.width)&quot;</span></code> 입니다.</p>
</div>
<p>만약 클래스가 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 정의하지 않으면 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 역시 정의하지 말아야 합니다. 만약 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 정의하지만 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 를 정의하지 않는다면, 그것의 인스턴스는 해시 가능 컬렉션에서 사용될 수 없습니다. 만약 클래스가 가변형 객체를 정의하고 있고 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 구현한다면, <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 를 구현하지 말아야 하는데, 해시 가능 컬렉션들의 구현이 키의 해시값이 불변이도록 요구하고 있기 때문입니다(만약 객체의 해시값이 변하면, 잘못된 해시 버킷(hash bucket)에 있게 됩니다).</p>
<p>사용자 정의 클래스는 기본적으로 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 와 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드를 갖습니다; 모든 객체는 (자기 자신을 제외하고) 같지 않다고 비교되고, <code class="docutils literal notranslate"><span class="pre">x.__hash__()</span></code> 는 적절한 값을 돌려주어, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> 일 때 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> 와 <code class="docutils literal notranslate"><span class="pre">hash(x)</span> <span class="pre">==</span> <span class="pre">hash(y)</span></code> 가 동시에 성립할 수 있도록 합니다.</p>
<p><a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 재정의하고 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 를 정의하지 않는 클래스는 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정됩니다. 클래스의 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 메서드가 <code class="docutils literal notranslate"><span class="pre">None</span></code> 이면, 클래스의 인스턴스는 프로그램이 해시값을 얻으려 시도할 때 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으키고, <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code> 로 검사할 때 해시 가능하지 않다고 올바로 감지됩니다.</p>
<p>만약 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 재정의하는 클래스가 부모 클래스로부터 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 의 구현을 물려받고 싶으면 인터프리터에게 명시적으로 이렇게 지정해주어야 합니다: <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">&lt;ParentClass&gt;.__hash__</span></code>.</p>
<p>만약 <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 를 재정의하지 않는 클래스가 해시 지원을 멈추고 싶으면, 클래스 정의에 <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> 을 포함해야 합니다. 자신의 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 을 정의한 후에 직접 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 를 일으키는 경우는 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code> 호출이 해시 가능하다고 잘못 인식합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>기본적으로, str과 bytes 객체들의 <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> 값은 예측할 수 없는 난수값으로 “솔트되어(salted)” 있습니다. 개별 파이썬 프로세스 내에서는 변하지 않는 값으로 유지되지만, 파이썬을 반복적으로 실행할 때는 예측할 수 없게 됩니다.</p>
<p>This is intended to provide protection against a denial-of-service caused
by carefully-chosen inputs that exploit the worst case performance of a
dict insertion, O(n<sup>2</sup>) complexity.  See
<a class="reference external" href="http://www.ocert.org/advisories/ocert-2011-003.html">http://www.ocert.org/advisories/ocert-2011-003.html</a> for details.</p>
<p>해시값의 변경은 집합의 이터레이션 순서에 영향을 줍니다, 파이썬은 이 순서에 대해 어떤 보장도 하지 않습니다 (그리고 보통 32-bit 와 64-bit 빌드 사이에서도 다릅니다).</p>
<p><span class="target" id="index-115"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a> 를 참고하십시오.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.3에서 변경: </span>해시 난수 화는 기본적으로 활성화됩니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__bool__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__bool__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bool__" title="정의 주소">¶</a></dt>
<dd><p id="index-78">논리값 검사와 내장 연산 <code class="docutils literal notranslate"><span class="pre">bool()</span></code> 구현을 위해 호출됩니다; <code class="docutils literal notranslate"><span class="pre">False</span></code> 나 <code class="docutils literal notranslate"><span class="pre">True</span></code> 를 돌려줘야 합니다. 이 메서드가 정의되지 않는 경우, 정의되어 있다면 <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 이 호출되어, 값이 0 이 아니면 참으로 인식합니다. 만약 클래스가 <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 과 <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> 모두 정의하지 않는다면, 모든 인스턴스는 참으로 취급됩니다.</p>
</dd></dl>

</section>
<section id="customizing-attribute-access">
<span id="attribute-access"></span><h3><span class="section-number">3.3.2. </span>어트리뷰트 액세스 커스터마이제이션<a class="headerlink" href="#customizing-attribute-access" title="제목 주소">¶</a></h3>
<p>클래스 인스턴스의 어트리뷰트 참조(읽기, 대입하기, <code class="docutils literal notranslate"><span class="pre">x.name</span></code> 을 삭제하기)의 의미를 변경하기 위해 다음과 같은 메서드들이 정의될 수 있습니다.</p>
<dl class="method">
<dt id="object.__getattr__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__getattr__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattr__" title="정의 주소">¶</a></dt>
<dd><p>기본 어트리뷰트 액세스가 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 로 실패할 때 호출됩니다 (<em>name</em> 이 인스턴스 어트리뷰트 또는 <code class="docutils literal notranslate"><span class="pre">self</span></code> 의 클래스 트리에 있는 어트리뷰트가 아니라서 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 가 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 일으키거나; <em>name</em> 프로퍼티의 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> 이 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 일으킬 때). 이 메서드는 (계산된) 어트리뷰트 값을 반환하거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 예외를 일으켜야 합니다.</p>
<p>일반적인 메커니즘을 통해 어트리뷰트가 발견되면 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 이 호출되지 않음에 주의해야 합니다 (이것은 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 과 <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 간의 의도된 비대칭입니다). 이렇게 하는 이유는 효율 때문이기도 하고, 그렇게 하지 않으면 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 가 인스턴스의 다른 어트리뷰트에 접근할 방법이 없기 때문이기도 합니다. 적어도 인스턴스 변수의 경우, 어떤 값도 인스턴스 어트리뷰트 딕셔너리에 넣지 않음으로써 (대신에 그것들을 다른 객체에 넣습니다) 완전한 제어인 것처럼 조작할 수 있습니다. 어트리뷰트 액세스를 실제로 완전히 조작하는 방법에 대해서는 아래에 나오는 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 에서 다룹니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__getattribute__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__getattribute__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattribute__" title="정의 주소">¶</a></dt>
<dd><p>클래스 인스턴스의 어트리뷰트 액세스를 구현하기 위해 조건 없이 호출됩니다. 만약 클래스가 <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> 도 함께 구현하면, <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 가 명시적으로 호출하거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 일으키지 않는 이상 <cite>__getattr__</cite> 는 호출되지 않습니다. 이 메서드는 어트리뷰트의 (계산된) 값을 돌려주거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 예외를 일으켜야 합니다. 이 메서드에서 무한 재귀(infinite recursion)가 발생하는 것을 막기 위해, 구현은 언제나 필요한 어트리뷰트에 접근하기 위해 같은 이름의 베이스 클래스의 메서드를 호출해야 합니다. 예를 들어, <code class="docutils literal notranslate"><span class="pre">object.__getattribute__(self,</span> <span class="pre">name)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>언어 문법이나 내장 함수에 의한 묵시적인 호출이 결과로 특수 메서드를 참조하는 경우에는 이 메서드를 거치지 않을 수 있습니다. 자세한 내용은 <a class="reference internal" href="#special-lookup"><span class="std std-ref">특수 메서드 조회</span></a> 에서 다룹니다.</p>
</div>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">obj</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>으로 <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code>을 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__setattr__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__setattr__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setattr__" title="정의 주소">¶</a></dt>
<dd><p>어트리뷰트 대입이 시도될 때 호출됩니다. 일반적인 메커니즘(즉 인스턴스 딕셔너리에 값을 저장하는 것) 대신에 이것이 호출됩니다. <em>name</em> 은 어트리뷰트 이름이고, <em>value</em> 는 그것에 대입하려는 값입니다.</p>
<p><a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 에서 인스턴스 어트리뷰트에 대입하려고 할 때는, 같은 이름의 베이스 클래스의 메서드를 호출해야 합니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">object.__setattr__(self,</span> <span class="pre">name,</span> <span class="pre">value)</span></code></p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">obj</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">value</span></code>로 <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">object.__setattr__</span></code>을 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__delattr__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__delattr__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delattr__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 과 비슷하지만 어트리뷰트를 대입하는 대신에 삭제합니다. 이것은 <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">obj.name</span></code> 이 객체에 의미가 있는 경우에만 구현되어야 합니다.</p>
<p class="audit-hook">인자 <code class="docutils literal notranslate"><span class="pre">obj</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>으로 <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">감사 이벤트</span></a> <code class="docutils literal notranslate"><span class="pre">object.__delattr__</span></code>을 발생시킵니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__dir__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__dir__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__dir__" title="정의 주소">¶</a></dt>
<dd><p>객체에 <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 이 호출될 때 호출됩니다. 시퀀스를 돌려줘야 합니다. <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 은 돌려준 시퀀스를 리스트로 변환한 후 정렬합니다.</p>
</dd></dl>

<section id="customizing-module-attribute-access">
<h4><span class="section-number">3.3.2.1. </span>모듈 어트리뷰트 액세스 커스터마이제이션<a class="headerlink" href="#customizing-module-attribute-access" title="제목 주소">¶</a></h4>
<p id="index-79">특수한 이름 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 과 <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> 는 모듈 어트리뷰트에 대한 접근을 사용자 정의하는 데 사용될 수도 있습니다. 모듈 수준의 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 함수는 하나의 인자로 어트리뷰트의 이름을 받아서 계산된 값을 돌려주거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 발생시켜야 합니다. 일반적인 조회(즉 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__getattribute__()</span></code></a>)를 통해 어트리뷰트가 모듈 객체에서 발견되지 않으면, <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 를 일으키기 전에 모듈 <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> 에서 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 을 검색합니다. 발견되면, 어트리뷰트 이름으로 그 함수를 호출하고 결과를 돌려줍니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">__dir__</span></code> 함수는 인자를 받지 않고 모듈에서 접근 할 수 있는 이름을 나타내는 문자열의 시퀀스를 돌려줘야 합니다. 존재하면, 이 함수는 모듈에 대한 표준 <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 검색을 재정의합니다.</p>
<p>모듈 동작(어트리뷰트 설정, 프로퍼티 등)을 보다 세밀하게 사용자 정의하려면, 모듈 객체의 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 어트리뷰트를 <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> 의 서브 클래스로 설정할 수 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">ModuleType</span>

<span class="k">class</span> <span class="nc">VerboseModule</span><span class="p">(</span><span class="n">ModuleType</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Verbose </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Setting </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">VerboseModule</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>모듈 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 정의와 모듈 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 설정은 어트리뷰트 액세스 구문을 사용하는 조회에만 영향을 미칩니다 – 모듈 전역에 대한 직접적인 액세스(모듈 내의 코드에 의한 액세스이거나 모듈의 전역 딕셔너리에 대한 참조를 거치거나)는 영향받지 않습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5에서 변경: </span>이제 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 모듈 어트리뷰트가 쓰기 가능합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7에 추가: </span><code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 과 <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> 모듈 어트리뷰트.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-116"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0562"><strong>PEP 562</strong></a> - 모듈 __getattr__ 과 __dir__</dt><dd><p>모듈에 대한 <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> 과 <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> 함수를 설명합니다.</p>
</dd>
</dl>
</div>
</section>
<section id="implementing-descriptors">
<span id="descriptors"></span><h4><span class="section-number">3.3.2.2. </span>디스크립터 구현하기<a class="headerlink" href="#implementing-descriptors" title="제목 주소">¶</a></h4>
<p>다음에 오는 메서드들은 메서드를 가진 클래스(소위 <em>디스크립터(descriptor)</em> 클래스)의 인스턴스가 <em>소유자(owner)</em> 클래스에 등장할 때만 적용됩니다(디스크립터는 소유자 클래스의 딕셔너리나 그 부모 클래스 중 하나의 딕셔너리에 있어야 합니다). 아래의 예에서, “어트리뷰트” 는 이름이 소유자 클래스의 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 의 키로 사용되고 있는 어트리뷰트를 가리킵니다.</p>
<dl class="method">
<dt id="object.__get__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__get__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">instance</em>, <em class="sig-param">owner=None</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__get__" title="정의 주소">¶</a></dt>
<dd><p>소유자 클래스(클래스 어트리뷰트 액세스) 나 그 클래스의 인스턴스(인스턴스 어트리뷰트 액세스)의 어트리뷰트를 취하려고 할 때 호출됩니다. 선택적 <em>owner</em> 인자는 소유자 클래스입니다. 반면에 <em>instance</em> 는 어트리뷰트 참조가 일어나고 있는 인스턴스이거나, 어트리뷰트가 <em>owner</em> 를 통해 액세스 되는 경우 <cite>None</cite> 입니다.</p>
<p>이 메서드는 계산된 어트리뷰트 값을 돌려주거나 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> 예외를 일으켜야 합니다.</p>
<p><span class="target" id="index-117"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0252"><strong>PEP 252</strong></a>는 <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>이 하나나 두 개의 인자를 갖는 콜러블이라고 지정합니다. 파이썬 자신의 내장 디스크립터는 이 명세를 지원합니다; 그러나, 일부 제삼자 도구에는 두 인수를 모두 요구하는 디스크립터가 있을 수 있습니다. 파이썬 자신의 <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 구현은 필요한지와 관계없이 항상 두 인자를 모두 전달합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__set__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__set__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">instance</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set__" title="정의 주소">¶</a></dt>
<dd><p>소유자 클래스의 인스턴스 <em>instance</em> 의 어트리뷰트를 새 값 <em>value</em> 로 설정할 때 호출됩니다.</p>
<p><a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a>이나 <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>를 추가하면 디스크립터 유형이 “데이터 디스크립터(data descriptor)”로 변경됨에 유의하십시오. 자세한 내용은 <a class="reference internal" href="#descriptor-invocation"><span class="std std-ref">디스크립터 호출하기</span></a>를 참조하십시오.</p>
</dd></dl>

<dl class="method">
<dt id="object.__delete__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__delete__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">instance</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delete__" title="정의 주소">¶</a></dt>
<dd><p>소유자 클래스의 인스턴스 <em>instance</em> 의 어트리뷰트를 삭제할 때 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__set_name__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__set_name__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">owner</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set_name__" title="정의 주소">¶</a></dt>
<dd><p>소유자 클래스 <em>owner</em> 가 만들어질 때 호출됩니다. 이 디스크립터가 <em>name</em> 에 대입되었습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a>은 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 생성자의 일부로 묵시적으로만 호출되므로, 초기 생성 이후에 디스크립터가 클래스에 추가될 때 적절한 매개 변수로 명시적으로 호출할 필요가 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
   <span class="k">pass</span>
<span class="n">descr</span> <span class="o">=</span> <span class="n">custom_descriptor</span><span class="p">()</span>
<span class="n">A</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="n">descr</span>
<span class="n">descr</span><span class="o">.</span><span class="n">__set_name__</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;attr&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>더 자세한 내용은 <a class="reference internal" href="#class-object-creation"><span class="std std-ref">클래스 객체 만들기</span></a> 을 참고하십시오.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<p>어트리뷰트 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__objclass__</span></code> 는 <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 모듈에 의해 이 객체가 정의된 클래스를 지정하는 것으로 해석됩니다(이 값을 적절히 설정하면 동적인 클래스 어트리뷰트의 실행시간 인트로스펙션(introspection)을 지원할 수 있습니다). 콜러블의 경우, 첫 번째 위치 인자에, 주어진 형(또는 서브 클래스)의 인스턴스가 기대되거나 요구됨을 가리킬 수 있습니다(예를 들어, CPython 은 C로 구현된 연결되지 않은 메서드(unbound method)에 이 어트리뷰트를 설정합니다).</p>
</section>
<section id="invoking-descriptors">
<span id="descriptor-invocation"></span><h4><span class="section-number">3.3.2.3. </span>디스크립터 호출하기<a class="headerlink" href="#invoking-descriptors" title="제목 주소">¶</a></h4>
<p>In general, a descriptor is an object attribute with “binding behavior”, one
whose attribute access has been overridden by methods in the descriptor
protocol:  <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a>, and
<a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>. If any of
those methods are defined for an object, it is said to be a descriptor.</p>
<p>어트리뷰트 액세스의 기본 동작은 객체의 딕셔너리에서 어트리뷰트를 읽고, 쓰고, 삭제하는 것입니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">a.x</span></code> 는 <code class="docutils literal notranslate"><span class="pre">a.__dict__['x']</span></code> 에서 시작해서 <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x']</span></code> 를 거쳐 <code class="docutils literal notranslate"><span class="pre">type(a)</span></code> 의 메타 클래스를 제외한 베이스 클래스들을 거쳐 가는 일련의 조회로 구성됩니다.</p>
<p>그러나, 만약 조회한 값이 디스크립터 메서드를 구현한 객체면, 파이썬은 기본 동작 대신에 디스크립터 메서드를 호출할 수 있습니다. 우선순위 목록의 어느 위치에서 이런 일이 일어나는지는 어떤 디스크립터 메서드가 정의되어 있고 어떤 식으로 호출되는지에 따라 다릅니다.</p>
<p>디스크립터 호출의 시작점은 결합(binding)입니다, <code class="docutils literal notranslate"><span class="pre">a.x</span></code>. 어떻게 인자들이 조합되는지는 <code class="docutils literal notranslate"><span class="pre">a</span></code> 에 따라 다릅니다:</p>
<dl class="simple">
<dt>직접 호출</dt><dd><p>가장 간단하면서도 가장 덜 사용되는 호출은 사용자의 코드가 디스크립터 메서드를 직접 호출할 때입니다: <code class="docutils literal notranslate"><span class="pre">x.__get__(a)</span></code></p>
</dd>
<dt>인스턴스 결합</dt><dd><p>객체 인스턴스에 결합하면, <code class="docutils literal notranslate"><span class="pre">a.x</span></code> 는 이런 호출로 변환됩니다: <code class="docutils literal notranslate"><span class="pre">type(a).__dict__['x'].__get__(a,</span> <span class="pre">type(a))</span></code>.</p>
</dd>
<dt>클래스 결합</dt><dd><p>클래스에 결합하면, <code class="docutils literal notranslate"><span class="pre">A.x</span></code> 는 이런 호출로 변환됩니다: <code class="docutils literal notranslate"><span class="pre">A.__dict__['x'].__get__(None,</span> <span class="pre">A)</span></code>.</p>
</dd>
<dt>Super 결합</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">a</span></code> is an instance of <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-class docutils literal notranslate"><span class="pre">super</span></code></a>, then the binding <code class="docutils literal notranslate"><span class="pre">super(B,</span> <span class="pre">obj).m()</span></code>
searches <code class="docutils literal notranslate"><span class="pre">obj.__class__.__mro__</span></code> for the base class <code class="docutils literal notranslate"><span class="pre">A</span></code>
immediately following <code class="docutils literal notranslate"><span class="pre">B</span></code> and then invokes the descriptor with the call:
<code class="docutils literal notranslate"><span class="pre">A.__dict__['m'].__get__(obj,</span> <span class="pre">obj.__class__)</span></code>.</p>
</dd>
</dl>
<p>For instance bindings, the precedence of descriptor invocation depends on
which descriptor methods are defined.  A descriptor can define any combination
of <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> and
<a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>.  If it does not
define <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, then accessing the attribute will return the descriptor
object itself unless there is a value in the object’s instance dictionary.  If
the descriptor defines <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> and/or <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>, it is a data
descriptor; if it defines neither, it is a non-data descriptor.  Normally, data
descriptors define both <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> and <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a>, while non-data
descriptors have just the <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> method.  Data descriptors with
<a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> and <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> (and/or <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>) defined always override a redefinition in an
instance dictionary.  In contrast, non-data descriptors can be overridden by
instances.</p>
<p>Python methods (including those decorated with
<a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code></a> and <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;classmethod</span></code></a>) are
implemented as non-data descriptors.  Accordingly, instances can redefine and
override methods.  This allows individual instances to acquire behaviors that
differ from other instances of the same class.</p>
<p><a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> 함수는 데이터 디스크립터로 구현됩니다. 이 때문에, 인스턴스는 프로퍼티(property)의 동작을 변경할 수 없습니다.</p>
</section>
<section id="slots">
<span id="id3"></span><h4><span class="section-number">3.3.2.4. </span>__slots__<a class="headerlink" href="#slots" title="제목 주소">¶</a></h4>
<p><em>__slots__</em> allow us to explicitly declare data members (like
properties) and deny the creation of <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> and <em>__weakref__</em>
(unless explicitly declared in <em>__slots__</em> or available in a parent.)</p>
<p>The space saved over using <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> can be significant.
Attribute lookup speed can be significantly improved as well.</p>
<dl class="data">
<dt id="object.__slots__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__slots__</code><a class="headerlink" href="#object.__slots__" title="정의 주소">¶</a></dt>
<dd><p>This class variable can be assigned a string, iterable, or sequence of
strings with variable names used by instances.  <em>__slots__</em> reserves space
for the declared variables and prevents the automatic creation of
<a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>
and <em>__weakref__</em> for each instance.</p>
</dd></dl>

<section id="notes-on-using-slots">
<h5><span class="section-number">3.3.2.4.1. </span><em>__slots__</em> 사용에 관한 노트<a class="headerlink" href="#notes-on-using-slots" title="제목 주소">¶</a></h5>
<ul class="simple">
<li><p>When inheriting from a class without <em>__slots__</em>, the
<a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> and
<em>__weakref__</em> attribute of the instances will always be accessible.</p></li>
<li><p>Without a <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> variable, instances cannot be assigned new
variables not
listed in the <em>__slots__</em> definition.  Attempts to assign to an unlisted
variable name raises <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. If dynamic assignment of new
variables is desired, then add <code class="docutils literal notranslate"><span class="pre">'__dict__'</span></code> to the sequence of strings in
the <em>__slots__</em> declaration.</p></li>
<li><p>Without a <em>__weakref__</em> variable for each instance, classes defining
<em>__slots__</em> do not support <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weak</span> <span class="pre">references</span></code></a> to its instances.
If weak reference
support is needed, then add <code class="docutils literal notranslate"><span class="pre">'__weakref__'</span></code> to the sequence of strings in the
<em>__slots__</em> declaration.</p></li>
<li><p><em>__slots__</em> are implemented at the class level by creating <a class="reference internal" href="#descriptors"><span class="std std-ref">descriptors</span></a>
for each variable name.  As a result, class attributes
cannot be used to set default values for instance variables defined by
<em>__slots__</em>; otherwise, the class attribute would overwrite the descriptor
assignment.</p></li>
<li><p>The action of a <em>__slots__</em> declaration is not limited to the class
where it is defined.  <em>__slots__</em> declared in parents are available in
child classes. However, child subclasses will get a <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> and
<em>__weakref__</em> unless they also define <em>__slots__</em> (which should only
contain names of any <em>additional</em> slots).</p></li>
<li><p>클래스가 베이스 클래스의 <em>__slots__</em> 에 정의된 이름과 같은 이름의 변수를 <em>__slots__</em> 에 선언한다면, 베이스 클래스가 정의한 변수는 액세스할 수 없는 상태가 됩니다(베이스 클래스로부터 디스크립터를 직접 조회하는 경우는 예외다). 이것은 프로그램을 정의되지 않은 상태로 보내게 됩니다. 미래에는, 이를 방지하기 위한 검사가 추가될 것입니다.</p></li>
<li><p><a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>과 같은 “가변 길이(valiable-length)” 의 내장형들을 계승하는 클래스에서는 오직 빈 <em>__slots__</em> 만 지원됩니다.</p></li>
<li><p>Any non-string <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> may be assigned to <em>__slots__</em>.</p></li>
<li><p>If a <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a> is used to assign <em>__slots__</em>, the dictionary
keys will be used as the slot names. The values of the dictionary can be used
to provide per-attribute docstrings that will be recognised by
<a class="reference internal" href="../library/inspect.html#inspect.getdoc" title="inspect.getdoc"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getdoc()</span></code></a> and displayed in the output of <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="../library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> assignment works only if both classes have the
same <em>__slots__</em>.</p></li>
<li><p><a class="reference internal" href="../tutorial/classes.html#tut-multiple"><span class="std std-ref">Multiple inheritance</span></a> with multiple slotted parent
classes can be used,
but only one parent is allowed to have attributes created by slots
(the other bases must have empty slot layouts) - violations raise
<a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p></li>
<li><p>If an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> is used for <em>__slots__</em> then a <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a> is
created for each
of the iterator’s values. However, the <em>__slots__</em> attribute will be an empty
iterator.</p></li>
</ul>
</section>
</section>
</section>
<section id="customizing-class-creation">
<span id="class-customization"></span><h3><span class="section-number">3.3.3. </span>클래스 생성 커스터마이제이션<a class="headerlink" href="#customizing-class-creation" title="제목 주소">¶</a></h3>
<p>Whenever a class inherits from another class, <a class="reference internal" href="#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> is
called on the parent class. This way, it is possible to write classes which
change the behavior of subclasses. This is closely related to class
decorators, but where class decorators only affect the specific class they’re
applied to, <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> solely applies to future subclasses of the
class defining the method.</p>
<dl class="method">
<dt id="object.__init_subclass__">
<em class="property">classmethod </em><code class="sig-prename descclassname">object.</code><code class="sig-name descname">__init_subclass__</code><span class="sig-paren">(</span><em class="sig-param">cls</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__init_subclass__" title="정의 주소">¶</a></dt>
<dd><p>이 메서드는 포함하는 클래스의 서브 클래스가 만들어질 때마다 호출됩니다. <em>cls</em> 는 새 서브 클래스입니다. 만약 일반적인 인스턴스 메서드로 정의되면, 이 메서드는 묵시적으로 클래스 메서드로 변경됩니다.</p>
<p>새 클래스에 주어진 키워드 인자들은 부모 클래스의 <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> 로 전달됩니다. <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> 를 사용하는 다른 클래스들과의 호환성을 위해, 필요한 키워드 인자들을 꺼낸 후에 다른 것들을 베이스 클래스로 전달해야 합니다. 이런 식입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Philosopher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">default_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">default_name</span> <span class="o">=</span> <span class="n">default_name</span>

<span class="k">class</span> <span class="nc">AustralianPhilosopher</span><span class="p">(</span><span class="n">Philosopher</span><span class="p">,</span> <span class="n">default_name</span><span class="o">=</span><span class="s2">&quot;Bruce&quot;</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>기본 구현 <code class="docutils literal notranslate"><span class="pre">object.__init_subclass__</span></code> 는 아무 일도 하지 않지만, 인자가 포함되어 호출되면 예외를 발생시킵니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>메타 클래스 힌트 <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> 는 나머지 형 절차에 의해 소비되고, <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> 로 전달되지 않습니다. 실제 메타 클래스 (명시적인 힌트 대신에) 는 <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code> 로 액세스할 수 있습니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6에 추가.</span></p>
</div>
</dd></dl>

<section id="metaclasses">
<span id="id4"></span><h4><span class="section-number">3.3.3.1. </span>메타 클래스<a class="headerlink" href="#metaclasses" title="제목 주소">¶</a></h4>
<p id="index-82">기본적으로, 클래스는 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 을 사용해서 만들어집니다. 클래스의 바디는 새 이름 공간에서 실행되고, 클래스 이름은 <code class="docutils literal notranslate"><span class="pre">type(name,</span> <span class="pre">bases,</span> <span class="pre">namespace)</span></code> 의 결과에 지역적으로 연결됩니다.</p>
<p>클래스를 만드는 과정은 클래스 정의 줄에 <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> 키워드 인자를 전달하거나, 그런 인자를 포함한 이미 존재하는 클래스를 계승함으로써 커스터마이즈될 수 있습니다. 다음 예에서, <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> 와 <code class="docutils literal notranslate"><span class="pre">MySubclass</span></code> 는 모두 <code class="docutils literal notranslate"><span class="pre">Meta</span></code> 의 인스턴스입니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MySubclass</span><span class="p">(</span><span class="n">MyClass</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>클래스 정의에서 지정된 다른 키워드 인자들은 아래에서 설명되는 모든 메타 클래스 연산들로 전달됩니다.</p>
<p>클래스 정의가 실행될 때, 다음과 같은 단계가 수행됩니다.:</p>
<ul class="simple">
<li><p>MRO 항목이 결정됩니다;</p></li>
<li><p>적절한 메타 클래스가 결정됩니다;</p></li>
<li><p>클래스 이름 공간이 준비됩니다;</p></li>
<li><p>클래스 바디가 실행됩니다;</p></li>
<li><p>클래스 객체가 만들어집니다.</p></li>
</ul>
</section>
<section id="resolving-mro-entries">
<h4><span class="section-number">3.3.3.2. </span>MRO 항목 결정하기<a class="headerlink" href="#resolving-mro-entries" title="제목 주소">¶</a></h4>
<p>클래스 정의에 나타나는 베이스 클래스가 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 의 인스턴스가 아닌 경우, 거기에서 <code class="docutils literal notranslate"><span class="pre">__mro_entries__</span></code> 메서드를 검색합니다. 발견되면, 원래의 베이스 튜플로 호출됩니다. 이 메서드는 이 베이스 대신에 사용될 클래스의 튜플을 돌려줘야 합니다. 튜플은 비어있을 수 있습니다. 이 경우 원래 베이스는 무시됩니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><span class="target" id="index-118"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0560"><strong>PEP 560</strong></a> - typing 모듈과 제네릭 형에 대한 코어 지원</p>
</div>
</section>
<section id="determining-the-appropriate-metaclass">
<h4><span class="section-number">3.3.3.3. </span>적절한 메타 클래스 선택하기<a class="headerlink" href="#determining-the-appropriate-metaclass" title="제목 주소">¶</a></h4>
<p id="index-84">클래스 정의의 적절한 메타 클래스는 다음과 같이 결정됩니다:</p>
<ul class="simple">
<li><p>베이스와 명시적인 메타 클래스를 주지 않는 경우 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 이 사용됩니다;</p></li>
<li><p>명시적인 메타 클래스가 지정되고, 그것이 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 의 인스턴스가 <em>아니면</em>, 그것을 메타 클래스로 사용합니다;</p></li>
<li><p><a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> 의 인스턴스가 명시적인 메타 클래스로 주어지거나, 베이스가 정의되었으면, 가장 많이 파생된 메타 클래스가 사용됩니다.</p></li>
</ul>
<p>가장 많이 파생된 메타 클래스는 명시적으로 지정된 메타 클래스(있다면)와 지정된 모든 베이스 클래스들의 메타 클래스들(즉, <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code>) 중에서 선택됩니다. 가장 많이 파생된 메타 클래스는 이들 <em>모두</em> 의 서브 타입(subtype)입니다. 만약 어느 것도 이 조건을 만족하지 못한다면, 클래스 정의는 <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> 를 발생시키며 실패합니다.</p>
</section>
<section id="preparing-the-class-namespace">
<span id="prepare"></span><h4><span class="section-number">3.3.3.4. </span>클래스 이름 공간 준비하기<a class="headerlink" href="#preparing-the-class-namespace" title="제목 주소">¶</a></h4>
<p id="index-85">Once the appropriate metaclass has been identified, then the class namespace
is prepared. If the metaclass has a <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> attribute, it is called
as <code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">=</span> <span class="pre">metaclass.__prepare__(name,</span> <span class="pre">bases,</span> <span class="pre">**kwds)</span></code> (where the
additional keyword arguments, if any, come from the class definition). The
<code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> method should be implemented as a
<a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod</span></code></a>. The
namespace returned by <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> is passed in to <code class="docutils literal notranslate"><span class="pre">__new__</span></code>, but when
the final class object is created the namespace is copied into a new <code class="docutils literal notranslate"><span class="pre">dict</span></code>.</p>
<p>만약 메타 클래스에 <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 어트리뷰트가 없다면, 클래스 이름 공간은 빈 순서 있는 매핑으로 초기화됩니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-119"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3115"><strong>PEP 3115</strong></a> - 파이썬 3000 에서의 메타 클래스</dt><dd><p><code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 이름 공간 훅을 도입했습니다</p>
</dd>
</dl>
</div>
</section>
<section id="executing-the-class-body">
<h4><span class="section-number">3.3.3.5. </span>클래스 바디 실행하기<a class="headerlink" href="#executing-the-class-body" title="제목 주소">¶</a></h4>
<p id="index-87">클래스 바디는 (대략) <code class="docutils literal notranslate"><span class="pre">exec(body,</span> <span class="pre">globals(),</span> <span class="pre">namespace)</span></code> 과같이 실행됩니다. 일반적인 <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 호출과 주된 차이점은 클래스 정의가 함수 내부에서 이루어질 때 어휘 스코핑(lexical scoping) 이 클래스 바디(모든 메서드들을 포함해서)로 하여금 현재와 외부 스코프에 있는 이름들을 참조하도록 허락한다는 것입니다.</p>
<p>하지만, 클래스 정의가 함수 내부에서 이루어질 때조차도, 클래스 내부에서 정의된 메서드들은 클래스 스코프에서 정의된 이름들을 볼 수 없습니다. 클래스 변수는 인스턴스나 클래스 메서드의 첫 번째 매개변수를 통해 액세스하거나 다음 섹션에서 설명하는 묵시적으로 어휘 스코핑된 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 참조를 통해야 합니다.</p>
</section>
<section id="creating-the-class-object">
<span id="class-object-creation"></span><h4><span class="section-number">3.3.3.6. </span>클래스 객체 만들기<a class="headerlink" href="#creating-the-class-object" title="제목 주소">¶</a></h4>
<p id="index-88">일단 클래스 이름 공간이 클래스 바디를 실행함으로써 채워지면, 클래스 객체가 <code class="docutils literal notranslate"><span class="pre">metaclass(name,</span> <span class="pre">bases,</span> <span class="pre">namespace,</span> <span class="pre">**kwds)</span></code> 을 통해 만들어집니다(여기에서 전달되는 추가적인 키워드 인자들은 <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> 에 전달된 것들과 같습니다).</p>
<p>이 클래스 객체는 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 에 인자를 주지 않는 경우 참조되는 것입니다. <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 는 클래스 바디의 메서드들 중 어느 하나라도 <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 나 <code class="docutils literal notranslate"><span class="pre">super</span></code> 를 참조할 경우 컴파일러에 의해 만들어지는 묵시적인 클로저(closure) 참조입니다. 이것은 인자 없는 형태의 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 가 어휘 스코핑 기반으로 현재 정의되고 있는 클래스를 올바르게 찾을 수 있도록 합니다. 반면에 현재의 호출에 사용된 클래스나 인스턴스는 메서드로 전달된 첫 번째 인자에 기초해서 식별됩니다.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> CPython 3.6 이상에서, <code class="docutils literal notranslate"><span class="pre">__class__</span></code> 셀(cell)은 클래스 이름 공간의 <code class="docutils literal notranslate"><span class="pre">__classcell__</span></code> 엔트리로 메타 클래스에 전달됩니다. 만약 존재한다면, 이것은 클래스가 올바르게 초기화되기 위해 <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> 호출까지 거슬러서 전파되어야 합니다. 이렇게 하지 못하면 파이썬 3.8 에서는 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>로 이어질 것입니다.</p>
</div>
<p>기본 메타 클래스 <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> 을 사용할 때나 다른 메타 클래스가 결국 <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> 를 호출할 때, 클래스 객체를 만든 후에, 다음과 같은 추가의 커스터마이제이션 단계가 실행됩니다:</p>
<ul class="simple">
<li><p>첫째로, <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> 는 <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> 을 정의하는 클래스 이름 공간의 모든 디스크립터들을 수집합니다;</p></li>
<li><p>둘째로, 이렇게 수집된 모든 <code class="docutils literal notranslate"><span class="pre">__set_name__</span></code> 을 호출하는데, 정의되고 있는 클래스와 디스크립터에 주어진 이름을 인자로 전달합니다;</p></li>
<li><p>마지막으로, 메서드 결정 순서에 따라 가장 가까운 부모에 대해 <a class="reference internal" href="#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> 훅이 호출됩니다.</p></li>
</ul>
<p>클래스 객체가 만들어진 후에, 클래스 정의에 포함된 클래스 데코레이터들에게 (있다면) 클래스를 전달하고, 그 결과를 클래스가 정의되는 지역 이름 공간에 연결합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> 로 새 클래스가 만들어질 때, 이름 공간 매개변수로 제공되는 객체는 새로 만든 순서 있는 매핑으로 복사되고, 원래의 객체는 버립니다. 새 사본은 읽기 전용 프락시(read-only proxy)로 둘러싸이는데, 이것이 클래스 객체의 <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 어트리뷰트가 됩니다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-120"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3135"><strong>PEP 3135</strong></a> - 새 super</dt><dd><p>묵시적인 __class__ 클로저 참조를 설명합니다</p>
</dd>
</dl>
</div>
</section>
<section id="uses-for-metaclasses">
<h4><span class="section-number">3.3.3.7. </span>메타 클래스의 용도<a class="headerlink" href="#uses-for-metaclasses" title="제목 주소">¶</a></h4>
<p>메타 클래스의 잠재적인 용도에는 한계가 없습니다. 탐색 된 몇 가지 아이디어들에는 enum, 로깅, 인터페이스 검사, 자동화된 위임(automatic delegation), 자동화된 프로퍼티(properety) 생성, 프락시(proxy), 프레임웍(framework), 자동화된 자원 로킹/동기화(automatic resource locking/synchronization) 등이 있습니다.</p>
</section>
</section>
<section id="customizing-instance-and-subclass-checks">
<h3><span class="section-number">3.3.4. </span>인스턴스 및 서브 클래스 검사 커스터마이제이션<a class="headerlink" href="#customizing-instance-and-subclass-checks" title="제목 주소">¶</a></h3>
<p>다음 메서드들은 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 와 <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 내장 함수들의 기본 동작을 재정의하는 데 사용됩니다.</p>
<p>특히, 메타 클래스 <a class="reference internal" href="../library/abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABCMeta</span></code></a> 는 추상 베이스 클래스(Abstract Base Class, ABC)를 다른 ABC를 포함한 임의의 클래스나 형(내장형을 포함합니다)에 “가상 베이스 클래스(virtual base class)”로 추가할 수 있게 하려고 이 메서드들을 구현합니다.</p>
<dl class="method">
<dt id="class.__instancecheck__">
<code class="sig-prename descclassname">class.</code><code class="sig-name descname">__instancecheck__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">instance</em><span class="sig-paren">)</span><a class="headerlink" href="#class.__instancecheck__" title="정의 주소">¶</a></dt>
<dd><p><em>instance</em> 가 (직접적이거나 간접적으로) <em>class</em> 의 인스턴스로 취급될 수 있으면 참을 돌려줍니다. 만약 정의되면, <code class="docutils literal notranslate"><span class="pre">isinstance(instance,</span> <span class="pre">class)</span></code> 를 구현하기 위해 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="class.__subclasscheck__">
<code class="sig-prename descclassname">class.</code><code class="sig-name descname">__subclasscheck__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">subclass</em><span class="sig-paren">)</span><a class="headerlink" href="#class.__subclasscheck__" title="정의 주소">¶</a></dt>
<dd><p><em>subclass</em> 가 (직접적이거나 간접적으로) <em>class</em> 의 서브 클래스로 취급될 수 있으면 참을 돌려줍니다. 만약 정의되면, <code class="docutils literal notranslate"><span class="pre">issubclass(subclass,</span> <span class="pre">class)</span></code> 를 구현하기 위해 호출됩니다.</p>
</dd></dl>

<p>이 메서드들은 클래스의 형(메타 클래스)에서 조회된다는 것에 주의해야 합니다. 실제 클래스에서 클래스 메서드로 정의될 수 없습니다. 이것은 인스턴스에 대해 호출되는 특수 메서드들의 조회와 일관성 있습니다. 이 경우 인스턴스는 클래스 자체다.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-121"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3119"><strong>PEP 3119</strong></a> - 추상 베이스 클래스의 도입</dt><dd><p><a class="reference internal" href="#class.__instancecheck__" title="class.__instancecheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__instancecheck__()</span></code></a> 와 <a class="reference internal" href="#class.__subclasscheck__" title="class.__subclasscheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__subclasscheck__()</span></code></a> 를 통해 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 와 <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 의 동작을 커스터마이징하는 데 필요한 규약을 포함하는데, 이 기능의 동기는 언어에 추상 베이스 클래스 (<a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> 모듈을 보십시오)를 추가하고자 하는 데 있습니다.</p>
</dd>
</dl>
</div>
</section>
<section id="emulating-generic-types">
<h3><span class="section-number">3.3.5. </span>제네릭 형 흉내 내기<a class="headerlink" href="#emulating-generic-types" title="제목 주소">¶</a></h3>
<p>When using <a class="reference internal" href="../glossary.html#term-annotation"><span class="xref std std-term">type annotations</span></a>, it is often useful to
<em>parameterize</em> a <a class="reference internal" href="../glossary.html#term-generic-type"><span class="xref std std-term">generic type</span></a> using Python’s square-brackets notation.
For example, the annotation <code class="docutils literal notranslate"><span class="pre">list[int]</span></code> might be used to signify a
<a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> in which all the elements are of type <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-91"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> - Type Hints</dt><dd><p>Introducing Python’s framework for type annotations</p>
</dd>
<dt><a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Types</span></a></dt><dd><p>Documentation for objects representing parameterized generic classes</p>
</dd>
<dt><a class="reference internal" href="../library/typing.html#generics"><span class="std std-ref">제네릭</span></a>, <a class="reference internal" href="../library/typing.html#user-defined-generics"><span class="std std-ref">user-defined generics</span></a> and <a class="reference internal" href="../library/typing.html#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a></dt><dd><p>Documentation on how to implement generic classes that can be
parameterized at runtime and understood by static type-checkers.</p>
</dd>
</dl>
</div>
<p>A class can <em>generally</em> only be parameterized if it defines the special
class method <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>.</p>
<dl class="method">
<dt id="object.__class_getitem__">
<em class="property">classmethod </em><code class="sig-prename descclassname">object.</code><code class="sig-name descname">__class_getitem__</code><span class="sig-paren">(</span><em class="sig-param">cls</em>, <em class="sig-param">key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__class_getitem__" title="정의 주소">¶</a></dt>
<dd><p><em>key</em> 에 있는 형 인자에 의한 제네릭 클래스의 특수화를 나타내는 객체를 돌려줍니다.</p>
<p>When defined on a class, <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> is automatically a class
method. As such, there is no need for it to be decorated with
<a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;classmethod</span></code></a> when it is defined.</p>
</dd></dl>

<section id="the-purpose-of-class-getitem">
<h4><span class="section-number">3.3.5.1. </span>The purpose of <em>__class_getitem__</em><a class="headerlink" href="#the-purpose-of-class-getitem" title="제목 주소">¶</a></h4>
<p>The purpose of <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> is to allow runtime
parameterization of standard-library generic classes in order to more easily
apply <a class="reference internal" href="../glossary.html#term-type-hint"><span class="xref std std-term">type hints</span></a> to these classes.</p>
<p>To implement custom generic classes that can be parameterized at runtime and
understood by static type-checkers, users should either inherit from a standard
library class that already implements <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>, or
inherit from <a class="reference internal" href="../library/typing.html#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a>, which has its own implementation of
<code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>.</p>
<p>Custom implementations of <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> on classes defined
outside of the standard library may not be understood by third-party
type-checkers such as mypy. Using <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> on any class for
purposes other than type hinting is discouraged.</p>
</section>
<section id="class-getitem-versus-getitem">
<span id="classgetitem-versus-getitem"></span><h4><span class="section-number">3.3.5.2. </span><em>__class_getitem__</em> versus <em>__getitem__</em><a class="headerlink" href="#class-getitem-versus-getitem" title="제목 주소">¶</a></h4>
<p>Usually, the <a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscription</span></a> of an object using square
brackets will call the <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> instance method defined on
the object’s class. However, if the object being subscribed is itself a class,
the class method <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> may be called instead.
<code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> should return a <a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias</span></a>
object if it is properly defined.</p>
<p>Presented with the <a class="reference internal" href="../glossary.html#term-expression"><span class="xref std std-term">expression</span></a> <code class="docutils literal notranslate"><span class="pre">obj[x]</span></code>, the Python interpreter
follows something like the following process to decide whether
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> or <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> should be
called:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">isclass</span>

<span class="k">def</span> <span class="nf">subscribe</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the result of the expression `obj[x]`&quot;&quot;&quot;</span>

    <span class="n">class_of_obj</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="c1"># If the class of obj defines __getitem__,</span>
    <span class="c1"># call class_of_obj.__getitem__(obj, x)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">class_of_obj</span><span class="p">,</span> <span class="s1">&#39;__getitem__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">class_of_obj</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Else, if obj is a class and defines __class_getitem__,</span>
    <span class="c1"># call obj.__class_getitem__(x)</span>
    <span class="k">elif</span> <span class="n">isclass</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__class_getitem__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">__class_getitem__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Else, raise an exception</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">class_of_obj</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; object is not subscriptable&quot;</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>In Python, all classes are themselves instances of other classes. The class of
a class is known as that class’s <a class="reference internal" href="../glossary.html#term-metaclass"><span class="xref std std-term">metaclass</span></a>, and most classes have the
<a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> class as their metaclass. <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> does not define
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, meaning that expressions such as <code class="docutils literal notranslate"><span class="pre">list[int]</span></code>,
<code class="docutils literal notranslate"><span class="pre">dict[str,</span> <span class="pre">float]</span></code> and <code class="docutils literal notranslate"><span class="pre">tuple[str,</span> <span class="pre">bytes]</span></code> all result in
<a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> being called:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># list has class &quot;type&quot; as its metaclass, like most classes:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="go">&lt;class &#39;type&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">tuple</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># &quot;list[int]&quot; calls &quot;list.__class_getitem__(int)&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="go">list[int]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># list.__class_getitem__ returns a GenericAlias object:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span>
<span class="go">&lt;class &#39;types.GenericAlias&#39;&gt;</span>
</pre></div>
</div>
<p>However, if a class has a custom metaclass that defines
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, subscribing the class may result in different
behaviour. An example of this can be found in the <a class="reference internal" href="../library/enum.html#module-enum" title="enum: Implementation of an enumeration class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">enum</span></code></a> module:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Menu</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;A breakfast menu&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="n">SPAM</span> <span class="o">=</span> <span class="s1">&#39;spam&#39;</span>
<span class="gp">... </span>    <span class="n">BACON</span> <span class="o">=</span> <span class="s1">&#39;bacon&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Enum classes have a custom metaclass:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Menu</span><span class="p">)</span>
<span class="go">&lt;class &#39;enum.EnumMeta&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># EnumMeta defines __getitem__,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># so __class_getitem__ is not called,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># and the result is not a GenericAlias object:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Menu</span><span class="p">[</span><span class="s1">&#39;SPAM&#39;</span><span class="p">]</span>
<span class="go">&lt;Menu.SPAM: &#39;spam&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Menu</span><span class="p">[</span><span class="s1">&#39;SPAM&#39;</span><span class="p">])</span>
<span class="go">&lt;enum &#39;Menu&#39;&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-92"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0560"><strong>PEP 560</strong></a> - Core Support for typing module and generic types</dt><dd><p>Introducing <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>, and outlining when a
<a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscription</span></a> results in <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>
being called instead of <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a></p>
</dd>
</dl>
</div>
</section>
</section>
<section id="emulating-callable-objects">
<span id="callable-types"></span><h3><span class="section-number">3.3.6. </span>콜러블 객체 흉내 내기<a class="headerlink" href="#emulating-callable-objects" title="제목 주소">¶</a></h3>
<dl class="method">
<dt id="object.__call__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="optional">[</span>, <em class="sig-param">args...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__call__" title="정의 주소">¶</a></dt>
<dd><p id="index-93">인스턴스가 함수처럼 “호출될” 때 호출됩니다; 이 메서드가 정의되면, <code class="docutils literal notranslate"><span class="pre">x(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> 는 대략 <code class="docutils literal notranslate"><span class="pre">type(x).__call__(x,</span> <span class="pre">arg1,</span> <span class="pre">...)</span></code>로 번역됩니다.</p>
</dd></dl>

</section>
<section id="emulating-container-types">
<span id="sequence-types"></span><h3><span class="section-number">3.3.7. </span>컨테이너형 흉내 내기<a class="headerlink" href="#emulating-container-types" title="제목 주소">¶</a></h3>
<p>The following methods can be defined to implement container objects.  Containers
usually are <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequences</span></a> (such as <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">lists</span></code></a> or
<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuples</span></code></a>) or <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mappings</span></a> (like
<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionaries</span></code></a>),
but can represent other containers as well.  The first set of methods is used
either to emulate a sequence or to emulate a mapping; the difference is that for
a sequence, the allowable keys should be the integers <em>k</em> for which <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span>
<span class="pre">N</span></code> where <em>N</em> is the length of the sequence, or <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> objects, which define a
range of items.  It is also recommended that mappings provide the methods
<code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">setdefault()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code>, and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> behaving similar to those for Python’s standard <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a>
objects.  The <a class="reference internal" href="../library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> module provides a
<a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></a>
<a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a> to help create those methods from a base set of
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>, <a class="reference internal" href="#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a>, and <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>.
Mutable sequences should provide methods <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code>, like Python standard <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>
objects. Finally,
sequence types should implement addition (meaning concatenation) and
multiplication (meaning repetition) by defining the methods
<a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>, <a class="reference internal" href="#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code></a>, <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a>,
<a class="reference internal" href="#object.__mul__" title="object.__mul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code></a>, <a class="reference internal" href="#object.__rmul__" title="object.__rmul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmul__()</span></code></a> and <a class="reference internal" href="#object.__imul__" title="object.__imul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__imul__()</span></code></a>
described below; they should not define other numerical
operators.  It is recommended that both mappings and sequences implement the
<a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> method to allow efficient use of the <code class="docutils literal notranslate"><span class="pre">in</span></code>
operator; for
mappings, <code class="docutils literal notranslate"><span class="pre">in</span></code> should search the mapping’s keys; for sequences, it should
search through the values.  It is further recommended that both mappings and
sequences implement the <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method to allow efficient iteration
through the container; for mappings, <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> should iterate
through the object’s keys; for sequences, it should iterate through the values.</p>
<dl class="method">
<dt id="object.__len__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__len__" title="정의 주소">¶</a></dt>
<dd><p id="index-94">내장함수 <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 를 구현하기 위해 호출됩니다. 객체의 길이를 돌려줘야 하는데, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0인 정수입니다. 또한 <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> 메서드를 정의하지 않은 객체의 <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 이 0을 돌려주면 논리 문맥에서 거짓으로 취급됩니다.</p>
<div class="impl-detail compound">
<p><strong>CPython implementation detail:</strong> CPython 에서, 길이는 최대 <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a> 일 것이 요구됩니다. 만약 길이가 <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.maxsize</span></code> 보다 크면, 어떤 기능들 (<a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 과 같은)은 <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> 를 일으킬 수 있습니다. 참 거짓 검사에서 <code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code> 가 일어나는 것을 막기 위해, 객체는 <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> 를 정의해야 합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__length_hint__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__length_hint__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__length_hint__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/operator.html#operator.length_hint" title="operator.length_hint"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.length_hint()</span></code></a> 를 구현하기 위해 호출됩니다. 객체의 추정된 길이를 돌려줘야 합니다(실제 길이보다 크거나 작을 수 있습니다). 길이는 <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0인 정수여야 합니다. 반환 값은 <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-const docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> 일 수도 있으며, <code class="docutils literal notranslate"><span class="pre">__length_hint__</span></code> 메서드가 아예 존재하지 않는 것처럼 처리됩니다. 이 메서드는 순수하게 최적화를 위한 것이고 결코 올바름이 요구되지는 않습니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.4에 추가.</span></p>
</div>
</dd></dl>

<div class="admonition note" id="index-95">
<p class="admonition-title">참고</p>
<p>슬라이싱은 전적으로 다음에 나오는 세 메서드들에의해 수행됩니다</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p>과 같은 호출은</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p>로 번역되고, 다른 형태도 마찬가지입니다. 빠진 슬라이스 항목은 항상 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 채워집니다.</p>
</div>
<dl class="method">
<dt id="object.__getitem__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getitem__" title="정의 주소">¶</a></dt>
<dd><p>Called to implement evaluation of <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. For <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a> types,
the accepted keys should be integers and slice objects.  Note that the
special interpretation of negative indexes (if the class wishes to emulate a
<a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a> type) is up to the <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method. If <em>key</em> is
of an inappropriate type, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> may be raised; if of a value
outside the set of indexes for the sequence (after any special
interpretation of negative values), <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> should be raised. For
<a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a> types, if <em>key</em> is missing (not in the container),
<a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> should be raised.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 루프는 시퀀스의 끝을 올바로 감지하기 위해, 잘못된 인덱스에 대해 <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> 가 일어날 것으로 기대하고 있습니다.</p>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>When <a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscripting</span></a> a <em>class</em>, the special
class method <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> may be called instead of
<code class="docutils literal notranslate"><span class="pre">__getitem__()</span></code>. See <a class="reference internal" href="#classgetitem-versus-getitem"><span class="std std-ref">__class_getitem__ versus __getitem__</span></a> for more
details.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__setitem__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__setitem__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">key</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setitem__" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self[key]</span></code> 로의 대입을 구현하기 위해 호출됩니다. <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 과 같은 주의가 필요합니다. 매핑의 경우에는, 객체가 키에 대해 값의 변경이나 새 키의 추가를 허락할 경우, 시퀀스의 경우는 항목이 교체될 수 있을 때만 구현되어야 합니다. 잘못된 <em>key</em> 값의 경우는 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 에서와 같은 예외를 일으켜야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__delitem__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__delitem__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delitem__" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self[key]</span></code> 의 삭제를 구현하기 위해 호출됩니다. <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 과 같은 주의가 필요합니다. 매핑의 경우에는, 객체가 키의 삭제를 허락할 경우, 시퀀스의 경우는 항목이 시퀀스로부터 제거될 수 있을 때만 구현되어야 합니다. 잘못된 <em>key</em> 값의 경우는 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 에서와 같은 예외를 일으켜야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__missing__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__missing__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">key</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__missing__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 이 dict 서브 클래스에서 키가 딕셔너리에 없으면 <code class="docutils literal notranslate"><span class="pre">self[key]</span></code> 를 구현하기 위해 호출합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__iter__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iter__" title="정의 주소">¶</a></dt>
<dd><p>컨테이너의 이터레이터가 필요할 때 이 메서드가 호출됩니다. 이 메서드는 컨테이너에 포함된 모든 객체를 이터레이트할 수 있는 이터레이터 객체를 돌려줘야 합니다. 매핑의 경우, 컨테이너의 키를 이터레이트해야 합니다.</p>
<p>이터레이터 객체 역시 이 메서드를 구현할 필요가 있습니다; 자기 자신을 돌려줘야 합니다. 이터레이터 객체에 대한 추가의 정보는 <a class="reference internal" href="../library/stdtypes.html#typeiter"><span class="std std-ref">이터레이터 형</span></a> 에 있습니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__reversed__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__reversed__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__reversed__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 내장 함수가 역 이터레이션(reverse iteration)을 구현하기 위해 (있다면) 호출합니다. 컨테이너에 있는 객체들을 역 순으로 탐색하는 새 이터레이터 객체를 돌려줘야 합니다.</p>
<p><a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> 메서드가 제공되지 않으면, <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 내장함수는 시퀀스 프로토콜(<a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> 과 <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>)을 대안으로 사용합니다. 시퀀스 프로토콜을 지원하는 객체들은 <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 가 제공하는 것보다 더 효율적인 구현을 제공할 수 있을 때만 <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> 를 제공해야 합니다.</p>
</dd></dl>

<p>멤버십 검사 연산자들(<a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 과 <a class="reference internal" href="expressions.html#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>) 은 보통 컨테이너에 대한 이터레이션으로 구현됩니다. 하지만, 컨테이너 객체는 더 효율적인 구현을 다음과 같은 특수 메서드를 통해 제공할 수 있습니다. 이 경우 객체는 이터러블일 필요도 없습니다.</p>
<dl class="method">
<dt id="object.__contains__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__contains__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">item</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__contains__" title="정의 주소">¶</a></dt>
<dd><p>멤버십 검사 연산자를 구현하기 위해 호출됩니다. <em>item</em> 이 <em>self</em> 에 있으면 참을, 그렇지 않으면 거짓을 돌려줘야 합니다. 매핑 객체의 경우, 키-값 쌍이 아니라 매핑의 키가 고려되어야 합니다.</p>
<p><a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> 를 정의하지 않는 객체의 경우, 멤버십 검사는 먼저 <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> 를 통한 이터레이션을 시도한 후, <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 을 통한 낡은 시퀀스 이터레이션 프로토콜을 시도합니다. <a class="reference internal" href="expressions.html#membership-test-details"><span class="std std-ref">언어 레퍼런스의 이 절</span></a>을 참고하십시오.</p>
</dd></dl>

</section>
<section id="emulating-numeric-types">
<span id="numeric-types"></span><h3><span class="section-number">3.3.8. </span>숫자 형 흉내 내기<a class="headerlink" href="#emulating-numeric-types" title="제목 주소">¶</a></h3>
<p>숫자 형을 흉내 내기 위해 다음과 같은 메서드들을 정의할 수 있습니다. 구현되는 특별한 종류의 숫자에 의해 지원되지 않는 연산들(예를 들어, 정수가 아닌 숫자들에 대한 비트 연산들)에 대응하는 메서드들을 정의되지 않은 채로 남겨두어야 합니다.</p>
<dl class="method">
<dt id="object.__add__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__add__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__add__" title="정의 주소">¶</a></dt>
<dt id="object.__sub__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__sub__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__sub__" title="정의 주소">¶</a></dt>
<dt id="object.__mul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__mul__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mul__" title="정의 주소">¶</a></dt>
<dt id="object.__matmul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__matmul__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__matmul__" title="정의 주소">¶</a></dt>
<dt id="object.__truediv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__truediv__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__truediv__" title="정의 주소">¶</a></dt>
<dt id="object.__floordiv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__floordiv__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floordiv__" title="정의 주소">¶</a></dt>
<dt id="object.__mod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__mod__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mod__" title="정의 주소">¶</a></dt>
<dt id="object.__divmod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__divmod__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__divmod__" title="정의 주소">¶</a></dt>
<dt id="object.__pow__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__pow__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="optional">[</span>, <em class="sig-param">modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__pow__" title="정의 주소">¶</a></dt>
<dt id="object.__lshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__lshift__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lshift__" title="정의 주소">¶</a></dt>
<dt id="object.__rshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rshift__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rshift__" title="정의 주소">¶</a></dt>
<dt id="object.__and__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__and__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__and__" title="정의 주소">¶</a></dt>
<dt id="object.__xor__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__xor__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__xor__" title="정의 주소">¶</a></dt>
<dt id="object.__or__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__or__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__or__" title="정의 주소">¶</a></dt>
<dd><p id="index-96">이 메서드들은 이항 산술 연산들(<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>)을 구현하기 위해 호출됩니다. 예를 들어, <em>x</em> 가 <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> 메서드를 가진 클래스의 인스턴스일 때, 표현식 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> 의 값을 구하기 위해, <code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> 가 호출됩니다. <a class="reference internal" href="#object.__divmod__" title="object.__divmod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__divmod__()</span></code></a> 메서드는 <a class="reference internal" href="#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a> 와 <a class="reference internal" href="#object.__mod__" title="object.__mod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mod__()</span></code></a> 를 사용하는 것과 동등해야 합니다; <a class="reference internal" href="#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a> 와 연관되지 않아야 합니다; 내장 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> 함수의 삼 항 버전이 지원되기 위해서는, <a class="reference internal" href="#object.__pow__" title="object.__pow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code></a> 메서드가 생략할 수 있는 세 번째 인자를 받도록 정의되어야 함에 주의해야 합니다.</p>
<p>만약 이 메서드들 중 하나가 제공된 인자에 대해 연산을 지원하지 않으면, <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 를 돌려줘야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__radd__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__radd__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__radd__" title="정의 주소">¶</a></dt>
<dt id="object.__rsub__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rsub__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rsub__" title="정의 주소">¶</a></dt>
<dt id="object.__rmul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rmul__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmul__" title="정의 주소">¶</a></dt>
<dt id="object.__rmatmul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rmatmul__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmatmul__" title="정의 주소">¶</a></dt>
<dt id="object.__rtruediv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rtruediv__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rtruediv__" title="정의 주소">¶</a></dt>
<dt id="object.__rfloordiv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rfloordiv__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rfloordiv__" title="정의 주소">¶</a></dt>
<dt id="object.__rmod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rmod__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmod__" title="정의 주소">¶</a></dt>
<dt id="object.__rdivmod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rdivmod__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rdivmod__" title="정의 주소">¶</a></dt>
<dt id="object.__rpow__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rpow__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="optional">[</span>, <em class="sig-param">modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__rpow__" title="정의 주소">¶</a></dt>
<dt id="object.__rlshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rlshift__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rlshift__" title="정의 주소">¶</a></dt>
<dt id="object.__rrshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rrshift__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rrshift__" title="정의 주소">¶</a></dt>
<dt id="object.__rand__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rand__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rand__" title="정의 주소">¶</a></dt>
<dt id="object.__rxor__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rxor__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rxor__" title="정의 주소">¶</a></dt>
<dt id="object.__ror__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ror__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ror__" title="정의 주소">¶</a></dt>
<dd><p id="index-97">이 메서드들은 뒤집힌 피연산자들에 대해 이항 산술 연산들(<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>)을 구현하기 위해 호출됩니다. 이 함수들은 왼쪽의 피연산자가 해당 연산을 지원하지 않고 <a class="footnote-reference brackets" href="#id10" id="id5">3</a>, 피연산자들이 서로 다른 형일 때만 호출됩니다. <a class="footnote-reference brackets" href="#id11" id="id6">4</a> 예를 들어, 표현식 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code> 의 값을 구하려고 할 때, <em>y</em> 가 <a class="reference internal" href="#object.__rsub__" title="object.__rsub__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rsub__()</span></code></a> 를 갖는 클래스의 인스턴스이고, <code class="docutils literal notranslate"><span class="pre">x.__sub__(y)</span></code> 가 <em>NotImplemented</em> 를 돌려주면 <code class="docutils literal notranslate"><span class="pre">y.__rsub__(x)</span></code> 가 호출됩니다.</p>
<p id="index-98">삼 항 <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> 는 <a class="reference internal" href="#object.__rpow__" title="object.__rpow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rpow__()</span></code></a> 를 호출하려고 시도하지 않음에 주의해야 합니다 (그렇게 하려면 코어션 규칙이 너무 복잡해집니다).</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>만약 오른쪽 피연산자의 형이 왼쪽 피연산자의 형의 서브 클래스이고, 그 서브 클래스가 연산의 뒤집힌 메서드의 다른 구현을 제공하면, 이 메서드가 왼쪽 연산자의 뒤집히지 않은 메서드보다 먼저 호출됩니다. 이 동작은 서브 클래스가 조상들의 연산을 재정의할 수 있도록 합니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__iadd__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__iadd__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iadd__" title="정의 주소">¶</a></dt>
<dt id="object.__isub__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__isub__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__isub__" title="정의 주소">¶</a></dt>
<dt id="object.__imul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__imul__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imul__" title="정의 주소">¶</a></dt>
<dt id="object.__imatmul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__imatmul__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imatmul__" title="정의 주소">¶</a></dt>
<dt id="object.__itruediv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__itruediv__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__itruediv__" title="정의 주소">¶</a></dt>
<dt id="object.__ifloordiv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ifloordiv__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ifloordiv__" title="정의 주소">¶</a></dt>
<dt id="object.__imod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__imod__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imod__" title="정의 주소">¶</a></dt>
<dt id="object.__ipow__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ipow__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="optional">[</span>, <em class="sig-param">modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__ipow__" title="정의 주소">¶</a></dt>
<dt id="object.__ilshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ilshift__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ilshift__" title="정의 주소">¶</a></dt>
<dt id="object.__irshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__irshift__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__irshift__" title="정의 주소">¶</a></dt>
<dt id="object.__iand__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__iand__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iand__" title="정의 주소">¶</a></dt>
<dt id="object.__ixor__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ixor__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ixor__" title="정의 주소">¶</a></dt>
<dt id="object.__ior__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ior__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ior__" title="정의 주소">¶</a></dt>
<dd><p>이 메서드들은 증분 산술 대입(<code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">//=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>, <code class="docutils literal notranslate"><span class="pre">**=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>)을 구현하기 위해 호출됩니다. 이 메서드는 연산을 제자리에서(<em>self</em> 를 수정해서) 하도록 시도해야 하고, 결과(반드시 그래야 하는 것은 아니지만 <em>self</em> 일 수 있습니다)를 돌려줘야 합니다. 만약 특정 메서드가 정의되지 않으면, 중분 대입은 일반적인 메서드들을 대신 사용합니다. 예를 들어, <em>x</em> 가 <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a> 메서드를 갖는 클래스의 인스턴스면, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">y</span></code> 는 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x.__iadd__(y)</span></code> 와 동등합니다. 그렇지 않으면, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> 의 값을 구할 때처럼, <code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> 와 <code class="docutils literal notranslate"><span class="pre">y.__radd__(x)</span></code> 가 고려됩니다. 어떤 상황에서, 증분 대입은 예상치 못한 에러로 이어질 수 있습니다. (<a class="reference internal" href="../faq/programming.html#faq-augmented-assignment-tuple-error"><span class="std std-ref">덧셈은 작동하는데, 왜 a_tuple[i] += [‘item’]이 예외를 일으킵니까?</span></a> 를 보십시오). 하지만 이 동작은 사실 데이터 모델의 일부입니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><code class="docutils literal notranslate"><span class="pre">**=</span></code> 디스패치 메커니즘의 버그로 인해, <a class="reference internal" href="#object.__ipow__" title="object.__ipow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ipow__()</span></code></a>를 정의하지만 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>를 반환하는 클래스는 <code class="docutils literal notranslate"><span class="pre">x.__pow__(y)</span></code>와 <code class="docutils literal notranslate"><span class="pre">y.__rpow__(x)</span></code>로 폴백 되지 않습니다. 이 버그는 파이썬 3.10에서 수정되었습니다.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="object.__neg__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__neg__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__neg__" title="정의 주소">¶</a></dt>
<dt id="object.__pos__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__pos__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__pos__" title="정의 주소">¶</a></dt>
<dt id="object.__abs__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__abs__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__abs__" title="정의 주소">¶</a></dt>
<dt id="object.__invert__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__invert__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__invert__" title="정의 주소">¶</a></dt>
<dd><p id="index-99">일 항 산술 연산(<code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">~</span></code>)을 구현하기 위해 호출됩니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__complex__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__complex__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__complex__" title="정의 주소">¶</a></dt>
<dt id="object.__int__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__int__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__int__" title="정의 주소">¶</a></dt>
<dt id="object.__float__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__float__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__float__" title="정의 주소">¶</a></dt>
<dd><p id="index-100">내장 함수 <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a>를 구현하기 위해 호출됩니다. 적절한 형의 값을 돌려줘야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__index__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__index__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__index__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../library/operator.html#operator.index" title="operator.index"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.index()</span></code></a> 를 구현하기 위해 호출되고, 파이썬이 숫자 객체를 정수 객체로 손실 없이 변환해야 할 때(슬라이싱이나 내장 <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a>, <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a>, <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a> 함수들에서와같이)마다 호출됩니다. 이 메서드의 존재는 숫자 객체가 정수 형임을 가리킵니다. 반드시 정수를 돌려줘야 합니다.</p>
<p><a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a>, <a class="reference internal" href="#object.__float__" title="object.__float__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code></a> 및 <a class="reference internal" href="#object.__complex__" title="object.__complex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code></a>가 정의되어 있지 않으면, 해당 내장 함수 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> 및 <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a>는 <a class="reference internal" href="#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>를 사용합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__round__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__round__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="optional">[</span>, <em class="sig-param">ndigits</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__round__" title="정의 주소">¶</a></dt>
<dt id="object.__trunc__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__trunc__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__trunc__" title="정의 주소">¶</a></dt>
<dt id="object.__floor__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__floor__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floor__" title="정의 주소">¶</a></dt>
<dt id="object.__ceil__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ceil__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ceil__" title="정의 주소">¶</a></dt>
<dd><p id="index-101">내장 함수 <a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a>와 <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 함수 <a class="reference internal" href="../library/math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">trunc()</span></code></a>, <a class="reference internal" href="../library/math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a>, <a class="reference internal" href="../library/math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a> 을 구현하기 위해 호출됩니다. <em>ndigits</em> 가 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__round__()</span></code> 로 전달되지 않는 한, 이 메서드들은 모두 <a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a> (보통 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) 로 잘린 객체의 값을 돌려줘야 합니다.</p>
<p>The built-in function <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> falls back to <a class="reference internal" href="#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a> if neither
<a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a> nor <a class="reference internal" href="#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> is defined.</p>
</dd></dl>

</section>
<section id="with-statement-context-managers">
<span id="context-managers"></span><h3><span class="section-number">3.3.9. </span>with 문 컨텍스트 관리자<a class="headerlink" href="#with-statement-context-managers" title="제목 주소">¶</a></h3>
<p><em class="dfn">컨텍스트 관리자 (context manager)</em> 는 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문을 실행할 때 자리 잡는 실행 컨텍스트(context)를 정의하는 객체입니다. 코드 블록의 실행을 위해, 컨텍스트 관리자는 원하는 실행시간 컨텍스트로의 진입과 탈출을 처리합니다. 컨텍스트 관리자는 보통 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> 문(<a class="reference internal" href="compound_stmts.html#with"><span class="std std-ref">with 문</span></a> 섹션에서 설명합니다)으로 시작되지만, 그들의 메서드를 호출해서 직접 사용할 수도 있습니다.</p>
<p id="index-102">컨텍스트 관리자의 전형적인 용도에는 다양한 종류의 전역 상태(global state)를 보관하고 복구하는 것, 자원을 로킹(locking)하고 언로킹(unlocking)하는 것, 열린 파일을 닫는 것 등이 있습니다.</p>
<p>컨텍스트 관리자에 대한 더 자세한 정보는 <a class="reference internal" href="../library/stdtypes.html#typecontextmanager"><span class="std std-ref">컨텍스트 관리자 형</span></a> 에 나옵니다.</p>
<dl class="method">
<dt id="object.__enter__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__enter__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__enter__" title="정의 주소">¶</a></dt>
<dd><p>이 객체와 연관된 실행시간 컨텍스트에 진입합니다. <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문은 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> 절로 지정된 대상이 있다면, 이 메서드의 반환 값을 연결합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__exit__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__exit__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">exc_type</em>, <em class="sig-param">exc_value</em>, <em class="sig-param">traceback</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__exit__" title="정의 주소">¶</a></dt>
<dd><p>이 객체와 연관된 실행시간 컨텍스트를 종료합니다. 매개변수들은 컨텍스트에서 벗어나게 만든 예외를 기술합니다. 만약 컨텍스트가 예외 없이 종료한다면, 세 인자 모두 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 이 됩니다.</p>
<p>만약 예외가 제공되고, 메서드가 예외를 중지시키고 싶으면 (즉 확산하는 것을 막으려면) 참(true)을 돌려줘야 합니다. 그렇지 않으면 예외는 이 메서드가 종료한 후에 계속 진행됩니다.</p>
<p><a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 메서드가 전달된 예외를 다시 일으키지(reraise) 않도록 주의해야 합니다; 이것은 호출자(caller)의 책임입니다.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<dl class="simple">
<dt><span class="target" id="index-122"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a> - “with” 문</dt><dd><p>파이썬 <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 문에 대한 규격, 배경, 예.</p>
</dd>
</dl>
</div>
</section>
<section id="special-method-lookup">
<span id="special-lookup"></span><h3><span class="section-number">3.3.10. </span>특수 메서드 조회<a class="headerlink" href="#special-method-lookup" title="제목 주소">¶</a></h3>
<p>사용자 정의 클래스의 경우, 묵시적인 특수 메서드의 호출은 객체의 인스턴스 딕셔너리가 아닌 객체의 형에 정의되어 있을 때만 올바르게 동작함이 보장됩니다. 이런 동작은 다음과 같은 코드가 예외를 일으키는 원인입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">object of type &#39;C&#39; has no len()</span>
</pre></div>
</div>
<p>The rationale behind this behaviour lies with a number of special methods such
as <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> and <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> that are implemented
by all objects,
including type objects. If the implicit lookup of these methods used the
conventional lookup process, they would fail when invoked on the type object
itself:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">descriptor &#39;__hash__&#39; of &#39;int&#39; object needs an argument</span>
</pre></div>
</div>
<p>클래스의 연결되지 않은 메서드를 호출하려는 이런 식의 잘못된 시도는 종종 ‘메타 클래스 혼란(metaclass confusion)’ 이라고 불리고, 특수 메서드를 조회할 때 인스턴스를 우회하는 방법으로 피할 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In addition to bypassing any instance attributes in the interest of
correctness, implicit special method lookup generally also bypasses the
<a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> method even of the object’s metaclass:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metaclass getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Class getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>                 <span class="c1"># Explicit lookup via instance</span>
<span class="go">Class getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>          <span class="c1"># Explicit lookup via type</span>
<span class="go">Metaclass getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>                      <span class="c1"># Implicit lookup</span>
<span class="go">10</span>
</pre></div>
</div>
<p>Bypassing the <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> machinery in this fashion
provides significant scope for speed optimisations within the
interpreter, at the cost of some flexibility in the handling of
special methods (the special method <em>must</em> be set on the class
object itself in order to be consistently invoked by the interpreter).</p>
</section>
</section>
<section id="coroutines">
<span id="index-104"></span><h2><span class="section-number">3.4. </span>코루틴(Coroutines)<a class="headerlink" href="#coroutines" title="제목 주소">¶</a></h2>
<section id="awaitable-objects">
<h3><span class="section-number">3.4.1. </span>어웨이터블 객체(Awaitable Objects)<a class="headerlink" href="#awaitable-objects" title="제목 주소">¶</a></h3>
<p>An <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> object generally implements an <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> method.
<a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutine objects</span></a> returned from <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> functions
are awaitable.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>The <a class="reference internal" href="../glossary.html#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a> objects returned from generators
decorated with <a class="reference internal" href="../library/types.html#types.coroutine" title="types.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.coroutine()</span></code></a> or <a class="reference internal" href="../library/asyncio-task.html#asyncio.coroutine" title="asyncio.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.coroutine()</span></code></a>
are also awaitable, but they do not implement <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>.</p>
</div>
<dl class="method">
<dt id="object.__await__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__await__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__await__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">이터레이터</span></a> 를 돌려줘야 합니다. <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">어웨이터블</span></a> 객체를 구현하기 위해 사용되어야 합니다. 예를 들어, <a class="reference internal" href="../library/asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> 는 <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> 표현식과 호환되기 위해 이 메서드를 구현합니다.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">더 보기</p>
<p><span class="target" id="index-123"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 가 어웨이터블 객체에 대한 더 자세한 정보를 포함하고 있습니다.</p>
</div>
</section>
<section id="coroutine-objects">
<span id="id7"></span><h3><span class="section-number">3.4.2. </span>코루틴 객체(Coroutine Objects)<a class="headerlink" href="#coroutine-objects" title="제목 주소">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutine objects</span></a> are <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> objects.
A coroutine’s execution can be controlled by calling <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> and
iterating over the result.  When the coroutine has finished executing and
returns, the iterator raises <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, and the exception’s
<code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> attribute holds the return value.  If the
coroutine raises an exception, it is propagated by the iterator.  Coroutines
should not directly raise unhandled <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exceptions.</p>
<p>코루틴은 다음에 나열하는 메서드들 또한 갖고 있는데, 제너레이터(<a class="reference internal" href="expressions.html#generator-methods"><span class="std std-ref">제너레이터-이터레이터 메서드</span></a> 를 보십시오)의 것들과 닮았습니다. 하지만, 제너레이터와는 달리, 코루틴은 이터레이션을 직접 지원하지는 않습니다.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.5.2에서 변경: </span>코루틴을 두 번 await 하면 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 를 일으킵니다.</p>
</div>
<dl class="method">
<dt id="coroutine.send">
<code class="sig-prename descclassname">coroutine.</code><code class="sig-name descname">send</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.send" title="정의 주소">¶</a></dt>
<dd><p>Starts or resumes execution of the coroutine.  If <em>value</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>,
this is equivalent to advancing the iterator returned by
<a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>.  If <em>value</em> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, this method delegates
to the <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> method of the iterator that caused
the coroutine to suspend.  The result (return value,
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, or other exception) is the same as when
iterating over the <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> return value, described above.</p>
</dd></dl>

<dl class="method">
<dt id="coroutine.throw">
<code class="sig-prename descclassname">coroutine.</code><code class="sig-name descname">throw</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.throw" title="정의 주소">¶</a></dt>
<dt>
<code class="sig-prename descclassname">coroutine.</code><code class="sig-name descname">throw</code><span class="sig-paren">(</span><em class="sig-param">type</em><span class="optional">[</span>, <em class="sig-param">value</em><span class="optional">[</span>, <em class="sig-param">traceback</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Raises the specified exception in the coroutine.  This method delegates
to the <a class="reference internal" href="expressions.html#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> method of the iterator that caused
the coroutine to suspend, if it has such a method.  Otherwise,
the exception is raised at the suspension point.  The result
(return value, <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, or other exception) is the same as
when iterating over the <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> return value, described
above.  If the exception is not caught in the coroutine, it propagates
back to the caller.</p>
</dd></dl>

<dl class="method">
<dt id="coroutine.close">
<code class="sig-prename descclassname">coroutine.</code><code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.close" title="정의 주소">¶</a></dt>
<dd><p>코루틴이 자신을 정리하고 종료하도록 만듭니다. 만약 코루틴이 일시 중지 중이면, 이 메서드는 먼저 코루틴이 일시 중지되도록 한 이터레이터의 <a class="reference internal" href="expressions.html#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 메서드로 위임합니다(그런 메서드를 가지는 경우). 그런 다음 일시 중지지점에서 <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> 를 발생시키는데, 코루틴이 즉시 자신을 정리하도록 만듭니다. 마지막으로 코루틴에 실행을 종료했다고 표시하는데, 아직 시작하지조차 않았을 때도 그렇다.</p>
<p>코루틴 객체가 파괴될 때는 위의 프로세스에 따라 자동으로 닫힙니다(closed).</p>
</dd></dl>

</section>
<section id="asynchronous-iterators">
<span id="async-iterators"></span><h3><span class="section-number">3.4.3. </span>비동기 이터레이터(Asynchronous Iterators)<a class="headerlink" href="#asynchronous-iterators" title="제목 주소">¶</a></h3>
<p><em>비동기 이터레이터</em> 는 자신의 <code class="docutils literal notranslate"><span class="pre">__anext__</span></code> 메서드에서 비동기 코드를 호출할 수 있습니다.</p>
<p>비동기 이터레이터는 <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> 문에서 사용될 수 있습니다.</p>
<dl class="method">
<dt id="object.__aiter__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__aiter__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aiter__" title="정의 주소">¶</a></dt>
<dd><p><em>비동기 이터레이터</em> 객체를 돌려줘야 합니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__anext__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__anext__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__anext__" title="정의 주소">¶</a></dt>
<dd><p>이터레이터의 다음 값을 주는 <em>어웨이터블</em> 을 돌려줘야 합니다. 이터레이션이 끝나면 <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> 에러를 일으켜야 합니다.</p>
</dd></dl>

<p>비동기 이터러블 객체의 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Reader</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__anext__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopAsyncIteration</span>
        <span class="k">return</span> <span class="n">val</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>Prior to Python 3.7, <a class="reference internal" href="#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> could return an <em>awaitable</em>
that would resolve to an
<a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a>.</p>
<p>Starting with Python 3.7, <a class="reference internal" href="#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> must return an
asynchronous iterator object.  Returning anything else
will result in a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> error.</p>
</div>
</section>
<section id="asynchronous-context-managers">
<span id="async-context-managers"></span><h3><span class="section-number">3.4.4. </span>비동기 컨텍스트 관리자<a class="headerlink" href="#asynchronous-context-managers" title="제목 주소">¶</a></h3>
<p><em>비동기 컨텍스트 관리자(asynchronous context manager)</em> 는 <code class="docutils literal notranslate"><span class="pre">__aenter__</span></code> 와 <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> 메서드에서 실행을 일시 중지할 수 있는 <em>컨텍스트 관리자</em> 입니다.</p>
<p>비동기 컨텍스트 관리자는 <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> 문에서 사용될 수 있습니다.</p>
<dl class="method">
<dt id="object.__aenter__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__aenter__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aenter__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 메서드와 의미상으로 유사한데, 유일한 차이점은 <em>어웨이터블</em> 을 돌려줘야 한다는 것입니다.</p>
</dd></dl>

<dl class="method">
<dt id="object.__aexit__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__aexit__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">exc_type</em>, <em class="sig-param">exc_value</em>, <em class="sig-param">traceback</em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aexit__" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 메서드와 의미상으로 유사한데, 유일한 차이점은 <em>어웨이터블</em> 을 돌려줘야 한다는 것입니다.</p>
</dd></dl>

<p>비동기 컨텍스트 관리자 클래스의 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;entering context&#39;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;exiting context&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<p class="rubric">각주</p>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>어떤 제한된 조건으로, 어떤 경우에 객체의 형을 변경하는 것이 <em>가능합니다</em>. 하지만 잘못 다뤄지면 아주 괴상한 결과로 이어질 수 있으므로 일반적으로 좋은 생각이 아닙니다.</p>
</dd>
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>The <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>,
<a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a>, and <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> methods have
special handling for this; others
will still raise a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, but may do so by relying on
the behavior that <code class="docutils literal notranslate"><span class="pre">None</span></code> is not callable.</p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id5">3</a></span></dt>
<dd><p>여기서 “지원하지 않는다” 는 클래스가 그런 메서드를 갖지 않거나, 메서드가 <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> 를 돌려줌을 뜻합니다. 오른쪽 피연산자의 뒤집힌 메서드를 사용하는 대안이 시도되도록 하려면 메서드를 <code class="docutils literal notranslate"><span class="pre">None</span></code> 으로 설정하지 말아야 합니다 - 그렇게 하는 것은 그런 대안을 명시적으로 <em>금지하는</em> 반대 효과를 줍니다.</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id6">4</a></span></dt>
<dd><p>For operands of the same type, it is assumed that if the non-reflected
method – such as <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> – fails then the overall
operation is not
supported, which is why the reflected method is not called.</p>
</dd>
</dl>
</section>
</section>
</section>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. 데이터 모델</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. 객체, 값, 형</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. 표준형 계층</a></li>
<li><a class="reference internal" href="#special-method-names">3.3. 특수 메서드 이름들</a><ul>
<li><a class="reference internal" href="#basic-customization">3.3.1. 기본적인 커스터마이제이션</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.3.2. 어트리뷰트 액세스 커스터마이제이션</a><ul>
<li><a class="reference internal" href="#customizing-module-attribute-access">3.3.2.1. 모듈 어트리뷰트 액세스 커스터마이제이션</a></li>
<li><a class="reference internal" href="#implementing-descriptors">3.3.2.2. 디스크립터 구현하기</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.3.2.3. 디스크립터 호출하기</a></li>
<li><a class="reference internal" href="#slots">3.3.2.4. __slots__</a><ul>
<li><a class="reference internal" href="#notes-on-using-slots">3.3.2.4.1. <em>__slots__</em> 사용에 관한 노트</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.3.3. 클래스 생성 커스터마이제이션</a><ul>
<li><a class="reference internal" href="#metaclasses">3.3.3.1. 메타 클래스</a></li>
<li><a class="reference internal" href="#resolving-mro-entries">3.3.3.2. MRO 항목 결정하기</a></li>
<li><a class="reference internal" href="#determining-the-appropriate-metaclass">3.3.3.3. 적절한 메타 클래스 선택하기</a></li>
<li><a class="reference internal" href="#preparing-the-class-namespace">3.3.3.4. 클래스 이름 공간 준비하기</a></li>
<li><a class="reference internal" href="#executing-the-class-body">3.3.3.5. 클래스 바디 실행하기</a></li>
<li><a class="reference internal" href="#creating-the-class-object">3.3.3.6. 클래스 객체 만들기</a></li>
<li><a class="reference internal" href="#uses-for-metaclasses">3.3.3.7. 메타 클래스의 용도</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.3.4. 인스턴스 및 서브 클래스 검사 커스터마이제이션</a></li>
<li><a class="reference internal" href="#emulating-generic-types">3.3.5. 제네릭 형 흉내 내기</a><ul>
<li><a class="reference internal" href="#the-purpose-of-class-getitem">3.3.5.1. The purpose of <em>__class_getitem__</em></a></li>
<li><a class="reference internal" href="#class-getitem-versus-getitem">3.3.5.2. <em>__class_getitem__</em> versus <em>__getitem__</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#emulating-callable-objects">3.3.6. 콜러블 객체 흉내 내기</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.3.7. 컨테이너형 흉내 내기</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.3.8. 숫자 형 흉내 내기</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.3.9. with 문 컨텍스트 관리자</a></li>
<li><a class="reference internal" href="#special-method-lookup">3.3.10. 특수 메서드 조회</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coroutines">3.4. 코루틴(Coroutines)</a><ul>
<li><a class="reference internal" href="#awaitable-objects">3.4.1. 어웨이터블 객체(Awaitable Objects)</a></li>
<li><a class="reference internal" href="#coroutine-objects">3.4.2. 코루틴 객체(Coroutine Objects)</a></li>
<li><a class="reference internal" href="#asynchronous-iterators">3.4.3. 비동기 이터레이터(Asynchronous Iterators)</a></li>
<li><a class="reference internal" href="#asynchronous-context-managers">3.4.4. 비동기 컨텍스트 관리자</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="lexical_analysis.html"
                        title="이전 장"><span class="section-number">2. </span>어휘 분석</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="executionmodel.html"
                        title="다음 장"><span class="section-number">4. </span>실행 모델</a></p>
  <div role="note" aria-label="source link">
    <h3>현재 문서</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.9/Doc/reference/datamodel.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. 실행 모델"
             >다음</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. 어휘 분석"
             >이전</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.9.14 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 언어 레퍼런스</a> &#187;</li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    최종 업데이트: 9월 11, 2022
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>

  </body>
</html>