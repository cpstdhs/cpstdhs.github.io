
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>typing — 형 힌트 지원 &#8212; Python 3.9.14 문서</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.9.14 문서에서 찾기"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="이 문서 정보" href="../about.html" />
    <link rel="index" title="색인" href="../genindex.html" />
    <link rel="search" title="검색" href="../search.html" />
    <link rel="copyright" title="저작권" href="../copyright.html" />
    <link rel="next" title="pydoc — 설명서 생성과 온라인 도움말 시스템" href="pydoc.html" />
    <link rel="prev" title="개발 도구" href="development.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/typing.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="빠른 검색"/>
            <input type="submit" value="이동"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> — 형 힌트 지원</a><ul>
<li><a class="reference internal" href="#relevant-peps">Relevant PEPs</a></li>
<li><a class="reference internal" href="#type-aliases">형 에일리어스</a></li>
<li><a class="reference internal" href="#newtype">NewType</a></li>
<li><a class="reference internal" href="#callable">Callable</a></li>
<li><a class="reference internal" href="#generics">제네릭</a></li>
<li><a class="reference internal" href="#user-defined-generic-types">사용자 정의 제네릭 형</a></li>
<li><a class="reference internal" href="#the-any-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code> 형</a></li>
<li><a class="reference internal" href="#nominal-vs-structural-subtyping">명목적 대 구조적 서브 타이핑</a></li>
<li><a class="reference internal" href="#module-contents">모듈 내용</a><ul>
<li><a class="reference internal" href="#special-typing-primitives">특수 타이핑 프리미티브</a><ul>
<li><a class="reference internal" href="#special-types">특수형</a></li>
<li><a class="reference internal" href="#special-forms">특수 형태</a></li>
<li><a class="reference internal" href="#building-generic-types">제네릭 형 구축하기</a></li>
<li><a class="reference internal" href="#other-special-directives">기타 특수 지시자</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic-concrete-collections">제네릭 구상 컬렉션</a><ul>
<li><a class="reference internal" href="#corresponding-to-built-in-types">내장형에 해당하는 것들</a></li>
<li><a class="reference internal" href="#corresponding-to-types-in-collections"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code>의 형에 해당하는 것들</a></li>
<li><a class="reference internal" href="#other-concrete-types">기타 구상형</a></li>
</ul>
</li>
<li><a class="reference internal" href="#abstract-base-classes">추상 베이스 클래스</a><ul>
<li><a class="reference internal" href="#corresponding-to-collections-in-collections-abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code>의 컬렉션에 해당하는 것들</a></li>
<li><a class="reference internal" href="#corresponding-to-other-types-in-collections-abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code>의 기타 형에 해당하는 것들</a></li>
<li><a class="reference internal" href="#asynchronous-programming">비동기 프로그래밍</a></li>
<li><a class="reference internal" href="#context-manager-types">컨텍스트 관리자 형</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocols">프로토콜</a></li>
<li><a class="reference internal" href="#functions-and-decorators">함수와 데코레이터</a></li>
<li><a class="reference internal" href="#introspection-helpers">인트로스펙션 도우미</a></li>
<li><a class="reference internal" href="#constant">상수</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="development.html"
                        title="이전 장">개발 도구</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="pydoc.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code> — 설명서 생성과 온라인 도움말 시스템</a></p>
  <div role="note" aria-label="source link">
    <h3>현재 문서</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.9/Doc/library/typing.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc — 설명서 생성과 온라인 도움말 시스템"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="development.html" title="개발 도구"
             accesskey="P">이전</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.9.14 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">개발 도구</a> &#187;</li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-typing">
<span id="typing-support-for-type-hints"></span><h1><a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> — 형 힌트 지원<a class="headerlink" href="#module-typing" title="제목 주소">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5에 추가.</span></p>
</div>
<p><strong>소스 코드:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/typing.py">Lib/typing.py</a></p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>파이썬 런타임은 함수와 변수 형 어노테이션을 강제하지 않습니다. 형 어노테이션은 형 검사기, IDE, 린터(linter) 등과 같은 제삼자 도구에서 사용할 수 있습니다.</p>
</div>
<hr class="docutils" />
<p>This module provides runtime support for type hints. The most fundamental
support consists of the types <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, <a class="reference internal" href="#typing.Union" title="typing.Union"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code></a>, <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a>,
<a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>, and <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>. For a full specification, please see
<span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>. For a simplified introduction to type hints, see <span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0483"><strong>PEP 483</strong></a>.</p>
<p>아래의 함수는 문자열을 취하고 반환하며 다음과 같이 어노테이트 되었습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">greeting</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s1">&#39;Hello &#39;</span> <span class="o">+</span> <span class="n">name</span>
</pre></div>
</div>
<p>함수 <code class="docutils literal notranslate"><span class="pre">greeting</span></code>에서, 인자 <code class="docutils literal notranslate"><span class="pre">name</span></code>은 형 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>로, 반환형은 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>로 기대됩니다. 서브 형은 인자로 허용됩니다.</p>
<p>New features are frequently added to the <code class="docutils literal notranslate"><span class="pre">typing</span></code> module.
The <a class="reference external" href="https://pypi.org/project/typing-extensions/">typing_extensions</a> package
provides backports of these new features to older versions of Python.</p>
<section id="relevant-peps">
<span id="id1"></span><h2>Relevant PEPs<a class="headerlink" href="#relevant-peps" title="제목 주소">¶</a></h2>
<p>Since the initial introduction of type hints in <span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> and <span class="target" id="index-3"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0483"><strong>PEP 483</strong></a>, a
number of PEPs have modified and enhanced Python’s framework for type
annotations. These include:</p>
<ul class="simple">
<li><dl class="simple">
<dt><span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>: Syntax for Variable Annotations</dt><dd><p><em>Introducing</em> syntax for annotating variables outside of function
definitions, and <a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-5"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0544"><strong>PEP 544</strong></a>: Protocols: Structural subtyping (static duck typing)</dt><dd><p><em>Introducing</em> <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> and the
<a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;runtime_checkable</span></code></a> decorator</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>: Type Hinting Generics In Standard Collections</dt><dd><p><em>Introducing</em> <a class="reference internal" href="types.html#types.GenericAlias" title="types.GenericAlias"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.GenericAlias</span></code></a> and the ability to use standard
library classes as <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">generic types</span></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-7"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0586"><strong>PEP 586</strong></a>: Literal Types</dt><dd><p><em>Introducing</em> <a class="reference internal" href="#typing.Literal" title="typing.Literal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Literal</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0589"><strong>PEP 589</strong></a>: TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys</dt><dd><p><em>Introducing</em> <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-9"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0591"><strong>PEP 591</strong></a>: Adding a final qualifier to typing</dt><dd><p><em>Introducing</em> <a class="reference internal" href="#typing.Final" title="typing.Final"><code class="xref py py-data docutils literal notranslate"><span class="pre">Final</span></code></a> and the <a class="reference internal" href="#typing.final" title="typing.final"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;final</span></code></a> decorator</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0593"><strong>PEP 593</strong></a>: Flexible function and variable annotations</dt><dd><p><em>Introducing</em> <a class="reference internal" href="#typing.Annotated" title="typing.Annotated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Annotated</span></code></a></p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="type-aliases">
<h2>형 에일리어스<a class="headerlink" href="#type-aliases" title="제목 주소">¶</a></h2>
<p>형 에일리어스는 별칭에 형을 대입하여 정의됩니다. 이 예에서, <code class="docutils literal notranslate"><span class="pre">Vector</span></code>와 <code class="docutils literal notranslate"><span class="pre">list[float]</span></code>는 교환 가능한 동의어로 취급됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">scalar</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">scalar</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">]</span>

<span class="c1"># typechecks; a list of floats qualifies as a Vector.</span>
<span class="n">new_vector</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.2</span><span class="p">,</span> <span class="mf">5.4</span><span class="p">])</span>
</pre></div>
</div>
<p>형 에일리어스는 복잡한 형 서명을 단순화하는 데 유용합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>

<span class="n">ConnectionOptions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">Address</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="n">Server</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Address</span><span class="p">,</span> <span class="n">ConnectionOptions</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Server</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># The static type checker will treat the previous type signature as</span>
<span class="c1"># being exactly equivalent to this one.</span>
<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span>
        <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>형 힌트로서의 <code class="docutils literal notranslate"><span class="pre">None</span></code>은 특별한 경우이며 <code class="docutils literal notranslate"><span class="pre">type(None)</span></code>으로 치환됨에 유의하십시오.</p>
</section>
<section id="newtype">
<span id="distinct"></span><h2>NewType<a class="headerlink" href="#newtype" title="제목 주소">¶</a></h2>
<p>Use the <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-func docutils literal notranslate"><span class="pre">NewType()</span></code></a> helper to create distinct types:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">some_id</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">524313</span><span class="p">)</span>
</pre></div>
</div>
<p>정적 형 검사기는 새 형을 원래 형의 서브 클래스인 것처럼 다룹니다. 논리 에러를 잡는 데 유용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_user_name</span><span class="p">(</span><span class="n">user_id</span><span class="p">:</span> <span class="n">UserId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># typechecks</span>
<span class="n">user_a</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="n">UserId</span><span class="p">(</span><span class="mi">42351</span><span class="p">))</span>

<span class="c1"># does not typecheck; an int is not a UserId</span>
<span class="n">user_b</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">UserId</span></code> 형의 변수에 대해 모든 <code class="docutils literal notranslate"><span class="pre">int</span></code> 연산을 여전히 수행할 수 있지만, 결과는 항상 <code class="docutils literal notranslate"><span class="pre">int</span></code> 형이 됩니다. 이것은 <code class="docutils literal notranslate"><span class="pre">int</span></code>가 기대되는 모든 곳에 <code class="docutils literal notranslate"><span class="pre">UserId</span></code>를 전달할 수 있지만, 잘못된 방식으로 의도하지 않게 <code class="docutils literal notranslate"><span class="pre">UserId</span></code>를 만들지 않도록 합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># &#39;output&#39; is of type &#39;int&#39;, not &#39;UserId&#39;</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">23413</span><span class="p">)</span> <span class="o">+</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">54341</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that these checks are enforced only by the static type checker. At runtime,
the statement <code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Base)</span></code> will make <code class="docutils literal notranslate"><span class="pre">Derived</span></code> a
callable that immediately returns whatever parameter you pass it. That means
the expression <code class="docutils literal notranslate"><span class="pre">Derived(some_value)</span></code> does not create a new class or introduce
any overhead beyond that of a regular function call.</p>
<p>더욱 정확하게, 표현식 <code class="docutils literal notranslate"><span class="pre">some_value</span> <span class="pre">is</span> <span class="pre">Derived(some_value)</span></code>는 실행 시간에 항상 참입니다.</p>
<p>이것은 또한 <code class="docutils literal notranslate"><span class="pre">Derived</span></code>의 서브 형을 만들 수 없다는 것을 의미하는데, 실행 시간에 항등함수(identity function)일 뿐 실제 형이 아니기 때문입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="c1"># Fails at runtime and does not typecheck</span>
<span class="k">class</span> <span class="nc">AdminUserId</span><span class="p">(</span><span class="n">UserId</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
</div>
<p>그러나, ‘파생된’ <code class="docutils literal notranslate"><span class="pre">NewType</span></code>을 기반으로 <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-func docutils literal notranslate"><span class="pre">NewType()</span></code></a>을 만들 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="n">ProUserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;ProUserId&#39;</span><span class="p">,</span> <span class="n">UserId</span><span class="p">)</span>
</pre></div>
</div>
<p>그리고 <code class="docutils literal notranslate"><span class="pre">ProUserId</span></code>에 대한 형 검사는 예상대로 작동합니다.</p>
<p>자세한 내용은 <span class="target" id="index-119"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>를 참조하십시오.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>형 에일리어스를 사용하면 두 형이 서로 <em>동등한</em> 것으로 선언됨을 상기하십시오. <code class="docutils literal notranslate"><span class="pre">Alias</span> <span class="pre">=</span> <span class="pre">Original</span></code>은 모든 경우 정적 형 검사기가 <code class="docutils literal notranslate"><span class="pre">Alias</span></code>를 <code class="docutils literal notranslate"><span class="pre">Original</span></code>과 <em>정확히 동등한</em> 것으로 취급하게 합니다. 이것은 복잡한 형 서명을 단순화하려는 경우에 유용합니다.</p>
<p>반면에, <code class="docutils literal notranslate"><span class="pre">NewType</span></code>은 한 형을 다른 형의 <em>서브 형</em>으로 선언합니다. <code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Original)</span></code>은 정적 형 검사기가 <code class="docutils literal notranslate"><span class="pre">Derived</span></code>를 <code class="docutils literal notranslate"><span class="pre">Original</span></code>의 <em>서브 클래스</em>로 취급하게 합니다. 이는 <code class="docutils literal notranslate"><span class="pre">Original</span></code> 형의 값이 <code class="docutils literal notranslate"><span class="pre">Derived</span></code> 형의 값이 예상되는 위치에서 사용될 수 없음을 의미합니다. 실행 시간 비용을 최소화하면서 논리 에러를 방지하려는 경우에 유용합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</section>
<section id="callable">
<h2>Callable<a class="headerlink" href="#callable" title="제목 주소">¶</a></h2>
<p>특정 서명의 콜백 함수를 기대하는 프레임워크는 <code class="docutils literal notranslate"><span class="pre">Callable[[Arg1Type,</span> <span class="pre">Arg2Type],</span> <span class="pre">ReturnType]</span></code>을 사용하여 형 힌트를 제공할 수 있습니다.</p>
<p>예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>

<span class="k">def</span> <span class="nf">feeder</span><span class="p">(</span><span class="n">get_next_item</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Body</span>

<span class="k">def</span> <span class="nf">async_query</span><span class="p">(</span><span class="n">on_success</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">on_error</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Body</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">on_update</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Body</span>
<span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Awaitable</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="n">on_update</span>
</pre></div>
</div>
<p>형 힌트에서 인자 리스트를 리터럴 줄임표(ellipsis)로 대체하여 호출 서명을 지정하지 않고 콜러블의 반환 값을 선언할 수 있습니다: <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">ReturnType]</span></code>.</p>
</section>
<section id="generics">
<span id="id2"></span><h2>제네릭<a class="headerlink" href="#generics" title="제목 주소">¶</a></h2>
<p>컨테이너에 보관된 객체에 대한 형 정보는 일반적인 방식으로 정적으로 유추될 수 없기 때문에, 컨테이너 요소에 대해 기대되는 형을 나타내는 서명을 지원하도록 추상 베이스 클래스가 확장되었습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="k">def</span> <span class="nf">notify_by_email</span><span class="p">(</span><span class="n">employees</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Employee</span><span class="p">],</span>
                    <span class="n">overrides</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>Generics can be parameterized by using a factory available in typing
called <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>      <span class="c1"># Declare type variable</span>

<span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>   <span class="c1"># Generic function</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="user-defined-generic-types">
<span id="user-defined-generics"></span><h2>사용자 정의 제네릭 형<a class="headerlink" href="#user-defined-generic-types" title="제목 주소">¶</a></h2>
<p>사용자 정의 클래스는 제네릭 클래스로 정의 할 수 있습니다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">Logger</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LoggedVar</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Set &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Get &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p>베이스 클래스로서의 <code class="docutils literal notranslate"><span class="pre">Generic[T]</span></code>는 클래스 <code class="docutils literal notranslate"><span class="pre">LoggedVar</span></code>가 단일한 형 매개 변수 <code class="docutils literal notranslate"><span class="pre">T</span></code>를 취한다는 것을 정의합니다. 이는 또한 <code class="docutils literal notranslate"><span class="pre">T</span></code>를 클래스 바디 내에서 형으로 유효하게 만듭니다.</p>
<p>The <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> base class defines <a class="reference internal" href="../reference/datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> so
that <code class="docutils literal notranslate"><span class="pre">LoggedVar[t]</span></code> is valid as a type:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="k">def</span> <span class="nf">zero_all_vars</span><span class="p">(</span><span class="nb">vars</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">LoggedVar</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">var</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>A generic type can have any number of type variables. All varieties of
<a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> are permissible as parameters for a generic type:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">contravariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">WeirdTrio</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">S</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>에 대한 각 형 변수 인자는 달라야 합니다. 그래서 이것은 잘못되었습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Pair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>   <span class="c1"># INVALID</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>으로 다중 상속을 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sized</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>제네릭 클래스에서 상속할 때, 일부 형 변수를 고정할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MyDict</span><span class="p">(</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>이 경우 <code class="docutils literal notranslate"><span class="pre">MyDict</span></code>는 단일 매개 변수 <code class="docutils literal notranslate"><span class="pre">T</span></code>를 갖습니다.</p>
<p>형 매개 변수를 지정하지 않고 제네릭 클래스를 사용하는 것은 각 위치에 대해 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>를 가정합니다. 다음 예제에서, <code class="docutils literal notranslate"><span class="pre">MyIterable</span></code>은 제네릭이 아니지만 <code class="docutils literal notranslate"><span class="pre">Iterable[Any]</span></code>를 묵시적으로 상속합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">MyIterable</span><span class="p">(</span><span class="n">Iterable</span><span class="p">):</span> <span class="c1"># Same as Iterable[Any]</span>
</pre></div>
</div>
<p>사용자 정의 제네릭 형 에일리어스도 지원됩니다. 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Union</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
<span class="n">Response</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">S</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span>

<span class="c1"># Return type here is same as Union[Iterable[str], int]</span>
<span class="k">def</span> <span class="nf">response</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span>
<span class="n">Vec</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]]</span>

<span class="k">def</span> <span class="nf">inproduct</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="c1"># Same as Iterable[tuple[T, T]]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>에는 더는 사용자 정의 메타 클래스가 없습니다.</p>
</div>
<p>사용자 정의 제네릭 클래스는 메타 클래스 충돌 없이 베이스 클래스로 ABC를 가질 수 있습니다. 제네릭 메타 클래스는 지원되지 않습니다. 제네릭을 매개 변수화한 결과가 캐시 되며, typing 모듈의 대부분 형이 해시 가능하고 동등성을 비교할 수 있습니다.</p>
</section>
<section id="the-any-type">
<h2><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 형<a class="headerlink" href="#the-any-type" title="제목 주소">¶</a></h2>
<p>특수한 종류의 형은 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>입니다. 정적 형 검사기는 모든 형을 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>와 호환되는 것으로, <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>를 모든 형과 호환되는 것으로 취급합니다.</p>
<p>이것은 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 형의 값에 대해 어떤 연산이나 메서드 호출을 수행하고, 그것을 임의의 변수에 대입할 수 있다는 것을 의미합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>          <span class="c1"># OK</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>           <span class="c1"># OK</span>

<span class="n">s</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">a</span>           <span class="c1"># OK</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Typechecks; &#39;item&#39; could be any type,</span>
    <span class="c1"># and that type might have a &#39;bar&#39; method</span>
    <span class="n">item</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 형의 값을 보다 구체적인 형에 대입할 때 형 검사가 수행되지 않음에 유의하십시오. 예를 들어, 정적 형 검사기는 <code class="docutils literal notranslate"><span class="pre">s</span></code>가 형 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>로 선언되고 실행 시간에 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 값을 수신하더라도 <code class="docutils literal notranslate"><span class="pre">a</span></code>를 <code class="docutils literal notranslate"><span class="pre">s</span></code>에 대입할 때 에러를 보고하지 않았습니다!</p>
<p>또한, 반환형이나 매개 변수 형이 없는 모든 함수는 묵시적으로 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> 기본값을 사용합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="c1"># A static type checker will treat the above</span>
<span class="c1"># as having the same signature as:</span>
<span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<p>이 동작은 여러분이 동적으로 형이 지정되는 코드와 정적으로 형이 지정되는 코드를 혼합해야 할 때 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>를 <em>탈출구</em>로 사용할 수 있도록 합니다.</p>
<p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>의 동작과 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>의 동작을 대조하십시오. <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>와 유사하게, 모든 형은 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>의 서브 형입니다. 그러나, <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>와는 달리, 그 반대는 사실이 아닙니다: <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>는 다른 모든 형의 서브 형이 <em>아닙</em>니다.</p>
<p>이것은 값의 형이 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>일 때, 형 검사기가 그것에 대한 거의 모든 연산을 거부하고, 그것을 더 특수한 형의 변수에 대입(또는 그것을 반환 값으로 사용)하는 것이 형 에러임을 의미합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hash_a</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Fails; an object does not have a &#39;magic&#39; method.</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">hash_b</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Typechecks</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="c1"># Typechecks, since ints and strs are subclasses of object</span>
<span class="n">hash_a</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_a</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="c1"># Typechecks, since Any is compatible with all types</span>
<span class="n">hash_b</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_b</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>값이 형 안전한 방식으로 모든 형이 될 수 있음을 표시하려면 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>를 사용하십시오. 값이 동적으로 형이 지정됨을 표시하려면 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>를 사용하십시오.</p>
</section>
<section id="nominal-vs-structural-subtyping">
<h2>명목적 대 구조적 서브 타이핑<a class="headerlink" href="#nominal-vs-structural-subtyping" title="제목 주소">¶</a></h2>
<p>Initially <span class="target" id="index-12"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> defined the Python static type system as using
<em>nominal subtyping</em>. This means that a class <code class="docutils literal notranslate"><span class="pre">A</span></code> is allowed where
a class <code class="docutils literal notranslate"><span class="pre">B</span></code> is expected if and only if <code class="docutils literal notranslate"><span class="pre">A</span></code> is a subclass of <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
<p>이 요구 사항은 이전에 <a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>과 같은 추상 베이스 클래스에도 적용되었습니다. 이 접근 방식의 문제점은 이것을 지원하려면 클래스를 명시적으로 표시해야만 한다는 점입니다. 이는 파이썬답지 않고 관용적인 동적으로 형이 지정된 파이썬 코드에서 일반적으로 수행하는 것과는 다릅니다. 예를 들어, 이것은 <span class="target" id="index-120"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>를 만족합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="k">class</span> <span class="nc">Bucket</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p><span class="target" id="index-121"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0544"><strong>PEP 544</strong></a>는 사용자가 클래스 정의에서 명시적인 베이스 클래스 없이 위의 코드를 작성할 수 있게 함으로써 이 문제를 풀도록 합니다. 정적 형 검사기가 <code class="docutils literal notranslate"><span class="pre">Bucket</span></code>을 <code class="docutils literal notranslate"><span class="pre">Sized</span></code>와 <code class="docutils literal notranslate"><span class="pre">Iterable[int]</span></code>의 서브 형으로 묵시적으로 취급하도록 합니다. 이것은 <em>구조적 서브 타이핑(structural subtyping)</em>(또는 정적 덕 타이핑)으로 알려져 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">Bucket</span><span class="p">:</span>  <span class="c1"># Note: no base classes</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">Bucket</span><span class="p">())</span>  <span class="c1"># Passes type check</span>
</pre></div>
</div>
<p>또한, 특별한 클래스 <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>을 서브 클래싱 함으로써, 사용자는 새로운 사용자 정의 프로토콜을 정의하여 구조적 서브 타이핑을 완전히 누릴 수 있습니다 (아래 예를 참조하십시오).</p>
</section>
<section id="module-contents">
<h2>모듈 내용<a class="headerlink" href="#module-contents" title="제목 주소">¶</a></h2>
<p>모듈은 다음 클래스, 함수 및 데코레이터를 정의합니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>이 모듈은 <code class="docutils literal notranslate"><span class="pre">[]</span></code> 내부의 형 변수를 지원하도록 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>를 확장하기도 하는 기존 표준 라이브러리 클래스의 서브 클래스인 여러 형을 정의합니다. 이러한 형은 해당하는 기존 클래스가 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원하도록 개선되었을 때 파이썬 3.9에서 중복되었습니다.</p>
<p>중복된 형은 파이썬 3.9부터 폐지되었지만, 인터프리터에서 폐지 경고가 발생하지 않습니다. 검사되는 프로그램이 파이썬 3.9 이상을 대상으로 할 때 형 검사기가 폐지된 형을 표시할 것으로 예상됩니다.</p>
<p>폐지된 형은 파이썬 3.9.0 릴리스 5년 후에 릴리스 되는 첫 번째 파이썬 버전의 <a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 모듈에서 제거됩니다. 자세한 내용은 <span class="target" id="index-122"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>-<em>표준 컬렉션의 형 힌트 제네릭</em>을 참조하십시오.</p>
</div>
<section id="special-typing-primitives">
<h3>특수 타이핑 프리미티브<a class="headerlink" href="#special-typing-primitives" title="제목 주소">¶</a></h3>
<section id="special-types">
<h4>특수형<a class="headerlink" href="#special-types" title="제목 주소">¶</a></h4>
<p>이들은 어노테이션에서 형으로 사용할 수 있으며 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원하지 않습니다.</p>
<dl class="data">
<dt id="typing.Any">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Any</code><a class="headerlink" href="#typing.Any" title="정의 주소">¶</a></dt>
<dd><p>제한되지 않는 형을 나타내는 특수형.</p>
<ul class="simple">
<li><p>모든 형은 <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>와 호환됩니다.</p></li>
<li><p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>는 모든 형과 호환됩니다.</p></li>
</ul>
</dd></dl>

<dl class="data">
<dt id="typing.NoReturn">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">NoReturn</code><a class="headerlink" href="#typing.NoReturn" title="정의 주소">¶</a></dt>
<dd><p>함수가 절대 반환하지 않는 것을 나타내는 특수한 형. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NoReturn</span>

<span class="k">def</span> <span class="nf">stop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;no way&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.2에 추가.</span></p>
</div>
</dd></dl>

</section>
<section id="special-forms">
<h4>특수 형태<a class="headerlink" href="#special-forms" title="제목 주소">¶</a></h4>
<p>이들은 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 사용하여 어노테이션에서 형으로 사용할 수 있는데, 각기 고유한 문법을 가집니다.</p>
<dl class="data">
<dt id="typing.Tuple">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Tuple</code><a class="headerlink" href="#typing.Tuple" title="정의 주소">¶</a></dt>
<dd><p>튜플 형; <code class="docutils literal notranslate"><span class="pre">Tuple[X,</span> <span class="pre">Y]</span></code>는 첫 번째 항목의 형이 X이고 두 번째 항목의 형이 Y인 두 항목의 튜플 형입니다. 빈 튜플의 형은 <code class="docutils literal notranslate"><span class="pre">Tuple[()]</span></code>로 쓸 수 있습니다.</p>
<p>예: <code class="docutils literal notranslate"><span class="pre">Tuple[T1,</span> <span class="pre">T2]</span></code>는 각각 형 변수 T1과 T2에 해당하는 두 요소의 튜플입니다. <code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span class="pre">float,</span> <span class="pre">str]</span></code>은 int, float 및 문자열의 튜플입니다.</p>
<p>같은 형의 가변 길이 튜플을 지정하려면 리터럴 생략 부호(ellipsis)를 사용하십시오, 예를 들어 <code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span class="pre">...]</span></code>. 단순한 <a class="reference internal" href="#typing.Tuple" title="typing.Tuple"><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code></a>은 <code class="docutils literal notranslate"><span class="pre">Tuple[Any,</span> <span class="pre">...]</span></code>와 동등하고, 이는 다시 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>과 동등합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.tuple</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-123"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Union">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Union</code><a class="headerlink" href="#typing.Union" title="정의 주소">¶</a></dt>
<dd><p>공용체 형; <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">Y]</span></code>는 X나 Y를 의미합니다.</p>
<p>공용체를 정의하려면, 예를 들어 <code class="docutils literal notranslate"><span class="pre">Union[int,</span> <span class="pre">str]</span></code>을 사용하십시오. 세부 사항:</p>
<ul>
<li><p>인자는 형이어야 하며 적어도 하나 있어야 합니다.</p></li>
<li><p>공용체의 공용체는 펼쳐집니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>단일 인자의 공용체는 사라집니다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span>  <span class="c1"># The constructor actually returns int</span>
</pre></div>
</div>
</li>
<li><p>중복 인자는 건너뜁니다. 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>공용체를 비교할 때, 인자 순서가 무시됩니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>공용체를 서브 클래스 화하거나 인스턴스 화할 수 없습니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Union[X][Y]</span></code>라고 쓸 수 없습니다.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Optional[X]</span></code>를 <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">None]</span></code>의 줄임 표현으로 사용할 수 있습니다.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.7에서 변경: </span>실행 시간에 공용체의 명시적 서브 클래스를 제거하지 않습니다.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Optional">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Optional</code><a class="headerlink" href="#typing.Optional" title="정의 주소">¶</a></dt>
<dd><p>선택적 형.</p>
<p><code class="docutils literal notranslate"><span class="pre">Optional[X]</span></code>는 <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">None]</span></code>과 동등합니다.</p>
<p>이는 기본값을 갖는 선택적 인자와 같은 개념이 아님에 유의하십시오. 단지 선택적이기 때문에 기본값을 갖는 선택적 인자가 형 어노테이션에 <code class="docutils literal notranslate"><span class="pre">Optional</span></code> 한정자가 필요하지는 않습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>한편, 명시적인 <code class="docutils literal notranslate"><span class="pre">None</span></code> 값이 허용되면, 인자가 선택적인지와 관계없이 <code class="docutils literal notranslate"><span class="pre">Optional</span></code>을 사용하는 것이 적합합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Callable">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Callable</code><a class="headerlink" href="#typing.Callable" title="정의 주소">¶</a></dt>
<dd><p>콜러블 형; <code class="docutils literal notranslate"><span class="pre">Callable[[int],</span> <span class="pre">str]</span></code>은 (int) -&gt; str 인 함수입니다.</p>
<p>서브스크립션 문법은 항상 정확히 두 개의 값으로 사용되어야 합니다: 인자 리스트와 반환형. 인자 리스트는 형의 리스트거나 생략 부호(ellipsis)여야 합니다. 반환형은 단일한 형이어야 합니다.</p>
<p>선택적이나 키워드 인자를 나타내는 문법은 없습니다; 그런 함수 형은 거의 콜백 형으로 사용되지 않습니다. <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">ReturnType]</span></code>(리터럴 생략 부호)은 임의의 수의 인자를 취하고 <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code>을 반환하는 콜러블에 형 힌트를 주는 데 사용할 수 있습니다. 단순한 <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a>은 <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">Any]</span></code>와 동등하며, 이는 다시 <a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a>과 동등합니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-124"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Type">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Type</code><span class="sig-paren">(</span><em class="sig-param">Generic[CT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Type" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">C</span></code>로 어노테이트 된 변수는 <code class="docutils literal notranslate"><span class="pre">C</span></code> 형의 값을 받아들일 수 있습니다. 대조적으로, <code class="docutils literal notranslate"><span class="pre">Type[C]</span></code>로 어노테이트 된 변수는 클래스 자신인 값을 받아들일 수 있습니다 – 구체적으로, <code class="docutils literal notranslate"><span class="pre">C</span></code>의 <em>클래스 객체</em>를 허용합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>         <span class="c1"># Has type &#39;int&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">int</span>       <span class="c1"># Has type &#39;Type[int]&#39;</span>
<span class="n">c</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c1"># Also has type &#39;Type[int]&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Type[C]</span></code>는 공변적(covariant)입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">:</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">BasicUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">ProUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">TeamUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>

<span class="c1"># Accepts User, BasicUser, ProUser, TeamUser, ...</span>
<span class="k">def</span> <span class="nf">make_new_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">User</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">User</span><span class="p">:</span>
    <span class="c1"># ...</span>
    <span class="k">return</span> <span class="n">user_class</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Type[C]</span></code>가 공변적(covariant)이라는 사실은 <code class="docutils literal notranslate"><span class="pre">C</span></code>의 모든 서브 클래스가 <code class="docutils literal notranslate"><span class="pre">C</span></code>와 같은 생성자 서명과 클래스 메서드 서명을 구현해야 함을 의미합니다. 형 검사기는 이 위반을 표시해야 하지만, 표시된 베이스 클래스의 생성자 호출과 일치하는 서브 클래스의 생성자 호출을 허용해야 합니다. 이 특별한 경우를 처리하기 위한 형 검사기의 요구 사항은 향후 <span class="target" id="index-125"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> 개정판에서 변경될 수 있습니다.</p>
<p><a class="reference internal" href="#typing.Type" title="typing.Type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Type</span></code></a>의 합법적인 매개 변수는 클래스, <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, <a class="reference internal" href="#generics"><span class="std std-ref">형 변수</span></a> 및 이러한 형들의 공용체(union)뿐입니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">new_non_team_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">BasicUser</span><span class="p">,</span> <span class="n">ProUser</span><span class="p">]]):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Type[Any]</span></code>는 <code class="docutils literal notranslate"><span class="pre">Type</span></code>과 동등하며, 이는 다시 파이썬의 메타 클래스 계층 구조의 루트인 <code class="docutils literal notranslate"><span class="pre">type</span></code>과 동등합니다.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-126"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Literal">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Literal</code><a class="headerlink" href="#typing.Literal" title="정의 주소">¶</a></dt>
<dd><p>대응하는 변수나 함수 매개 변수가 제공된 리터럴(또는 여러 리터럴 중 하나)과 동등한 값을 가짐을 형 검사기에 알리는 데 사용할 수 있는 형. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">validate_simple</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]:</span>  <span class="c1"># always returns True</span>
    <span class="o">...</span>

<span class="n">MODE</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">open_helper</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">MODE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/some/path&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>  <span class="c1"># Passes type check</span>
<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/other/path&#39;</span><span class="p">,</span> <span class="s1">&#39;typo&#39;</span><span class="p">)</span>  <span class="c1"># Error in type checker</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code>은 서브 클래싱 될 수 없습니다. 실행 시간에는, 임의의 값이 <code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code>에 대한 형 인자로 허용되지만, 형 검사기는 제한을 부과할 수 있습니다. 리터럴 형에 대한 자세한 내용은 <span class="target" id="index-127"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0586"><strong>PEP 586</strong></a>을 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9.1에서 변경: </span><code class="docutils literal notranslate"><span class="pre">Literal</span></code> now de-duplicates parameters.  Equality comparisons of
<code class="docutils literal notranslate"><span class="pre">Literal</span></code> objects are no longer order dependent. <code class="docutils literal notranslate"><span class="pre">Literal</span></code> objects
will now raise a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception during equality comparisons
if one of their parameters are not <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.ClassVar">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ClassVar</code><a class="headerlink" href="#typing.ClassVar" title="정의 주소">¶</a></dt>
<dd><p>클래스 변수를 표시하기 위한 특수 형 구조물.</p>
<p><span class="target" id="index-128"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>에서 소개된 것처럼, ClassVar로 감싼 변수 어노테이션은 주어진 어트리뷰트가 클래스 변수로 사용되도록 의도되었으며 해당 클래스의 인스턴스에 설정되어서는 안 됨을 나타냅니다. 용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Starship</span><span class="p">:</span>
    <span class="n">stats</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># class variable</span>
    <span class="n">damage</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>                     <span class="c1"># instance variable</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a>는 형만 받아들이며 더는 서브 스크립트 할 수 없습니다.</p>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a>는 클래스 자체가 아니므로, <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>나 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>와 함께 사용하면 안 됩니다. <a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a>는 파이썬 실행 시간 동작을 변경하지 않지만, 제삼자 형 검사기에서 사용할 수 있습니다. 예를 들어, 형 검사기는 다음 코드를 에러로 표시 할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">enterprise_d</span> <span class="o">=</span> <span class="n">Starship</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span>
<span class="n">enterprise_d</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Error, setting class variable on instance</span>
<span class="n">Starship</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>     <span class="c1"># This is OK</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.3에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Final">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Final</code><a class="headerlink" href="#typing.Final" title="정의 주소">¶</a></dt>
<dd><p>형 검사기에 이름이 다시 대입되거나 서브 클래스에서 재정의될 수 없다는 것을 나타내는 특수한 typing 구조물. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">MAX_SIZE</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="mi">9000</span>
<span class="n">MAX_SIZE</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Error reported by type checker</span>

<span class="k">class</span> <span class="nc">Connection</span><span class="p">:</span>
    <span class="n">TIMEOUT</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">class</span> <span class="nc">FastConnector</span><span class="p">(</span><span class="n">Connection</span><span class="p">):</span>
    <span class="n">TIMEOUT</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Error reported by type checker</span>
</pre></div>
</div>
<p>이러한 속성에 대한 실행 시간 검사는 없습니다. 자세한 내용은 <span class="target" id="index-129"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0591"><strong>PEP 591</strong></a>을 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="data">
<dt id="typing.Annotated">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Annotated</code><a class="headerlink" href="#typing.Annotated" title="정의 주소">¶</a></dt>
<dd><p>A type, introduced in <span class="target" id="index-23"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0593"><strong>PEP 593</strong></a> (<code class="docutils literal notranslate"><span class="pre">Flexible</span> <span class="pre">function</span> <span class="pre">and</span> <span class="pre">variable</span>
<span class="pre">annotations</span></code>), to decorate existing types with context-specific metadata
(possibly multiple pieces of it, as <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> is variadic).
Specifically, a type <code class="docutils literal notranslate"><span class="pre">T</span></code> can be annotated with metadata <code class="docutils literal notranslate"><span class="pre">x</span></code> via the
typehint <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code>. This metadata can be used for either static
analysis or at runtime. If a library (or tool) encounters a typehint
<code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code> and has no special logic for metadata <code class="docutils literal notranslate"><span class="pre">x</span></code>, it
should ignore it and simply treat the type as <code class="docutils literal notranslate"><span class="pre">T</span></code>. Unlike the
<code class="docutils literal notranslate"><span class="pre">no_type_check</span></code> functionality that currently exists in the <code class="docutils literal notranslate"><span class="pre">typing</span></code>
module which completely disables typechecking annotations on a function
or a class, the <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> type allows for both static typechecking
of <code class="docutils literal notranslate"><span class="pre">T</span></code> (which can safely ignore <code class="docutils literal notranslate"><span class="pre">x</span></code>)
together with runtime access to <code class="docutils literal notranslate"><span class="pre">x</span></code> within a specific application.</p>
<p>궁극적으로, 어노테이션을 해석하는 방법에 대한 책임은 (있기는 하다면) <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 형을 만나는 도구나 라이브러리의 책임입니다. <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 형을 만나는 도구나 라이브러리는 어노테이션을 통해 스캔하여 관심이 있는 것인지 판별합니다 (예를 들어, <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code>를 사용하여).</p>
<p>도구나 라이브러리가 어노테이션을 지원하지 않거나 알 수 없는 어노테이션을 만나면, 이를 무시하고 어노테이트 된 형을 하부 형으로 처리해야 합니다.</p>
<p>클라이언트가 한 형에 여러 어노테이션을 갖도록 허용되는지와 해당 어노테이션들을 병합하는 방법을 결정하는 것은 어노테이션을 소비하는 도구에 달려 있습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 형을 사용하면 임의의 노드에 같은 (또는 다른) 형의 여러 어노테이션을 넣을 수 있도록 하므로, 이 어노테이션을 소비하는 도구나 라이브러리는 잠재적 중복을 처리해야 합니다. 예를 들어, 값 범위 분석을 수행하는 경우 다음처럼 허용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T1</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
<span class="n">T2</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">T1</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">include_extras=True</span></code>를 <a class="reference internal" href="#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_type_hints()</span></code></a>로 전달하면 실행 시간에 추가 어노테이션에 액세스 할 수 있습니다.</p>
<p>문법의 세부 사항:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code>의 첫 번째 인자는 유효한 형이어야 합니다</p></li>
<li><p>여러 개의 형 주석이 지원됩니다 (<code class="docutils literal notranslate"><span class="pre">Annotated</span></code>는 가변 인자를 지원합니다):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code>는 최소한 두 개의 인자로 호출해야 합니다 (<code class="docutils literal notranslate"><span class="pre">Annotated[int]</span></code>는 유효하지 않습니다)</p></li>
<li><p>어노테이션의 순서는 유지되며 동등(equality) 검사의 경우 중요합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">),</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>중첩된 <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> 형은 가장 안쪽 주석으로 시작하는 메타 데이터로 평탄화됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span> <span class="o">==</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>중복된 어노테이션은 제거되지 않습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code>는 중첩되고 제네릭한 에일리어스와 함께 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">Vec</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]],</span> <span class="n">MaxLen</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">Vec</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

<span class="n">V</span> <span class="o">==</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">MaxLen</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</pre></div>
</div>
</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.9에 추가.</span></p>
</div>
</dd></dl>

</section>
<section id="building-generic-types">
<h4>제네릭 형 구축하기<a class="headerlink" href="#building-generic-types" title="제목 주소">¶</a></h4>
<p>이들은 어노테이션에는 사용되지 않습니다. 제네릭 형을 만들기 위한 빌딩 블록입니다.</p>
<dl class="class">
<dt id="typing.Generic">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Generic</code><a class="headerlink" href="#typing.Generic" title="정의 주소">¶</a></dt>
<dd><p>제네릭 형을 위한 추상 베이스 클래스.</p>
<p>제네릭 형은 일반적으로 이 클래스를 하나 이상의 형 변수로 인스턴스 화한 것을 상속하여 선언됩니다. 예를 들어, 제네릭 매핑형은 다음과 같이 정의할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mapping</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="c1"># Etc.</span>
</pre></div>
</div>
<p>이 클래스는 다음과 같이 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lookup_name</span><span class="p">(</span><span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Y</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.TypeVar">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">TypeVar</code><a class="headerlink" href="#typing.TypeVar" title="정의 주소">¶</a></dt>
<dd><p>형 변수.</p>
<p>용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># Can be anything</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>  <span class="c1"># Can be any subtype of str</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># Must be exactly str or bytes</span>
</pre></div>
</div>
<p>형 변수는 주로 정적 형 검사기를 위해 존재합니다. 이들은 제네릭 함수 정의뿐만 아니라 제네릭 형의 매개 변수 역할을 합니다. 제네릭 형에 대한 자세한 내용은 <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>을 참조하십시오. 제네릭 함수는 다음과 같이 작동합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Return a list containing n references to x.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>


<span class="k">def</span> <span class="nf">print_capitalized</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">S</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Print x capitalized, and return x.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">capitalize</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">A</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add two strings or bytes objects together.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>Note that type variables can be <em>bound</em>, <em>constrained</em>, or neither, but
cannot be both bound <em>and</em> constrained.</p>
<p>Constrained type variables and bound type variables have different
semantics in several important ways. Using a <em>constrained</em> type variable
means that the <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> can only ever be solved as being exactly one of
the constraints given:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">)</span>  <span class="c1"># Ok, variable &#39;a&#39; has type &#39;str&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">),</span> <span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;two&#39;</span><span class="p">))</span>  <span class="c1"># Inferred type of variable &#39;b&#39; is &#39;str&#39;,</span>
                                                               <span class="c1"># despite &#39;StringSubclass&#39; being passed in</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;two&#39;</span><span class="p">)</span>  <span class="c1"># error: type variable &#39;A&#39; can be either &#39;str&#39; or &#39;bytes&#39; in a function call, but not both</span>
</pre></div>
</div>
<p>Using a <em>bound</em> type variable, however, means that the <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> will be
solved using the most specific type possible:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">print_capitalized</span><span class="p">(</span><span class="s1">&#39;a string&#39;</span><span class="p">)</span>  <span class="c1"># Ok, output has type &#39;str&#39;</span>

<span class="k">class</span> <span class="nc">StringSubclass</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">print_capitalized</span><span class="p">(</span><span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;another string&#39;</span><span class="p">))</span>  <span class="c1"># Ok, output has type &#39;StringSubclass&#39;</span>
<span class="n">print_capitalized</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>  <span class="c1"># error: int is not a subtype of str</span>
</pre></div>
</div>
<p>Type variables can be bound to concrete types, abstract types (ABCs or
protocols), and even unions of types:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">U</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="o">|</span><span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># Can be any subtype of the union str|bytes</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">SupportsAbs</span><span class="p">)</span>  <span class="c1"># Can be anything with an __abs__ method</span>
</pre></div>
</div>
<p>Bound type variables are particularly useful for annotating
<a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethods</span></code></a> that serve as alternative constructors.
In the following example (©
<a class="reference external" href="https://www.youtube.com/watch?v=HTLu2DFOdTg">Raymond Hettinger</a>), the
type variable <code class="docutils literal notranslate"><span class="pre">C</span></code> is bound to the <code class="docutils literal notranslate"><span class="pre">Circle</span></code> class through the use of a
forward reference. Using this type variable to annotate the
<code class="docutils literal notranslate"><span class="pre">with_circumference</span></code> classmethod, rather than hardcoding the return type
as <code class="docutils literal notranslate"><span class="pre">Circle</span></code>, means that a type checker can correctly infer the return
type even if the method is called on a subclass:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="n">C</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s1">&#39;Circle&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Circle</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;An abstract circle&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>

    <span class="c1"># Use a type variable to show that the return type</span>
    <span class="c1"># will always be an instance of whatever ``cls`` is</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">with_circumference</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">C</span><span class="p">],</span> <span class="n">circumference</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">C</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a circle with the specified circumference&quot;&quot;&quot;</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">circumference</span> <span class="o">/</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Tire</span><span class="p">(</span><span class="n">Circle</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A specialised circle (made out of rubber)&quot;&quot;&quot;</span>

    <span class="n">MATERIAL</span> <span class="o">=</span> <span class="s1">&#39;rubber&#39;</span>


<span class="n">c</span> <span class="o">=</span> <span class="n">Circle</span><span class="o">.</span><span class="n">with_circumference</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Ok, variable &#39;c&#39; has type &#39;Circle&#39;</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tire</span><span class="o">.</span><span class="n">with_circumference</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># Ok, variable &#39;t&#39; has type &#39;Tire&#39; (not &#39;Circle&#39;)</span>
</pre></div>
</div>
<p>실행 시간에, <code class="docutils literal notranslate"><span class="pre">isinstance(x,</span> <span class="pre">T)</span></code>는 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다. 일반적으로, <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>와 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>는 형과 함께 사용하면 안 됩니다.</p>
<p>Type variables may be marked covariant or contravariant by passing
<code class="docutils literal notranslate"><span class="pre">covariant=True</span></code> or <code class="docutils literal notranslate"><span class="pre">contravariant=True</span></code>.  See <span class="target" id="index-24"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> for more
details.  By default, type variables are invariant.</p>
</dd></dl>

<dl class="data">
<dt id="typing.AnyStr">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AnyStr</code><a class="headerlink" href="#typing.AnyStr" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> is a <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">constrained</span> <span class="pre">type</span> <span class="pre">variable</span></code></a> defined as
<code class="docutils literal notranslate"><span class="pre">AnyStr</span> <span class="pre">=</span> <span class="pre">TypeVar('AnyStr',</span> <span class="pre">str,</span> <span class="pre">bytes)</span></code>.</p>
<p>다른 종류의 문자열을 섞지 않고 모든 종류의 문자열을 받아들일 수 있는 함수에 사용하기 위한 것입니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">concat</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Ok, output has type &#39;unicode&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Ok, output has type &#39;bytes&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Error, cannot mix unicode and bytes</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Protocol">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Protocol</code><span class="sig-paren">(</span><em class="sig-param">Generic</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Protocol" title="정의 주소">¶</a></dt>
<dd><p>프로토콜 클래스의 베이스 클래스. 프로토콜 클래스는 다음과 같이 정의됩니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Proto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>이러한 클래스는 주로 구조적 서브 타이핑(정적 덕 타이핑)을 인식하는 정적 형 검사기와 함께 사용됩니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Proto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>

<span class="n">func</span><span class="p">(</span><span class="n">C</span><span class="p">())</span>  <span class="c1"># Passes static type check</span>
</pre></div>
</div>
<p>자세한 내용은 <span class="target" id="index-130"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0544"><strong>PEP 544</strong></a>를 참조하십시오. <a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code></a>(아래에서 설명합니다)로 데코레이트 된 프로토콜 클래스는 주어진 어트리뷰트의 존재 여부만 확인하고 형 서명을 무시하는 단순한 실행 시간 프로토콜로 작동합니다.</p>
<p>프로토콜 클래스는 제네릭일 수 있습니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GenProto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="typing.runtime_checkable">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">runtime_checkable</code><a class="headerlink" href="#typing.runtime_checkable" title="정의 주소">¶</a></dt>
<dd><p>프로토콜 클래스를 실행 시간 프로토콜로 표시합니다.</p>
<p>이러한 프로토콜은 <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>와 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>와 함께 사용할 수 있습니다. 이것은 비 프로토콜 클래스에 적용될 때 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시킵니다. 이것은 <a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a>에 있는 <a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>처럼 “한 가지만 잘하는” 것과 매우 유사한 단순한 구조적 검사를 허용합니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@runtime_checkable</span>
<span class="k">class</span> <span class="nc">Closable</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/some/file&#39;</span><span class="p">),</span> <span class="n">Closable</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code></a>은 필요한 메서드의 존재만 검사할 뿐, 그것들의 형 서명은 검사하지 않습니다! 예를 들어, <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.complex</span></code></a>는 <a class="reference internal" href="../reference/datamodel.html#object.__float__" title="object.__float__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__float__()</span></code></a>를 구현하므로, <a class="reference internal" href="#typing.SupportsFloat" title="typing.SupportsFloat"><code class="xref py py-class docutils literal notranslate"><span class="pre">SupportsFloat</span></code></a>에 대해 <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 검사를 통과합니다. 그러나, <code class="docutils literal notranslate"><span class="pre">complex.__float__</span></code> 메서드는 더 많은 정보를 제공하는 메시지와 함께 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeError</span></code></a>를 발생시키기 위해서만 존재합니다.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

</section>
<section id="other-special-directives">
<h4>기타 특수 지시자<a class="headerlink" href="#other-special-directives" title="제목 주소">¶</a></h4>
<p>이들은 어노테이션에는 사용되지 않습니다. 형 선언을 위한 빌딩 블록입니다.</p>
<dl class="class">
<dt id="typing.NamedTuple">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">NamedTuple</code><a class="headerlink" href="#typing.NamedTuple" title="정의 주소">¶</a></dt>
<dd><p>형 지정된(typed) <a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a> 버전.</p>
<p>용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>이것은 다음과 동등합니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>필드에 기본값을 부여하려면, 클래스 바디에서 그 값을 대입할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">employee</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">employee</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>
</div>
<p>기본값이 있는 필드는 기본값이 없는 모든 필드 뒤에 와야 합니다.</p>
<p>The resulting class has an extra attribute <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> giving a
dict that maps the field names to the field types.  (The field names are in
the <code class="docutils literal notranslate"><span class="pre">_fields</span></code> attribute and the default values are in the
<code class="docutils literal notranslate"><span class="pre">_field_defaults</span></code> attribute, both of which are part of the <a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">namedtuple()</span></code></a>
API.)</p>
<p><code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> 서브 클래스는 독스트링과 메서드도 가질 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents an employee.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;Employee </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">, id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">&gt;&#39;</span>
</pre></div>
</div>
<p>이전 버전과 호환되는 사용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6에서 변경: </span><span class="target" id="index-131"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a> 변수 어노테이션 문법 지원을 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.6.1에서 변경: </span>기본값, 메서드 및 독스트링에 대한 지원을 추가했습니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.8에서 변경: </span><code class="docutils literal notranslate"><span class="pre">_field_types</span></code>와 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 어트리뷰트는 이제 <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code> 인스턴스가 아닌 일반 딕셔너리입니다.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span><code class="docutils literal notranslate"><span class="pre">_field_types</span></code> 어트리뷰트를 제거하고, 같은 정보를 가지는 더 표준적인 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 어트리뷰트로 대체했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="typing.NewType">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">NewType</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">tp</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.NewType" title="정의 주소">¶</a></dt>
<dd><p>형 검사기에 구별되는 형을 가리키는 도우미 함수, <a class="reference internal" href="#distinct"><span class="std std-ref">NewType</span></a>을 참조하십시오. 실행 시간에 인자를 반환하는 함수를 반환합니다. 용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">first_user</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.TypedDict">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">TypedDict</code><span class="sig-paren">(</span><em class="sig-param">dict</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypedDict" title="정의 주소">¶</a></dt>
<dd><p>딕셔너리에 형 힌트를 추가하는 특수 구조. 실행 시간에 일반 <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>입니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>는 모든 인스턴스가 각 키가 일관된 형의 값에 연관되는, 특정한 키 집합을 갖도록 기대되는 딕셔너리 형을 선언합니다. 이 기대는 실행 시간에는 검사되지 않고, 형 검사기에서만 강제됩니다. 사용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;good&#39;</span><span class="p">}</span>  <span class="c1"># OK</span>
<span class="n">b</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;bad&#39;</span><span class="p">}</span>           <span class="c1"># Fails type check</span>

<span class="k">assert</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To allow using this feature with older versions of Python that do not
support <span class="target" id="index-27"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>, <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> supports two additional equivalent
syntactic forms:</p>
<ul>
<li><p>Using a literal <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> as the second argument:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">})</span>
</pre></div>
</div>
</li>
<li><p>Using keyword arguments:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>The functional syntax should also be used when any of the keys are not valid
<a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">identifiers</span></a>, for example because they are keywords or contain hyphens.
Example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># raises SyntaxError</span>
<span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="ow">in</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># &#39;in&#39; is a keyword</span>
    <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># name with hyphens</span>

<span class="c1"># OK, functional syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;x-y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">})</span>
</pre></div>
</div>
<p>By default, all keys must be present in a <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>. It is possible to
override this by specifying totality.
Usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="c1"># Alternative syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">},</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>This means that a <code class="docutils literal notranslate"><span class="pre">Point2D</span></code> <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> can have any of the keys
omitted. A type checker is only expected to support a literal <code class="docutils literal notranslate"><span class="pre">False</span></code> or
<code class="docutils literal notranslate"><span class="pre">True</span></code> as the value of the <code class="docutils literal notranslate"><span class="pre">total</span></code> argument. <code class="docutils literal notranslate"><span class="pre">True</span></code> is the default,
and makes all items defined in the class body required.</p>
<p>It is possible for a <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> type to inherit from one or more other <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> types
using the class-based syntax.
Usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Point3D</span></code> has three items: <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code>. It is equivalent to this
definition:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> cannot inherit from a non-<code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> class,
notably including <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">Y</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">Z</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># A non-TypedDict class</span>

<span class="k">class</span> <span class="nc">XY</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># OK</span>

<span class="k">class</span> <span class="nc">XZ</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># raises TypeError</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">XT</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span> <span class="k">pass</span>  <span class="c1"># raises TypeError</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> can be introspected via <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code>,
<a class="reference internal" href="#typing.TypedDict.__total__" title="typing.TypedDict.__total__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__total__</span></code></a>, <a class="reference internal" href="#typing.TypedDict.__required_keys__" title="typing.TypedDict.__required_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__required_keys__</span></code></a>, and <a class="reference internal" href="#typing.TypedDict.__optional_keys__" title="typing.TypedDict.__optional_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__optional_keys__</span></code></a>.</p>
<dl class="attribute">
<dt id="typing.TypedDict.__total__">
<code class="sig-name descname">__total__</code><a class="headerlink" href="#typing.TypedDict.__total__" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Point2D.__total__</span></code> gives the value of the <code class="docutils literal notranslate"><span class="pre">total</span></code> argument.
Example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point2D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point2D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="typing.TypedDict.__required_keys__">
<code class="sig-name descname">__required_keys__</code><a class="headerlink" href="#typing.TypedDict.__required_keys__" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="typing.TypedDict.__optional_keys__">
<code class="sig-name descname">__optional_keys__</code><a class="headerlink" href="#typing.TypedDict.__optional_keys__" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Point2D.__required_keys__</span></code> and <code class="docutils literal notranslate"><span class="pre">Point2D.__optional_keys__</span></code> return
<a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> objects containing required and non-required keys, respectively.
Currently the only way to declare both required and non-required keys in the
same <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> is mixed inheritance, declaring a <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> with one value
for the <code class="docutils literal notranslate"><span class="pre">total</span></code> argument and then inheriting it from another <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> with
a different value for <code class="docutils literal notranslate"><span class="pre">total</span></code>.
Usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">... </span>    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__required_keys__</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;z&#39;</span><span class="p">})</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__optional_keys__</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<p>추가 예제와 <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>를 사용하는 자세한 규칙은 <span class="target" id="index-132"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0589"><strong>PEP 589</strong></a>를 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

</section>
</section>
<section id="generic-concrete-collections">
<h3>제네릭 구상 컬렉션<a class="headerlink" href="#generic-concrete-collections" title="제목 주소">¶</a></h3>
<section id="corresponding-to-built-in-types">
<h4>내장형에 해당하는 것들<a class="headerlink" href="#corresponding-to-built-in-types" title="제목 주소">¶</a></h4>
<dl class="class">
<dt id="typing.Dict">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Dict</code><span class="sig-paren">(</span><em class="sig-param">dict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Dict" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>의 제네릭 버전. 반환형을 어노테이트하는 데 유용합니다. 인자를 어노테이트 하려면 <a class="reference internal" href="#typing.Mapping" title="typing.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a>과 같은 추상 컬렉션 형을 사용하는 것이 좋습니다.</p>
<p>이 형은 다음과 같이 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count_words</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.dict</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-133"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.List">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">List</code><span class="sig-paren">(</span><em class="sig-param">list, MutableSequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.List" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>의 제네릭 버전. 반환형을 어노테이트하는 데 유용합니다. 인자를 어노테이트 하려면 <a class="reference internal" href="#typing.Sequence" title="typing.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a>나 <a class="reference internal" href="#typing.Iterable" title="typing.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>과 같은 추상 컬렉션 형을 사용하는 것이 좋습니다.</p>
<p>이 형은 다음과 같이 사용될 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">vec2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">keep_positives</span><span class="p">(</span><span class="n">vector</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">vector</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.list</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-134"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Set">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Set</code><span class="sig-paren">(</span><em class="sig-param">set, MutableSet[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Set" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a>의 제네릭 버전. 반환형을 어노테이트하는 데 유용합니다. 인자를 어노테이트 하려면 <a class="reference internal" href="#typing.AbstractSet" title="typing.AbstractSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractSet</span></code></a>과 같은 추상 컬렉션 형을 사용하는 것이 좋습니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-135"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.FrozenSet">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">FrozenSet</code><span class="sig-paren">(</span><em class="sig-param">frozenset, AbstractSet[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.FrozenSet" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a>의 제네릭 버전.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-136"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">참고</p>
<p><a class="reference internal" href="#typing.Tuple" title="typing.Tuple"><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code></a>은 특수 형태입니다.</p>
</div>
</section>
<section id="corresponding-to-types-in-collections">
<h4><a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a>의 형에 해당하는 것들<a class="headerlink" href="#corresponding-to-types-in-collections" title="제목 주소">¶</a></h4>
<dl class="class">
<dt id="typing.DefaultDict">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">DefaultDict</code><span class="sig-paren">(</span><em class="sig-param">collections.defaultdict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.DefaultDict" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-137"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.OrderedDict">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">OrderedDict</code><span class="sig-paren">(</span><em class="sig-param">collections.OrderedDict, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.OrderedDict" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7.2에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-138"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.ChainMap">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ChainMap</code><span class="sig-paren">(</span><em class="sig-param">collections.ChainMap, MutableMapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ChainMap" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.1에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-139"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Counter">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Counter</code><span class="sig-paren">(</span><em class="sig-param">collections.Counter, Dict[T, int]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Counter" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.1에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-140"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Deque">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Deque</code><span class="sig-paren">(</span><em class="sig-param">deque, MutableSequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Deque" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.1에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-141"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

</section>
<section id="other-concrete-types">
<h4>기타 구상형<a class="headerlink" href="#other-concrete-types" title="제목 주소">¶</a></h4>
<dl class="class">
<dt id="typing.IO">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">IO</code><a class="headerlink" href="#typing.IO" title="정의 주소">¶</a></dt>
<dt id="typing.TextIO">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">TextIO</code><a class="headerlink" href="#typing.TextIO" title="정의 주소">¶</a></dt>
<dt id="typing.BinaryIO">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">BinaryIO</code><a class="headerlink" href="#typing.BinaryIO" title="정의 주소">¶</a></dt>
<dd><p>Generic type <code class="docutils literal notranslate"><span class="pre">IO[AnyStr]</span></code> and its subclasses <code class="docutils literal notranslate"><span class="pre">TextIO(IO[str])</span></code>
and <code class="docutils literal notranslate"><span class="pre">BinaryIO(IO[bytes])</span></code>
represent the types of I/O streams such as returned by
<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.8, will be removed in version 3.12: </span>These types are also in the <code class="docutils literal notranslate"><span class="pre">typing.io</span></code> namespace, which was
never supported by type checkers and will be removed.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Pattern">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Pattern</code><a class="headerlink" href="#typing.Pattern" title="정의 주소">¶</a></dt>
<dt id="typing.Match">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Match</code><a class="headerlink" href="#typing.Match" title="정의 주소">¶</a></dt>
<dd><p>These type aliases
correspond to the return types from <a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> and
<a class="reference internal" href="re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a>.  These types (and the corresponding functions)
are generic in <code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> and can be made specific by writing
<code class="docutils literal notranslate"><span class="pre">Pattern[str]</span></code>, <code class="docutils literal notranslate"><span class="pre">Pattern[bytes]</span></code>, <code class="docutils literal notranslate"><span class="pre">Match[str]</span></code>, or
<code class="docutils literal notranslate"><span class="pre">Match[bytes]</span></code>.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Deprecated since version 3.8, will be removed in version 3.12: </span>These types are also in the <code class="docutils literal notranslate"><span class="pre">typing.re</span></code> namespace, which was
never supported by type checkers and will be removed.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a>의 클래스 <code class="docutils literal notranslate"><span class="pre">Pattern</span></code>과 <code class="docutils literal notranslate"><span class="pre">Match</span></code>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-142"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Text">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Text</code><a class="headerlink" href="#typing.Text" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Text</span></code>는 <code class="docutils literal notranslate"><span class="pre">str</span></code>의 별칭입니다. 파이썬 2 코드를 위한 상위 호환 경로를 제공하기 위해 제공됩니다: 파이썬 2에서, <code class="docutils literal notranslate"><span class="pre">Text</span></code>는 <code class="docutils literal notranslate"><span class="pre">unicode</span></code>의 별칭입니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">Text</span></code>를 사용하여 값이 파이썬 2와 파이썬 3 모두와 호환되는 방식으로 유니코드 문자열을 포함해야 함을 나타내십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_unicode_checkmark</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Text</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">text</span> <span class="o">+</span> <span class="sa">u</span><span class="s1">&#39; </span><span class="se">\u2713</span><span class="s1">&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

</section>
</section>
<section id="abstract-base-classes">
<h3>추상 베이스 클래스<a class="headerlink" href="#abstract-base-classes" title="제목 주소">¶</a></h3>
<section id="corresponding-to-collections-in-collections-abc">
<h4><a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a>의 컬렉션에 해당하는 것들<a class="headerlink" href="#corresponding-to-collections-in-collections-abc" title="제목 주소">¶</a></h4>
<dl class="class">
<dt id="typing.AbstractSet">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AbstractSet</code><span class="sig-paren">(</span><em class="sig-param">Sized, Collection[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AbstractSet" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a>의 제네릭 버전.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-143"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.ByteString">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ByteString</code><span class="sig-paren">(</span><em class="sig-param">Sequence[int]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ByteString" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ByteString" title="collections.abc.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ByteString</span></code></a>의 제네릭 버전.</p>
<p>이 형은 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 및 바이트 시퀀스의 <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 형을 나타냅니다.</p>
<p>이 형의 줄임 표현으로, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>는 위에 언급된 모든 형의 인자를 어노테이트하는 데 사용될 수 있습니다.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.ByteString" title="collections.abc.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ByteString</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-144"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Collection">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Collection</code><span class="sig-paren">(</span><em class="sig-param">Sized, Iterable[T_co], Container[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Collection" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a>의 제네릭 버전</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.0에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-145"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Container">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Container</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Container" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a>의 제네릭 버전.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-146"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.ItemsView">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ItemsView</code><span class="sig-paren">(</span><em class="sig-param">MappingView, Generic[KT_co, VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ItemsView" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a>의 제네릭 버전.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-147"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.KeysView">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">KeysView</code><span class="sig-paren">(</span><em class="sig-param">MappingView[KT_co], AbstractSet[KT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.KeysView" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a>의 제네릭 버전.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-148"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Mapping">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Mapping</code><span class="sig-paren">(</span><em class="sig-param">Sized, Collection[KT], Generic[VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Mapping" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a>의 제네릭 버전. 이 형은 다음과 같이 사용할 수 있습니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_position_in_index</span><span class="p">(</span><span class="n">word_list</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">word_list</span><span class="p">[</span><span class="n">word</span><span class="p">]</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-149"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.MappingView">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">MappingView</code><span class="sig-paren">(</span><em class="sig-param">Sized, Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MappingView" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a>의 제네릭 버전.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-150"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.MutableMapping">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">MutableMapping</code><span class="sig-paren">(</span><em class="sig-param">Mapping[KT, VT]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableMapping" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a>의 제네릭 버전.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-151"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.MutableSequence">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">MutableSequence</code><span class="sig-paren">(</span><em class="sig-param">Sequence[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSequence" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a>의 제네릭 버전.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-152"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.MutableSet">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">MutableSet</code><span class="sig-paren">(</span><em class="sig-param">AbstractSet[T]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSet" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a>의 제네릭 버전.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-153"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Sequence">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Sequence</code><span class="sig-paren">(</span><em class="sig-param">Reversible[T_co], Collection[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Sequence" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a>의 제네릭 버전.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-154"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.ValuesView">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ValuesView</code><span class="sig-paren">(</span><em class="sig-param">MappingView[VT_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ValuesView" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a>의 제네릭 버전.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-155"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

</section>
<section id="corresponding-to-other-types-in-collections-abc">
<h4><a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a>의 기타 형에 해당하는 것들<a class="headerlink" href="#corresponding-to-other-types-in-collections-abc" title="제목 주소">¶</a></h4>
<dl class="class">
<dt id="typing.Iterable">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Iterable</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterable" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a>의 제네릭 버전.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-156"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Iterator">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Iterator</code><span class="sig-paren">(</span><em class="sig-param">Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterator" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a>의 제네릭 버전.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-157"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Generator">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Generator</code><span class="sig-paren">(</span><em class="sig-param">Iterator[T_co], Generic[T_co, T_contra, V_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Generator" title="정의 주소">¶</a></dt>
<dd><p>제너레이터는 제네릭 형 <code class="docutils literal notranslate"><span class="pre">Generator[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></code>으로 어노테이트할 수 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;Done&#39;</span>
</pre></div>
</div>
<p>typing 모듈의 다른 많은 제네릭과 달리 <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>의 <code class="docutils literal notranslate"><span class="pre">SendType</span></code>은 공변적(covariant)이거나 불변적(invariant)이 아니라 반변적(contravariant)으로 행동함에 유의하십시오.</p>
<p>제너레이터가 값을 일드(yield)하기만 하면, <code class="docutils literal notranslate"><span class="pre">SendType</span></code>과 <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code>을 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>또는, <code class="docutils literal notranslate"><span class="pre">Iterable[YieldType]</span></code>이나 <code class="docutils literal notranslate"><span class="pre">Iterator[YieldType]</span></code> 중 하나의 반환형을 갖는 것으로 제너레이터를 어노테이트 하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Generator</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-158"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Hashable">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Hashable</code><a class="headerlink" href="#typing.Hashable" title="정의 주소">¶</a></dt>
<dd><p>An alias to <a class="reference internal" href="collections.abc.html#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Hashable</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="typing.Reversible">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Reversible</code><span class="sig-paren">(</span><em class="sig-param">Iterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Reversible" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a>의 제네릭 버전.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-159"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Sized">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Sized</code><a class="headerlink" href="#typing.Sized" title="정의 주소">¶</a></dt>
<dd><p>An alias to <a class="reference internal" href="collections.abc.html#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sized</span></code></a>.</p>
</dd></dl>

</section>
<section id="asynchronous-programming">
<h4>비동기 프로그래밍<a class="headerlink" href="#asynchronous-programming" title="제목 주소">¶</a></h4>
<dl class="class">
<dt id="typing.Coroutine">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Coroutine</code><span class="sig-paren">(</span><em class="sig-param">Awaitable[V_co], Generic[T_co, T_contra, V_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Coroutine" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a>의 제네릭 버전. 형 변수의 변화와 순서는 <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>의 것과 같습니다, 예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Coroutine</span>
<span class="n">c</span><span class="p">:</span> <span class="n">Coroutine</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>  <span class="c1"># Some coroutine defined elsewhere</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;hi&#39;</span><span class="p">)</span>                   <span class="c1"># Inferred type of &#39;x&#39; is list[str]</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">bar</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="k">await</span> <span class="n">c</span>                    <span class="c1"># Inferred type of &#39;y&#39; is int</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.3에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-160"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncGenerator">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AsyncGenerator</code><span class="sig-paren">(</span><em class="sig-param">AsyncIterator[T_co], Generic[T_co, T_contra]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncGenerator" title="정의 주소">¶</a></dt>
<dd><p>비동기 제너레이터는 제네릭 형 <code class="docutils literal notranslate"><span class="pre">AsyncGenerator[YieldType,</span> <span class="pre">SendType]</span></code>으로 어노테이트할 수 있습니다. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">rounded</span> <span class="o">=</span> <span class="k">await</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">rounded</span>
</pre></div>
</div>
<p>일반 제너레이터와 달리, 비동기 제너레이터는 값을 반환할 수 없기 때문에, <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> 형 매개 변수가 없습니다. <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>와 마찬가지로, <code class="docutils literal notranslate"><span class="pre">SendType</span></code>은 반변적(contravariant)으로 행동합니다.</p>
<p>제너레이터가 값을 일드(yield)하기만 하면, <code class="docutils literal notranslate"><span class="pre">SendType</span></code>을 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<p>또는, <code class="docutils literal notranslate"><span class="pre">AsyncIterable[YieldType]</span></code>이나 <code class="docutils literal notranslate"><span class="pre">AsyncIterator[YieldType]</span></code> 중 하나의 반환형을 갖는 것으로 제너레이터를 어노테이트 하십시오:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.1에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncGenerator</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-161"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncIterable">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AsyncIterable</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterable" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-162"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncIterator">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AsyncIterator</code><span class="sig-paren">(</span><em class="sig-param">AsyncIterable[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterator" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-163"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.Awaitable">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">Awaitable</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Awaitable" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a>의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a>은 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-164"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

</section>
<section id="context-manager-types">
<h4>컨텍스트 관리자 형<a class="headerlink" href="#context-manager-types" title="제목 주소">¶</a></h4>
<dl class="class">
<dt id="typing.ContextManager">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ContextManager</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ContextManager" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a> 의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.0에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.contextlib.AbstractContextManager</span></code>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-165"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.AsyncContextManager">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">AsyncContextManager</code><span class="sig-paren">(</span><em class="sig-param">Generic[T_co]</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncContextManager" title="정의 주소">¶</a></dt>
<dd><p><a class="reference internal" href="contextlib.html#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a> 의 제네릭 버전.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.4에 추가.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.6.2에 추가.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">버전 3.9부터 폐지: </span><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.contextlib.AbstractAsyncContextManager</span></code>는 이제 <code class="docutils literal notranslate"><span class="pre">[]</span></code>를 지원합니다. <span class="target" id="index-166"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a>와 <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">제네릭 에일리어스 형</span></a>을 참조하십시오.</p>
</div>
</dd></dl>

</section>
</section>
<section id="protocols">
<h3>프로토콜<a class="headerlink" href="#protocols" title="제목 주소">¶</a></h3>
<p>이 프로토콜은 <a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code></a>로 데코레이트 되어 있습니다.</p>
<dl class="class">
<dt id="typing.SupportsAbs">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsAbs</code><a class="headerlink" href="#typing.SupportsAbs" title="정의 주소">¶</a></dt>
<dd><p>반환형이 공변적(covariant)인 하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__abs__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsBytes">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsBytes</code><a class="headerlink" href="#typing.SupportsBytes" title="정의 주소">¶</a></dt>
<dd><p>하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__bytes__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsComplex">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsComplex</code><a class="headerlink" href="#typing.SupportsComplex" title="정의 주소">¶</a></dt>
<dd><p>하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__complex__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsFloat">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsFloat</code><a class="headerlink" href="#typing.SupportsFloat" title="정의 주소">¶</a></dt>
<dd><p>하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__float__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsIndex">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsIndex</code><a class="headerlink" href="#typing.SupportsIndex" title="정의 주소">¶</a></dt>
<dd><p>하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__index__</span></code>를 가진 ABC.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsInt">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsInt</code><a class="headerlink" href="#typing.SupportsInt" title="정의 주소">¶</a></dt>
<dd><p>하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__int__</span></code>를 가진 ABC.</p>
</dd></dl>

<dl class="class">
<dt id="typing.SupportsRound">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">SupportsRound</code><a class="headerlink" href="#typing.SupportsRound" title="정의 주소">¶</a></dt>
<dd><p>반환형이 공변적(covariant)인 하나의 추상 메서드 <code class="docutils literal notranslate"><span class="pre">__round__</span></code>를 가진 ABC.</p>
</dd></dl>

</section>
<section id="functions-and-decorators">
<h3>함수와 데코레이터<a class="headerlink" href="#functions-and-decorators" title="제목 주소">¶</a></h3>
<dl class="function">
<dt id="typing.cast">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">cast</code><span class="sig-paren">(</span><em class="sig-param">typ</em>, <em class="sig-param">val</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.cast" title="정의 주소">¶</a></dt>
<dd><p>값을 형으로 변환합니다.</p>
<p>값을 변경하지 않고 반환합니다. 형 검사기에서는 반환 값이 지정된 형임을 나타내지만, 실행 시간에는 의도적으로 아무것도 확인하지 않습니다 (우리는 이것이 가능한 한 빠르기를 원합니다).</p>
</dd></dl>

<dl class="function">
<dt id="typing.overload">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">overload</code><a class="headerlink" href="#typing.overload" title="정의 주소">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> 데코레이터는 여러 가지 다양한 인자형의 조합을 지원하는 함수와 메서드를 기술할 수 있도록 합니다. <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>로 데코레이트 된 일련의 정의에는 (같은 함수/메서드에 대해) 정확히 하나의 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>로 데코레이트 되지 않은 정의가 뒤따라야 합니다. <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>로 데코레이트 된 정의는 <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>로 데코레이트 되지 않은 정의에 의해 덮어 쓰이기 때문에 형 검사기만을 위한 것입니다. 후자는 실행 시간에 사용되지만, 형 검사기에서는 무시되어야 합니다. 실행 시간에, <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>로 데코레이트 된 함수를 직접 호출하면 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 가 발생합니다. 공용체(union)나 형 변수를 사용하여 표현할 수 있는 것보다 더 정밀한 형을 제공하는 오버로드의 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">actual</span> <span class="n">implementation</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>자세한 내용과 다른 typing 의미와의 비교는 <span class="target" id="index-167"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>를 참조하십시오.</p>
</dd></dl>

<dl class="function">
<dt id="typing.final">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">final</code><a class="headerlink" href="#typing.final" title="정의 주소">¶</a></dt>
<dd><p>데코레이트 된 메서드가 재정의될 수 없고, 데코레이트 된 클래스가 서브 클래싱 될 수 없음을 형 검사기에 알리는 데코레이터. 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>
<span class="k">class</span> <span class="nc">Sub</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Error reported by type checker</span>
        <span class="o">...</span>

<span class="nd">@final</span>
<span class="k">class</span> <span class="nc">Leaf</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">class</span> <span class="nc">Other</span><span class="p">(</span><span class="n">Leaf</span><span class="p">):</span>  <span class="c1"># Error reported by type checker</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>이러한 속성에 대한 실행 시간 검사는 없습니다. 자세한 내용은 <span class="target" id="index-168"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0591"><strong>PEP 591</strong></a>을 참조하십시오.</p>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="typing.no_type_check">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">no_type_check</code><a class="headerlink" href="#typing.no_type_check" title="정의 주소">¶</a></dt>
<dd><p>어노테이션이 형 힌트가 아님을 나타내는 데코레이터.</p>
<p>이것은 클래스나 함수 <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">데코레이터</span></a>로 작동합니다. 클래스일 때, 해당 클래스에 정의된 모든 메서드에 재귀적으로 적용됩니다 (하지만 슈퍼 클래스나 서브 클래스에 정의된 메서드에는 적용되지 않습니다).</p>
<p>함수가 제자리에서(in place) 변경됩니다.</p>
</dd></dl>

<dl class="function">
<dt id="typing.no_type_check_decorator">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">no_type_check_decorator</code><a class="headerlink" href="#typing.no_type_check_decorator" title="정의 주소">¶</a></dt>
<dd><p>다른 데코레이터에 <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a> 효과를 주는 데코레이터.</p>
<p>이것은 데코레이트 된 함수를 <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a>로 감싸는 무언가로 데코레이터를 감쌉니다.</p>
</dd></dl>

<dl class="function">
<dt id="typing.type_check_only">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">type_check_only</code><a class="headerlink" href="#typing.type_check_only" title="정의 주소">¶</a></dt>
<dd><p>실행 시간에 클래스나 함수를 사용할 수 없도록 표시하는 데코레이터.</p>
<p>이 데코레이터 자체는 실행 시간에 사용할 수 없습니다. 주로, 구현이 비공개 클래스의 인스턴스를 반환할 때, 형 스텁 파일에 정의된 클래스를 표시하기 위한 용도입니다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@type_check_only</span>
<span class="k">class</span> <span class="nc">Response</span><span class="p">:</span>  <span class="c1"># private or not available at runtime</span>
    <span class="n">code</span><span class="p">:</span> <span class="nb">int</span>
    <span class="k">def</span> <span class="nf">get_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">fetch_response</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>비공개 클래스의 인스턴스를 반환하는 것은 좋지 않음에 유의하십시오. 일반적으로 그러한 클래스를 공개로 만드는 것이 바람직합니다.</p>
</dd></dl>

</section>
<section id="introspection-helpers">
<h3>인트로스펙션 도우미<a class="headerlink" href="#introspection-helpers" title="제목 주소">¶</a></h3>
<dl class="function">
<dt id="typing.get_type_hints">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">get_type_hints</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">globalns=None</em>, <em class="sig-param">localns=None</em>, <em class="sig-param">include_extras=False</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_type_hints" title="정의 주소">¶</a></dt>
<dd><p>함수, 메서드, 모듈 또는 클래스 객체에 대한 형 힌트가 포함된 딕셔너리를 반환합니다.</p>
<p>이것은 종종 <code class="docutils literal notranslate"><span class="pre">obj.__annotations__</span></code>와 같습니다. 또한, 문자열 리터럴로 인코딩된 전방 참조는 <code class="docutils literal notranslate"><span class="pre">globals</span></code>와 <code class="docutils literal notranslate"><span class="pre">locals</span></code> 이름 공간에서 이를 평가하여 처리됩니다. 필요하면, 기본값이 <code class="docutils literal notranslate"><span class="pre">None</span></code>으로 설정되면 함수와 메서드 어노테이션에 <code class="docutils literal notranslate"><span class="pre">Optional[t]</span></code>가 추가됩니다. 클래스 <code class="docutils literal notranslate"><span class="pre">C</span></code>에 대해, <code class="docutils literal notranslate"><span class="pre">C.__mro__</span></code>의 역순으로 모든 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code>를 병합하여 만든 딕셔너리를 반환합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">include_extras</span></code>가 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정되어 있지 않은 한, 이 함수는 모든 <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">...]</span></code>를 <code class="docutils literal notranslate"><span class="pre">T</span></code>로 재귀적으로 치환합니다 (자세한 내용은 <a class="reference internal" href="#typing.Annotated" title="typing.Annotated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Annotated</span></code></a>를 참조하십시오). 예를 들면:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Student</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;some marker&#39;</span><span class="p">]</span>

<span class="n">get_type_hints</span><span class="p">(</span><span class="n">Student</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">}</span>
<span class="n">get_type_hints</span><span class="p">(</span><span class="n">Student</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">}</span>
<span class="n">get_type_hints</span><span class="p">(</span><span class="n">Student</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span>
    <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;some marker&#39;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">버전 3.9에서 변경: </span><span class="target" id="index-169"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0593"><strong>PEP 593</strong></a>의 일부로 <code class="docutils literal notranslate"><span class="pre">include_extras</span></code> 매개 변수를 추가했습니다.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="typing.get_args">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">get_args</code><span class="sig-paren">(</span><em class="sig-param">tp</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_args" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="typing.get_origin">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">get_origin</code><span class="sig-paren">(</span><em class="sig-param">tp</em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_origin" title="정의 주소">¶</a></dt>
<dd><p>제네릭 형과 특수 typing 형식에 대한 기본적인 인트로스펙션을 제공합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">X[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> 형식의 typing 객체의 경우, 이 함수는 <code class="docutils literal notranslate"><span class="pre">X</span></code>와 <code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">Z,</span> <span class="pre">...)</span></code>를 반환합니다. <code class="docutils literal notranslate"><span class="pre">X</span></code>가 내장이나 <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 클래스의 제네릭 에일리어스인 경우, 원래 클래스로 정규화됩니다. <code class="docutils literal notranslate"><span class="pre">X</span></code>가 다른 제네릭 형에 포함된 <a class="reference internal" href="#typing.Union" title="typing.Union"><code class="xref py py-class docutils literal notranslate"><span class="pre">Union</span></code></a>이나 <a class="reference internal" href="#typing.Literal" title="typing.Literal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Literal</span></code></a>이면, <code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">Z,</span> <span class="pre">...)</span></code>의 순서는 형 캐싱으로 인해 원래 인자 <code class="docutils literal notranslate"><span class="pre">[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code>의 순서와 다를 수 있습니다. 지원되지 않는 객체의 경우 각각 <code class="docutils literal notranslate"><span class="pre">None</span></code>과 <code class="docutils literal notranslate"><span class="pre">()</span></code>를 반환합니다. 예:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="ow">is</span> <span class="n">Union</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.8에 추가.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="typing.ForwardRef">
<em class="property">class </em><code class="sig-prename descclassname">typing.</code><code class="sig-name descname">ForwardRef</code><a class="headerlink" href="#typing.ForwardRef" title="정의 주소">¶</a></dt>
<dd><p>A class used for internal typing representation of string forward references.
For example, <code class="docutils literal notranslate"><span class="pre">List[&quot;SomeClass&quot;]</span></code> is implicitly transformed into
<code class="docutils literal notranslate"><span class="pre">List[ForwardRef(&quot;SomeClass&quot;)]</span></code>.  This class should not be instantiated by
a user, but may be used by introspection tools.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p><span class="target" id="index-66"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> generic types such as <code class="docutils literal notranslate"><span class="pre">list[&quot;SomeClass&quot;]</span></code> will not be
implicitly transformed into <code class="docutils literal notranslate"><span class="pre">list[ForwardRef(&quot;SomeClass&quot;)]</span></code> and thus
will not automatically resolve to <code class="docutils literal notranslate"><span class="pre">list[SomeClass]</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.7.4에 추가.</span></p>
</div>
</dd></dl>

</section>
<section id="constant">
<h3>상수<a class="headerlink" href="#constant" title="제목 주소">¶</a></h3>
<dl class="data">
<dt id="typing.TYPE_CHECKING">
<code class="sig-prename descclassname">typing.</code><code class="sig-name descname">TYPE_CHECKING</code><a class="headerlink" href="#typing.TYPE_CHECKING" title="정의 주소">¶</a></dt>
<dd><p>제삼자 정적 형 검사기에 의해 <code class="docutils literal notranslate"><span class="pre">True</span></code>로 설정될 것으로 가정되는 특수 상수. 실행 시간에는 <code class="docutils literal notranslate"><span class="pre">False</span></code>입니다. 용법:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">expensive_mod</span>

<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="s1">&#39;expensive_mod.SomeType&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">local_var</span><span class="p">:</span> <span class="n">expensive_mod</span><span class="o">.</span><span class="n">AnotherType</span> <span class="o">=</span> <span class="n">other_fun</span><span class="p">()</span>
</pre></div>
</div>
<p>첫 번째 어노테이션은 따옴표로 묶여야 합니다, “전방 참조”로 만들어서 인터프리터 실행 시간에 <code class="docutils literal notranslate"><span class="pre">expensive_mod</span></code> 참조를 숨깁니다. 지역 변수에 대한 형 어노테이션은 평가되지 않기 때문에, 두 번째 어노테이션을 따옴표로 묶을 필요는 없습니다.</p>
<div class="admonition note">
<p class="admonition-title">참고</p>
<p>If <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code> is used,
annotations are not evaluated at function definition time.
Instead, they are stored as strings in <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code>.
This makes it unnecessary to use quotes around the annotation
(see <span class="target" id="index-67"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0563"><strong>PEP 563</strong></a>).</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">버전 3.5.2에 추가.</span></p>
</div>
</dd></dl>

</section>
</section>
</section>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> — 형 힌트 지원</a><ul>
<li><a class="reference internal" href="#relevant-peps">Relevant PEPs</a></li>
<li><a class="reference internal" href="#type-aliases">형 에일리어스</a></li>
<li><a class="reference internal" href="#newtype">NewType</a></li>
<li><a class="reference internal" href="#callable">Callable</a></li>
<li><a class="reference internal" href="#generics">제네릭</a></li>
<li><a class="reference internal" href="#user-defined-generic-types">사용자 정의 제네릭 형</a></li>
<li><a class="reference internal" href="#the-any-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code> 형</a></li>
<li><a class="reference internal" href="#nominal-vs-structural-subtyping">명목적 대 구조적 서브 타이핑</a></li>
<li><a class="reference internal" href="#module-contents">모듈 내용</a><ul>
<li><a class="reference internal" href="#special-typing-primitives">특수 타이핑 프리미티브</a><ul>
<li><a class="reference internal" href="#special-types">특수형</a></li>
<li><a class="reference internal" href="#special-forms">특수 형태</a></li>
<li><a class="reference internal" href="#building-generic-types">제네릭 형 구축하기</a></li>
<li><a class="reference internal" href="#other-special-directives">기타 특수 지시자</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic-concrete-collections">제네릭 구상 컬렉션</a><ul>
<li><a class="reference internal" href="#corresponding-to-built-in-types">내장형에 해당하는 것들</a></li>
<li><a class="reference internal" href="#corresponding-to-types-in-collections"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code>의 형에 해당하는 것들</a></li>
<li><a class="reference internal" href="#other-concrete-types">기타 구상형</a></li>
</ul>
</li>
<li><a class="reference internal" href="#abstract-base-classes">추상 베이스 클래스</a><ul>
<li><a class="reference internal" href="#corresponding-to-collections-in-collections-abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code>의 컬렉션에 해당하는 것들</a></li>
<li><a class="reference internal" href="#corresponding-to-other-types-in-collections-abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code>의 기타 형에 해당하는 것들</a></li>
<li><a class="reference internal" href="#asynchronous-programming">비동기 프로그래밍</a></li>
<li><a class="reference internal" href="#context-manager-types">컨텍스트 관리자 형</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocols">프로토콜</a></li>
<li><a class="reference internal" href="#functions-and-decorators">함수와 데코레이터</a></li>
<li><a class="reference internal" href="#introspection-helpers">인트로스펙션 도우미</a></li>
<li><a class="reference internal" href="#constant">상수</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>이전 항목</h4>
  <p class="topless"><a href="development.html"
                        title="이전 장">개발 도구</a></p>
  <h4>다음 항목</h4>
  <p class="topless"><a href="pydoc.html"
                        title="다음 장"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code> — 설명서 생성과 온라인 도움말 시스템</a></p>
  <div role="note" aria-label="source link">
    <h3>현재 문서</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고하기</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.9/Doc/library/typing.rst"
            rel="nofollow">소스 보기
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="전체 색인"
             >색인</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 모듈 목록"
             >모듈</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc — 설명서 생성과 온라인 도움말 시스템"
             >다음</a> |</li>
        <li class="right" >
          <a href="development.html" title="개발 도구"
             >이전</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.9.14 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >개발 도구</a> &#187;</li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="빠른 검색" aria-label="빠른 검색" type="text" name="q" />
          <input type="submit" value="이동" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">저작권</a> 2001-2022, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    최종 업데이트: 9월 11, 2022
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>

  </body>
</html>